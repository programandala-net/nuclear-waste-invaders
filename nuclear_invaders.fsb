( Nuclear Invaders )

  \ XXX UNDER DEVELOPMENT

\ Version 0.0.0+201602192153

\ Description

\ This game is a ZX Spectrum port (for Solo Forth:
\ http://programandala.net/en.program.solo_forth.html) of a
\ game written by Dancresp in 2013 for Jupiter ACE
\ (http://www.zonadepruebas.com/viewtopic.php?t=4231).

  \ This version:
\ Copyright (C) 2016 Marcos Cruz (programandala.net)

  \ Original version:
\ Copyright (C) 2013 Scainet Soft

\ License

\ You may do whatever you want with this work, so long as you
\ retain the copyright/authorship/acknowledgment/credit
\ notice(s) and this license in all redistributed copies and
\ derived works.  There is no warranty.

  \ History: see at the end of the file.

-->

( Requirements from the library of Solo Forth)

only forth definitions

need roll       need inkey    need bleep  need beep>bleep
need os-chars   need os-udg   need 2/     need abort"
need value      need case     need random
need columns    need rows     need ocr    need ms
need s+
\ need 0until \ XXX TODO

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

need benched    need ~~
13 ~~key !
  \ XXX TMP -- during the development

: debug-point  ( -- )  depth abort" depth is not zero"  ;
  \ XXX TMP for debugging

-->

( Screen and colors) debug-point

16384 constant sys-screen  6912 constant /sys-screen
                           6144 constant /sys-screen-bitmap
  \ Address and size of the screen.

22528 constant attributes  768 constant /attributes
  \ Address and size of the screen attributes.

0 constant black    1 constant blue   2 constant red
3 constant magenta  4 constant green  5 constant cyan
6 constant yellow   7 constant white

: papery   ( color -- paper-attribute )           8 *  ;
: brighty  ( attribute -- brighty-attribute )  64 and  ;
: flashy   ( attribute -- flashy-attribute )  128 and  ;

              black constant arena-color
                red constant brick-color
     yellow brighty constant container-color

: init-colors  ( -- )
  0 paper 7 ink 0 flash 0 bright 0 inverse 1 border  ;
  \ XXX TMP

-->

( Keyboard) debug-point

13 constant enter-key

  \ 'z' value left-key  'x' value right-key
'r' value left-key
't' value right-key
enter-key value fire-key
  \ XXX TMP
  \ XXX TODO -- configurable key sets

: .key  ( c -- )
  case
    enter-key of  ." Enter"  endof
           bl of  ." Space"  endof
    dup upper emit  \ default
  endcase  ;
  \ Print the name of the key that produces char _c_.

: wait  ( -- )  begin  inkey  until  ;
  \ Wait until any key is pressed.

: enter-key?  ( -- f )  inkey enter-key =  ;
  \ Is the Enter key pressed?

: wait-for-enter  ( -- )  begin  enter-key?  until  ;
  \ Wait until the Enter key is pressed.

-->

( Variables) debug-point

variable tank-x        \ coordinate (column)
variable shoot-x       \ coordinate (column)
variable shoot-y       \ coordinate (row), 0 if no shoot
variable ufo-x         \ coordinate (column)
variable lifes         \ counter (0..3)
variable level         \ counter (1..5)
variable score         \ counter
variable record        \ max score
variable invaders      \ counter
variable invader-type  \ element of table  (0..8)
variable catastrophe   \ flag (game end condition)

record off

-->

( beep ) debug-point

: beep  ( n1 n2 -- )  beep>bleep bleep  ;
  \ XXX TMP -- compatibility layer for the original code

-->

( .score .record update-score  ) debug-point

1 constant score-y

: (.score)  ( n x y -- )  at-xy s>d <# # # # #> type  ;
: .score  ( -- )  score @ 3 score-y (.score)  ;
: .record  ( -- )  record @ 14 score-y (.score)  ;
: update-score  ( n -- )  score +! .score  ;

-->

( udg-set >udg >scan scan! ) debug-point

          27 constant udgs   \ number of UDGs
           8 constant scans  \ scans per UDG
udgs scans * constant /udgs  \ size of the UDG set

create udg-set /udgs allot

: .udgs  ( -- )  cr udgs 0 do  i 'a' + emit  loop
                 cr udgs 0 do  i 128 + emit  loop  ;
  \ Print all game UDGs.
  \ XXX TMP -- for debugging

udg-set os-udg !
  \ Point system UDG to the game UDG set.
  \ Solo Forth will use this set for chars 128..255.

: >udg  ( c -- a )  'a' - scans * udg-set +  ;
  \ Convert UDG char _c_ to the address _a_ of its bitmap.

: >scan  ( n c -- a )  >udg +  ;
  \ Convert scan number _n_ of UDG char _c_ to its address _a_.

: scan!  ( c b n -- c )  rot >scan c!  ;
  \ Store scan _b_ into scan number _n_ of char _c_,
  \ and return _c_ back for further processing.

-->

( font! font@ graphic-font rom-font )

: font!  ( a -- )  os-chars !  ;
  \ Set the current charset to address _a_
  \ (the bitmap of char 0).

: font@  ( -- a )  os-chars @  ;
  \ Fetch the address _a_ of the current charset
  \ (the bitmap of char 0).

'a' constant first-sprite
    variable last-sprite

: init-ocr  ( -- )
  udg-set ocr-charset !  \ address of the first printable char
  first-sprite ocr-first !  \ its char code
  last-sprite @ first-sprite - ocr-chars !  ;  \ chars
  \ Set `ocr` to work with the sprites:
  \ Set the address of the first printable char to be
  \ examined, its char code and the number of examined chars.

: graphic-font  ( -- )
  [ udg-set 'a' scans * -  ] literal font!  ;
  \ Set a fake font whose chars "a".."|" are the game sprites.
  \ This way the original code will work without change.

: rom-font  ( -- )  15360 font!  ;
  \ Set ROM font for chars 0..127.

-->

( ~~ )

  \ Configure the debugging tool `~~`.

warnings @  warnings off

variable ~~font

: ~~(  ( -- )  font@ ~~font ! rom-font  ;
: ~~)  ( -- ) ~~font @ font!  ;

: ~~  ( -- )
  postpone ~~( postpone ~~  postpone ~~)  ; immediate

warnings !

-->

( sprite! 2sprite! ) debug-point

: sprite!  ( n0..n7 c -- )
  scans 0 do
    dup scans 1+ i - roll i scan!
  loop  drop  ;
  \ Store a 1x1 UDG sprite into char _c_.

: sprite  ( n0..n7 c "name" -- )  dup constant sprite!  ;

: 2sprite!  ( n0..n7 c -- )
  scans 0 do
    dup scans 1+ i - pick flip i scan! 1+  \ first UDG
    dup scans 1+ i - roll      i scan! 1-  \ second UDG
  loop  drop  ;
  \ Store a 2x1 UDG sprite into chars _c_ and _c_+1.
  \ Scans _n0..n7_ are 16-bit: high part is char _c_,
  \ and low part is the next char.

: 2sprite  ( n0..n7 c "name" -- )  dup constant 2sprite!  ;

: .2sprite  ( c -- )  dup emit 1+ emit  ;

-->

( sprites ) debug-point

binary

  \ "ab",  30 points invader, frame 1
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000010110100000
0000100000010000
0000010000100000

char a 2sprite!

decimal  -->

( sprites ) debug-point

binary

  \ "cd",  30 points invader, frame 2
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000001001000000
0000010110100000
0000101001010000

char c 2sprite invader-3

decimal  -->

( sprites ) debug-point

binary

  \ "ef",  20 points invader, frame 1
0000100000100000
0010010001001000
0010111111101000
0011101110111000
0011111111111000
0001111111110000
0000100000100000
0001000000010000

char e 2sprite!

decimal  -->

( sprites ) debug-point

binary

  \ "gh",  20 points invader, frame 2
0000100000100000
0000010001000000
0000111111100000
0001101110110000
0011111111111000
0011111111111000
0010100000101000
0000011011000000

char g 2sprite invader-2

decimal  -->

( sprites ) debug-point

binary

  \ "ij",  10 points invader, frame 1
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000111001110000
0001100110011000
0000110000110000

char i 2sprite!

decimal  -->

( sprites ) debug-point

binary

  \ "kl",  10 points invader, frame 2
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000011001100000
0000110110110000
0011000000001100

char k 2sprite invader-1

decimal  -->

( sprites ) debug-point

binary

  \ "mn", tank
0000000100000000
0000001110000000
0000001110000000
0111111111111100
1111111111111110
1111111111111110
1111111111111110
1111111111111110

char m 2sprite!

decimal  -->

( sprites ) debug-point

binary

  \ "op", ufo
0000000000000000
0000011111100000
0001111111111000
0011111111111100
0110110110110110
1111111111111111
0011100110011100
0001000000001000

char o 2sprite!

decimal  -->

( sprites ) debug-point

binary

  \ "qr", invader explosion
0000010001000000
0010001010001000
0001000000010000
0000100000100000
0110000000001100
0000010000100000
0001001010010000
0010010001001000

char q 2sprite!

decimal  -->

( sprites ) debug-point

binary

  \ "s", char 115, projectile
00000000
00000001
00000001
00000001
00000001
00000001
00000000
00000000

char s sprite!

decimal  -->

( sprites ) debug-point

binary

  \ "tu", UFO explosion
0000000000000010
0010000001100100
0100011111110000
0000111111111010
0001111011011001
0100110011110000
1000011111000100
0010001100010010

char t 2sprite!

decimal  -->

( sprites ) debug-point

binary

  \ "v", brick
11111011
11111011
11111011
00000000
11011111
11011111
11011111
00000000

char v sprite!

decimal  -->

( sprites ) debug-point

binary

  \ "w", horizontal ruler
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000000

char w sprite ruler

decimal  -->

( sprites ) debug-point

binary

  \ "xy", top of container
0000001111100000
0001110000011100
0010001111100010
0010000000000010
0010000111000010
0010001111100010
0010000111000010
0010000010000010

char x 2sprite!

decimal  -->

( sprites ) debug-point

binary

  \ "z{", bottom of container
0010010101010010
0010111101111010
0010111000111010
0010011000110010
0010000000000010
0001110000011100
0000001111100000
0000000000000000

char z 2sprite!

decimal  -->

( sprites ) debug-point

binary

  \ "|", blank
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

char | dup last-sprite ! sprite blank-char

decimal  -->

( centered center-type )

: centered  ( len -- column )  columns swap - 2/  ;
  \ Convert a string length to the column required
  \ to print the string centered.

: centered-at  ( row len -- )  centered swap at-xy  ;
  \ Set the cursor position to print string _ca len_ centered
  \ on the given row.

: center-type  ( ca len row -- )  over centered-at type  ;
  \ Print string _ca len_ centered on the given row.

: type-blank  ( ca len -- )  nip spaces  ;

: center-type-blank  ( ca len row -- )
  over centered-at type-blank ;
  \ Overwrite string _ca len_ with blanks, centered on the given row.

17 constant message-y  \ row for game messages

: message  ( ca len -- )
  2dup font@ >r rom-font message-y center-type  1500 ms
                         message-y center-type-blank
  r> font!  ;
  \ Print a game message _ca len_.

-->

( instructions ) debug-point

: title  ( -- )  s" NUCLEAR INVADERS" 0 center-type  ;

: (c)  ( -- )  127 emit  ;
  \ Print the copyright symbol.

: copyright  ( row -- )
  1 over    at-xy (c) ."  2013 Dancresp (Scainet Soft)"
  1 over 1+ at-xy (c) ."  2016 Marcos Cruz"
  8 swap 2+ at-xy           ." (programandala.net)"  ;
  \ Print the copyright starting at _row_.

: controls  ( row -- )
  dup s" [Space] to change controls:" rot center-type
  9 over 2+  at-xy ." Left  = " left-key .key
  9 over 3 + at-xy ." Right = " right-key .key
  9 swap 4 + at-xy ." Fire  = " fire-key .key  ;
  \ Print the controls starting at _row_.

-->

( instructions ) debug-point

: score-table-item  ( ca1 len1 ca2 len2 -- )
  font@ >r graphic-font type r> font! ."  = " type  ;
  \ Print an item of the score table, with sprite string _ca2
  \ len2_ and description _ca1 len1_

: score-table  ( row -- )
   9 over     at-xy s" 10 points" s" kl" score-table-item
   9 over 2+  at-xy s" 20 points" s" gh" score-table-item
   9 over 4 + at-xy s" 30 points" s" cd" score-table-item
   9 swap 6 + at-xy s" bonus"     s" op" score-table-item  ;
   \ Print the score table starting at the given row.

: instructions  ( -- )
  cls  title
                        3 score-table
                       12 controls
  s" [Enter] to start" 18 center-type
                       21 copyright
  wait-for-enter 200 ms  ;

-->

( game-screen ) debug-point

: clear-arena  ( -- )
  rom-font  0 2 at-xy 608 spaces  graphic-font  ;
  \ Clear the arena (the whole screen except the status bars).

: score-bar  ( -- )
  ."  SCORE<1>    RECORD    SCORE<2>"  .score .record  ;
  \ XXX TODO -- score 2 is not used in the original

: blinking-score  ( -- )
  10 0 do
    3 score-y at-xy 4 spaces 64 ms
    3 score-y at-xy ." 0000" 64 ms
  loop  ;
  \ XXX TODO -- not used yet

-->

( game-screen ) debug-point

22 constant status-bar-y

: bar-ruler  ( -- )
  graphic-font
  1 [ status-bar-y 1- ] literal at-xy ruler 30 emits
  rom-font  ;
  \ XXX TODO use a line instead

: life-icons  ( -- ca len )  s" mnmnmn" drop lifes @ 2*  ;
  \ String containing as much icons (tanks) as current lifes.

: .life-icons  ( -- )  life-icons type ." ||"  ;
  \ Print one icon for each remaining life.

: .lifes  ( -- )
  font@  rom-font 2 status-bar-y at-xy lifes ?
         graphic-font .life-icons
  font!  ;
  \ Print number of lifes and life icons.

: status-bar  ( -- )  bar-ruler .lifes  ;

: game-screen  ( -- )  init-colors cls score-bar status-bar  ;

-->

( invaders-min-x invaders-max-x ) debug-point

 1 constant invaders-min-x
29 constant invaders-max-x

-->

( invaders-data ) debug-point

  \ Invaders data is stored in a table.
  \ which has the following structure:
  \
  \ +0 = units (0..3)
  \ +2 = active? (0..1)
  \ +4 = y coordinate (row)
  \ +6 = x coordinate (column)
  \ +8 = main graphic (character)

  \ The `invader` variable points to the data of the current
  \ invader in the table.

     10 constant invader-types
6 cells constant /invader-type

create default-invaders-data
  \ Default invaders data table.
  \ This is used to restore the actual data table
  \ before a new game.

here

  \ units   active? x                 y    sprite       x inc
    3 ,     0 ,     invaders-min-x ,  5 ,  invader-3 ,  1 ,
    3 ,     0 ,     invaders-min-x ,  7 ,  invader-2 ,  1 ,
    3 ,     0 ,     invaders-min-x ,  9 ,  invader-2 ,  1 ,
    3 ,     0 ,     invaders-min-x , 11 ,  invader-1 ,  1 ,
    3 ,     0 ,     invaders-min-x , 13 ,  invader-1 ,  1 ,
    3 ,     0 ,     invaders-max-x ,  5 ,  invader-3 ,  -1 ,
    3 ,     0 ,     invaders-max-x ,  7 ,  invader-2 ,  -1 ,
    3 ,     0 ,     invaders-max-x ,  9 ,  invader-2 ,  -1 ,
    3 ,     0 ,     invaders-max-x , 11 ,  invader-1 ,  -1 ,
    3 ,     0 ,     invaders-max-x , 13 ,  invader-1 ,  -1 ,

here swap - constant /invaders-data  -->
  \ Space occupied by the invaders data.

  \ XXX TODO convert this table to a standard structure

( invaders-data ) debug-point

create invaders-data  /invaders-data allot
  \ Current invaders data.

: 'invader   ( -- a )
  invader-type @ /invader-type * invaders-data +  ;
  \ Data address _a_ of the current invader type.

: invader-units   ( -- a )  'invader            ;
: invader-active  ( -- a )  'invader cell+      ;
: invader-x       ( -- a )  'invader [ 2 cells ] literal +  ;
: invader-y       ( -- a )  'invader [ 3 cells ] literal +  ;

: invader-xy@    ( -- x y )  invader-x 2@  ;
: invader-char@  ( -- c )  'invader [ 4 cells ] literal + @  ;

: invader-x-inc@  ( -- n )
  'invader [ 5 cells ] literal + @  ;

-->

( brick bricks containers-top containers-bottom ) debug-point

: brick  ( -- )  ." v"  ;

here 1+ s" vvvvvvvvvvvv" s, constant bricks
  \ Compile a string of bricks and save the address
  \ of its first char.

here 1+ s" vxyxyxyxyxy" s, constant containers-top
here 1+ s" vz{z{z{z{z{" s, constant containers-bottom
  \ Compile strings which hold a brick followed by nuclear
  \ containers (top and bottom parts) and save the addresses of
  \ their first char.

-->

( set-building-size ) debug-point

 4 constant building-top-y
15 constant building-bottom-y
   variable building-left-x
   variable building-right-x
   variable containers-left-x
   variable containers-right-x

: set-building-size  ( -- )
  [ columns 2/ 1- ] literal level @ -
  dup building-left-x !
  dup 1+ containers-left-x !
      columns swap - dup containers-right-x !
                         1+ building-right-x !  ;
  \ Set the size of the building after the current level.

-->

( increase-level update-level init-level ) debug-point

5 constant max-level

: increase-level  ( -- )  level @ 1+ max-level min level +!  ;
  \ Increase the level number.

: update-level  ( -- )  increase-level set-building-size  ;

: init-level  ( -- )  level off  update-level  ;
  \ Init the level number and the related variables
  \ (the size of the bulding).

-->

( building ) debug-point

: building-width  ( -- n )  level @ 2* 2+  ;

: building  ( -- )

  bricks building-width 2dup
  building-left-x @ building-bottom-y at-xy type

  level @ 2* 1+  building-left-x @

  building-top-y
  [ building-bottom-y 2- ] literal
  do
    2dup 2dup
    i 1+ at-xy containers-bottom swap type brick
    i    at-xy containers-top    swap type brick
  -2 +loop  2drop

  building-left-x @ building-top-y    at-xy type  ;
  \ Draw the building and the nuclear containers.

-->

( init ) debug-point

: init-game  ( -- )
  init-ocr  3 lifes !  init-level  score off  game-screen  ;

: init-invaders-data  ( -- )
  default-invaders-data invaders-data /invaders-data move  ;

: init-ufo  ( -- )  -200 ufo-x !  ;

: total-invaders  ( -- n )
  0
  invader-types 0 do
    i invader-type ! invader-units @ +
  loop  ;
  \ Total number of invaders (sum of units of all invader
  \ types).

: init-invaders  ( -- )
  init-invaders-data  0 invader-type !
  total-invaders invaders !  ;

: init-tank  ( -- )  3 tank-x !  shoot-y off  ;  -->

( init ) debug-point

: parade  ( -- )
  invader-1 dup invader-2 dup invader-3
  building-bottom-y [ building-top-y 1+ ] literal
  do
    invaders-min-x i at-xy dup .2sprite
    invaders-max-x i at-xy     .2sprite
  2 +loop  ;
  \ Show the invaders at their initial positions.

: init-arena  ( -- )   clear-arena building parade  ;

: level-message  ( -- ca len )
  s" LEVEL " level @ s>d <# # #> s+  ;

: show-level  ( -- ) level-message message  ;

: init-combat  ( -- )
  catastrophe off
  init-invaders init-ufo init-tank init-arena show-level  ;

-->

( drive ) debug-point

20 constant tank-y      \ row of the tank
 3 constant tank-min-x  \ mininum column of the tank
27 constant tank-max-x  \ maximum column of the tank

: tank-limit  ( column -- column' )
  tank-max-x min tank-min-x max  ;
  \ Adjust the given column to the limits of the tank.

: drive  ( -- )
  inkey tank-x @ over left-key  =     +
                 swap right-key = abs +
  tank-limit dup tank-x !
  1- tank-y at-xy ." |mn|" ;
  \ Move the tank depending on the key pressed.

-->

( invasion ) debug-point

: at-invader  ( -- )  invader-xy@ at-xy  ;
  \ Set the cursor position at the coordinates of the invader.

: invader-frame  ( -- c )
  invader-char@ invader-x @ 2 mod 0> 2* +  ;
  \ Frame of the invader.

: .invader  ( -- )  invader-frame .2sprite  ;
  \ Print the current invader.

: container-reached?  ( -- f )
  invader-x @
  invader-x-inc@ 0>  \ flying to the right?
  if  building-left-x  else  containers-right-x  then  @ =  ;
  \ Has the current invader reached a container?
  \ XXX FIXME --

: damages  ( -- )  container-reached? catastrophe !  ;

  \ : damages  ( -- )  container-reached?
  \ if at-invader  font@ rom-font ." X" font! key drop
  \    catastrophe on then  ;
  \ XXX TMP --

-->

( invasion )

: flying-invader  ( -- )
  at-invader
  invader-x-inc@ dup 0>  \ flying to the right?
  if    blank-char emit .invader invader-x +!
  else  invader-x +! .invader blank-char emit  then  ;

-->

( invasion ) debug-point

: activate-invader  ( -- )
  32 random  26 invaders @ 5 < 16 * -  > invader-active !  ;
  \ Activate the current invader, depending on a random
  \ calculation: If there are less than 5 invaders left, the
  \ chances of activation are 22/32, else 6/32.
  \ XXX TODO -- Simpler and faster? Proportional to the
  \ number of invaders?

: last-invader-type?  ( -- f )
  invader-type @ [ invader-types 1- ] literal =  ;

: next-invader  ( -- )
  last-invader-type?
  if  invader-type off  else  1 invader-type +!  then  ;

: move-invader  ( -- )
  invader-active @
  if  flying-invader damages  else  activate-invader  then  ;

: invasion  ( -- )
  invader-units @ if  move-invader  then  next-invader  ;
  \ Move the current invader, if there are units left of it,
  \ and then choose the next one. _f_ is true when
  \ the invader has reached the containers.

-->

( ufo ) debug-point

 3 constant ufo-y       \ coordinate (row)
27 constant ufo-max-x   \ coordinate (column)

: ufo-invisible?  ( -- f )  ufo-x @ 0<  ;
  \ Is the UFO invisible?

: at-ufo  ( -- )  ufo-x @ ufo-y at-xy  ;
  \ Set the cursor position at the coordinates of the UFO.

: -ufo  ( -- )  at-ufo ." |||" init-ufo  ;
  \ Delete and init the UFO.

: ufo-lost?  ( -- f )  ufo-x @ ufo-max-x >  ;
  \ Is the UFO lost?

: flying-ufo  ( -- )  1 ufo-x +! at-ufo ." |op"  ;
  \ Update the position of the UFO and show it.

: (ufo)  ( -- )  ufo-lost?  if  -ufo  else  flying-ufo  then  ;
  \ Manage the UFO.

: ufo  ( -- )
  ufo-invisible? if  1 ufo-x +!  else  (ufo)  then  ;
  \ Manage the UFO, if it's visible.

-->

( ufo-impacted ) debug-point

: ufo-bang  ( -- )  18 12 do  i 15 beep  loop  ;

: ufo-in-fire  ( -- )  ufo-x @ 1+ ufo-y at-xy ." tu"  ;

: ufo-explosion  ( -- )  ufo-in-fire ufo-bang  ;

: ufo-points  ( -- n )  32 random 12 / 1+ 50 *  ;
  \ Random points for impacting the UFO.

: ufo-bonus  ( -- )
  ufo-points dup ufo-x @ 1+ 3 at-xy .  update-score  ;
  \ Update the score with the UFO bonus.

: ufo-impacted  ( -- )
  ufo-explosion ufo-bonus 200 ms -ufo  ;

-->

( invader-impacted ) debug-point

: invader-points  ( -- n )
  shoot-y @ 3 - 2/          \ depending on the row
  shoot-x @ 15 > abs 5 * +  \ add 5 when x>15  -- XXX why?
  shoot-y @
  dup 5 = if  drop 30
          else  10 > 10 * 20 +  then  ;
  \ Points for impacting an invader.
  \ XXX TODO dont't calculate; use the data table

: invader-bonus  ( -- )  invader-points  update-score  ;
  \ Update the score with the invader bonus.

: invader-explosion  ( -- )
  ;
  \ XXX TODO

: invader-impacted  ( -- )
  -1 invaders +!  invader-explosion invader-bonus  ;

-->

( impact ) debug-point

  \ XXX TODO -- factor

: invader-explosion  ( -- )
  2dup at-xy ." qr"  10 100 beep at-xy ." ||"  ;

: (impact)  ( -- )
  shoot-y @ ufo-y = if  ufo-impacted exit  then
  invader-impacted

  invader-type @ >r

  score @ 1- invader-type !
    \ XXX TODO -- check the original

  invader-x @ dup 15 < abs + invader-y @ invader-explosion

  -1 invader-units +!  invader-units @ if

    invader-active off
    shoot-x @ 15 < abs 29 * invader-x !  at-invader
    shoot-x @ 15 < if  ." |"  then
    invader-char@ .2sprite

  then  r> invader-type !  ;
  \ Manage the impact.

-->

( impact ) debug-point

: impact  ( -- )
  shoot-y @ 15 < if  (impact)  then  shoot-y off  ;
  \ Manage the impact, if the projectil is high enough.

: hit?  ( -- )  shoot-x @ shoot-y @ ocr blank-char <>  ;
  \ Did the projectile hit the target?

: impact?  ( -- f )  hit? dup if  impact  then  ;
  \ Did the projectil impacted?
  \ If so, do manage the impact.

-->

( shoot ) debug-point

: .projectile  ( -- )  shoot-x @ shoot-y @ at-xy 115 emit  ;
  \ Show the projectile.

: fire  ( -- )
  tank-x @ shoot-x ! [ tank-y 1- ] literal shoot-y !  ;
  \ The tank fires.

: -projectile  ( -- )  shoot-x @ shoot-y @ at-xy space  ;
  \ Delete the projectile.

: projectile-lost?  ( -- f )  shoot-y @ building-top-y <  ;
  \ Is the projectile lost?

: shooted  ( -- )
  -projectile  projectile-lost? if  shoot-y off exit  then
  -2 shoot-y +! impact? ?exit  .projectile  ;
  \ Manage the projectile.

: shooted?  ( -- )  shoot-y @  ;
  \ Has the tank already shooted?

: fire?  ( -- f )  inkey fire-key =  ;
  \ Is the fire key pressed?

: shoot  ( -- )
  shooted? if  shooted exit  then  fire? if  fire  then  ;
  \ Manage the shoot.
  \ XXX FIXME --

-->

( new-record? new-record check-record ) debug-point

: new-record?   ( -- f )  score @ record @ >  ;
: new-record    ( -- f )  score @ record !  ;
: check-record  ( -- )  new-record? if  new-record  then  ;

-->

( alive game-over next-level ) debug-point

: .game-over  ( -- )  s" GAME OVER" message  ;

: game-over  ( -- )  .game-over check-record  ;

: next-level  ( -- )  update-level show-level  ;

: dead  ( -- )  -1 lifes +!  .lifes  ;
  \ One life lost.

: tune  ( -- )  100 200 do  i 20 beep  -5 +loop  ;

: defeat  ( -- )  tune  300 ms  dead  ;

-->

( run ) debug-point

: victory?  ( -- f )  invaders @ 0=  ;

: (combat)  ( -- )
  begin   victory? if  next-level init-combat  then
          break-key? if  rom-font quit  then  \ XXX TMP
          drive shoot ufo invasion  catastrophe @
  until   defeat  ;

: combat  ( -- )
  graphic-font init-combat (combat)  rom-font  ;

: defeat?  ( f )  lifes @ 0=  ;

: game  ( -- )
  init-game  begin  combat defeat?  until  game-over  ;

: run  ( -- )  begin  instructions game  again  ;

-->

( Debugging tools)

: g0  ( -- )  rom-font  home  ;
: g1  ( -- )  graphic-font  ;
: g  ( xt -- )  g1 execute g0  ;
: cg  ( xt -- )  cls g1 execute g0  ;

  \ init-game init-invaders init-tank

  \ ==========================================================
  \ History

  \ This is mainly a compilation of the git commit comments.

  \ 2016-02-14:
  \
  \ Started changing the layout of the original
  \ source code.
  \
  \ 2016-02-15:
  \
  \ Change the layout of the source code.
  \ - Convert the source to lowercase.
  \ - Rename Spanish words to English.
  \ - Rename variables using meaningful names.
  \ - Indent the word definitions and the control structures.
  \ - Split lines at 63 columns.
  \ - Add block titles.
  \
  \ 2016-02-16:
  \
  \ Adapt graphics and data; start factoring.
  \ - Convert the graphics to binary numbers.
  \ - Implement words to define the graphics.
  \ - Adapt the invaders' data.
  \ - Factorize some words.
  \ - Adapt ACE Forth's `pick`.
  \ - Optimize some code idioms.
  \
  \ 2016-02-17:
  \
  \ Factor code, improve data, accelerate printing.
  \ - Factor the shoot manager.
  \ - Factor the invaders' manager.
  \ - Make the printing of containers faster.
  \ - Improve the invaders' data manipulation.
  \
  \ Finish the initial version of the game screens.
  \ - Convert the last `at-yx` to `at-xy`.
  \ - Add first words to support color.
  \ - Factor, modify and combine the presentation and
  \   instructions screens.
  \ - Name the main sprites.
  \ - Improve the logic of the game round loop.
  \ - Factor the arena screen.
  \ - Factor the printing of lifes.
  \
  \ 2016-02-18:
  \
  \ Fix record, data, phase; simplify lifes and font.
  \ - Fix record init.
  \ - Fix access to invaders' data.
  \ - Factor status bar.
  \ - Simplify printing of lifes (number and icons).
  \ - Simplify selecting the font.
  \ - Fix the phase incrementer.
  \
  \ 2016-02-19:
  \
  \ Factor, fix and improve algorithms.
  \ - Factor the calculation of the last invader type.
  \ - Factor the calculation of the invaders' direction.
  \ - Factor and fix the ending condition in the combat loop.
  \ - Fix the invaders' data.
  \ - Fix the reading of movement keys.
  \ - Fix and improve the phase update.
  \ - Fix the initial position of the building and the
  \   invaders.
  \ - Standardize the pauses.
  \ - Add the invaders' direction to the data table.
  \ - Fix the movement of invaders.
  \ - Improve access to both coordinates of current invader.

\ vim: filetype=soloforth
