( Nuclear Invaders )

  \ XXX UNDER DEVELOPMENT

\ Version 0.0.0+201602232200

\ Description

\ This game is a ZX Spectrum port (for Solo Forth:
\ http://programandala.net/en.program.solo_forth.html) of a
\ game written by Dancresp in 2013 for Jupiter ACE
\ (http://www.zonadepruebas.com/viewtopic.php?t=4231).

  \ This version:
\ Copyright (C) 2016 Marcos Cruz (programandala.net)

  \ Original version:
\ Copyright (C) 2013 Scainet Soft

\ License

\ You may do whatever you want with this work, so long as you
\ retain the copyright/authorship/acknowledgment/credit
\ notice(s) and this license in all redistributed copies and
\ derived works.  There is no warranty.

  \ History: see at the end of the file.

-->

( Requirements)

only forth definitions

  \ From the library of Solo Forth

need roll      need inkey   need bleep        need beep>bleep
need os-chars  need os-udg  need 2/           need abort"
need value     need case    need random       need columns
need rows      need ocr     need ms           need s+
need 2value    need row     need char>string  need s\"
need alias

4 constant /kk
need kk-ports  need kk-1#   need pressed?     need kk-chars

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

need benched    need ~~   13 ~~key !
  \ XXX TMP -- during the development

-->

( Debug tools)

: debug-point  ( -- )
  depth abort" Stack is not empty"
  \ ." blk " blk @ .
  \ key drop
  ;
  \ Abort if the stack is not empty.
  \ XXX TMP -- for debugging

-->

( Screen and colors) debug-point

16384 constant sys-screen  6912 constant /sys-screen
                           6144 constant /sys-screen-bitmap
  \ Address and size of the screen.
  \ XXX TODO -- not used yet

22528 constant attributes  768 constant /attributes
  \ Address and size of the screen attributes.
  \ XXX TODO -- not used yet

0 constant black    1 constant blue   2 constant red
3 constant magenta  4 constant green  5 constant cyan
6 constant yellow   7 constant white

: papery   ( color -- paper-attribute )           8 *  ;
: brighty  ( attribute -- brighty-attribute )  64 and  ;
: flashy   ( attribute -- flashy-attribute )  128 and  ;

              black constant arena-color
                red constant brick-color
     yellow brighty constant container-color
     \ XXX TODO -- not used yet

: init-colors  ( -- )
  0 paper 7 ink 0 flash 0 bright 0 inverse 0 border  ;
  \ XXX TMP --

-->

( Variables) debug-point

variable tank-x        \ coordinate (column)
variable projectile-x  \ coordinate (column)
variable projectile-y  \ coordinate (row), 0 if no shoot
variable ufo-x         \ coordinate (column)
variable lifes         \ counter (0..3)
variable level         \ counter (1..5)
variable score         \ counter
variable record        \ max score
variable invaders      \ counter (all units of every type)
variable invader-type  \ element of table  (0..9)
variable catastrophe   \ flag (game end condition)

record off

-->

( Keyboard) debug-point

13 constant enter-key

0 value kk-left#    0 value kk-right#    0 value kk-fire#
0. 2value kk-left   0. 2value kk-right   0. 2value kk-fire

: wait  ( -- )  begin  inkey  until  ;
  \ Wait until any key is pressed.

: enter-key?  ( -- f )  inkey enter-key =  ;
  \ Is the Enter key pressed?

: wait-for-enter  ( -- )  begin  enter-key?  until  ;
  \ Wait until the Enter key is pressed.

-->

( .kk# )

: kk#>c  ( n -- c )  kk-chars + c@  ;
  \ Convert key number _n_ to its char _c_.

: .kk#  ( n -- )
  case  kk-en# of  ." Enter"         endof
        kk-sp# of  ." Space"         endof
  \      kk-cs# of  ." Caps Shift"    endof  \ XXX OLD
  \      kk-ss# of  ." Symbol Shift"  endof  \ XXX OLD
        dup kk#>c upper emit  \ default
  endcase  ;
  \ Print the name of key number _n_.
  \ XXX OLD

: kk#>string  ( n -- ca len )
  case  kk-en# of  s" Enter"         endof
        kk-sp# of  s" Space"         endof
  \      kk-cs# of  s" Caps Shift"    endof  \ XXX OLD
  \      kk-ss# of  s" Symbol Shift"  endof  \ XXX OLD
        dup kk#>c upper char>string rot  \ default
  endcase  ;

-->

( controls )

3 constant /controls
  \ Bytes per item in the `controls` table.

create controls  here
  \ left      right     fire
    kk-z# c,  kk-x# c,  kk-en# c,   \ from the original game
    kk-5# c,  kk-8# c,  kk-0#  c,   \ cursor joystick
    kk-5# c,  kk-8# c,  kk-sp# c,   \ cursor with Space
    kk-5# c,  kk-8# c,  kk-en# c,   \ cursor with Enter
    kk-1# c,  kk-2# c,  kk-5#  c,   \ Sinclair joystick 1
    kk-6# c,  kk-7# c,  kk-0#  c,   \ Sinclair joystick 2
    kk-o# c,  kk-p# c,  kk-q#  c,   \ QWERTY
    kk-n# c,  kk-m# c,  kk-q#  c,   \ QWERTY
    kk-q# c,  kk-w# c,  kk-p#  c,   \ QWERTY
    kk-z# c,  kk-x# c,  kk-p#  c,   \ QWERTY
    kk-r# c,  kk-t# c,  kk-en# c,   \ Spanish Dvorak keyboard

here swap - /controls / 1- constant max-controls
  \ Number of controls stored in `controls`.

-->

( next-controls )

: >controls  ( n -- a )  /controls * controls +  ;
  \ Convert controls number _n_ to their address _a_.

: #>kk  ( n -- d )  /kk * kk-ports + kk@  ;
  \ Convert keyboard key number _n_ to its data _d_ (bitmap and
  \ port).

: set-controls  ( n -- )
  >controls     dup c@  dup to kk-left#   #>kk 2to kk-left
             1+ dup c@  dup to kk-right#  #>kk 2to kk-right
             1+     c@  dup to kk-fire#   #>kk 2to kk-fire  ;
  \ Make controls number _n_ (item of the `controls` table) the
  \ current controls.

variable current-controls
  \ Index of the current controls in `controls` table.

current-controls off
current-controls @ set-controls
  \ Default controls.

: next-controls  ( -- )
  current-controls @ 1+  dup max-controls > 0= abs *
  dup current-controls !  set-controls  ;
  \ Change the current controls.

-->

( beep ) debug-point

: beep  ( n1 n2 -- )  beep>bleep bleep  ;
  \ XXX TMP -- compatibility layer for the original code
  \ XXX TODO -- adapt the original beeps

-->

( udg-set udg>bitmap >scan scan! ) debug-point

         34 constant udgs       \ number of UDGs
          8 constant /udg       \ bytes per UDG
udgs /udg * constant /udg-set   \ size of the UDG set in bytes

create udg-set /udg-set allot

udg-set os-udg !
  \ Point system UDG to the game UDG set.
  \ Solo Forth will use this set for chars 128..255.

: udg>bitmap  ( c -- a )  $80 - /udg * udg-set +  ;
  \ Convert UDG char _c_ to the address _a_ of its bitmap.
  \ $80 is the code of the first UDG in Solo Forth.

: >scan  ( n c -- a )  udg>bitmap +  ;
  \ Convert scan number _n_ of UDG char _c_ to its address _a_.

: scan!  ( c b n -- c )  rot >scan c!  ;
  \ Store scan _b_ into scan number _n_ of char _c_,
  \ and return _c_ back for further processing.

variable used-udgs  used-udgs off
  \ Counter of UDGs defined.

: ?free-udg  ( n -- )
  used-udgs +!  used-udgs @ udgs > abort" Too many UDGs"  ;
  \ Abort if there is not free space for _n_ UDGs?
  \ This is a check done during the interpretation of the
  \ source file.

-->

( font! font@ rom-font ) debug-point

: font!  ( a -- )  os-chars !  ;
  \ Set the current charset to address _a_
  \ (the bitmap of char 0).
  \ XXX OLD

: font@  ( -- a )  os-chars @  ;
  \ Fetch the address _a_ of the current charset
  \ (the bitmap of char 0).
  \ XXX OLD

variable ocr-first-udg
variable ocr-last-udg
  \ Char codes of the first and last UDG to be examined
  \ by `ocr`.

: init-ocr  ( -- )
  ocr-first-udg @ udg>bitmap ocr-charset !
    \ Set address of the first char bitmap to be examined.
  ocr-first-udg @ ocr-first !
    \ Its char code in the UDG set.
  ocr-last-udg @ ocr-first-udg @ - 1+ ocr-chars !  ;  \ chars
  \ Set the UDGs `ocr` will examine te detect collisions.
  \ Set the address of the first char bitmap to be
  \ examined, its char code and the number of examined chars.
  \ XXX TODO -- range: only chars that may be detected: brick
  \ and invaders.

: rom-font  ( -- )  15360 font!  ;
  \ Set ROM font for chars 0..127
  \ (in Solo Forth chars 128..255 are UDG).
  \ XXX OLD

-->

( ~~ )

  \ Configure the debugging tool `~~`, in order to activate the
  \ ROM font before printing the debug information, and restore
  \ the previous font at the end.

warnings @  warnings off

variable ~~base

: ~~(  ( -- )  base @ ~~base ! decimal  ;

: ~~)  ( -- )  ~~base @ base !  ;

: ~~  ( -- )
  postpone ~~( postpone ~~  postpone ~~)  ; immediate

~~? off

warnings !

: XXX  ( -- )
  ~~? on
  base @ >r decimal latest .name .s r> base !
  key drop ;

-->

( .score .record update-score  ) debug-point

 1 constant score-y
14 constant record-x

variable players  1 players !  \ XXX TODO -- not used yet
variable player   1 player !   \ XXX TODO -- not used yet

: score-x  ( -- x )  3 player @ 1- 22 * +  ;
  \ Column of the score of the current player.

: (.score)  ( n x y -- )  at-xy s>d <# # # # # #> type  ;
  \ Print score _n_ at coordinates _x y_.

: score-xy  ( -- x y )  score-x score-y  ;
  \ Coordinates of the score.

: at-score  ( -- )  score-xy at-xy  ;
  \ Set the cursor position at the score.

: .score  ( -- )  score @ score-xy (.score)  ;
  \ Print the score.

: .record  ( -- )  record @ record-x score-y (.score)  ;
  \ Print the record.

: update-score  ( n -- )  score +! .score  ;

-->

( latest-sprite-width latest-sprite-height )

$80 constant first-udg
$FF constant last-udg
    variable >udg  first-udg >udg !  \ next free UDG

variable latest-sprite-width
variable latest-sprite-height
variable latest-sprite-udg

: ?udg  ( c -- )  last-udg > abort" Too many UDGs"  ;
  \ Abort if UDG _n_ is too high.

: free-udg  ( n -- c )
  >udg @ dup latest-sprite-udg !
  tuck +  dup >udg !  1- ?udg  ;
  \ Free _n_ consecutive UDGs and return the first one _c_.

: latest-sprite-size!  ( width height -- )
  latest-sprite-height !  latest-sprite-width !  ;
  \ Update the size of the latest sprited defined.

-->

( sprite-string )

: ?sprite-height  ( -- )
  latest-sprite-height @ 1 >
  abort" Sprite height not supported for sprite strings"  ;

: sprite-string  ( "name" -- )
  ?sprite-height
  here latest-sprite-udg @  latest-sprite-width @ dup >r
  0 ?do  dup c, 1+  loop  drop  r> 2constant  ;
  \ Create a definition "name" that will return a string
  \ containing all UDGs of the lastest sprite defined.
  \ XXX TODO --

-->

( 1x1sprite! 1x1sprite )

: (1x1sprite!)  ( b0..b7 c -- )
  1 ?free-udg  1 1 latest-sprite-size!
  /udg 0 do
    dup /udg 1+ i - roll i scan!
  loop  drop  ;
  \ Store a 1x1 UDG sprite into UDG _c_.

: 1x1sprite!  ( b0..b7 -- )
  1 free-udg (1x1sprite!)  ;
  \ Store a 1x1 UDG sprite into the next available UDG.

: 1x1sprite  ( n0..n7 "name" -- )
  1 free-udg dup constant (1x1sprite!)  ;

 ' emit alias .1x1sprite   ( c -- )
' emits alias .1x1sprites  ( c n -- )

-->

( 2x1sprite! 2x1sprite )

: (2x1sprite!)  ( n0..n7 c -- )
  2 ?free-udg  2 1 latest-sprite-size!
  /udg 0 do
    dup /udg 1+ i - pick flip i scan! 1+  \ first UDG
    dup /udg 1+ i - roll      i scan! 1-  \ second UDG
  loop  drop  ;
  \ Store a 2x1 UDG sprite into chars _c_ and _c_+1.
  \ Scans _n0..n7_ are 16-bit: high part is char _c_,
  \ and low part is _c_+1.

: 2x1sprite!  ( n0..n7 -- )
  2 free-udg (2x1sprite!)  ;
  \ Store a 2x1 UDG sprite into the next two available UDGs.
  \ Scans _n0..n7_ are 16-bit: high part is char _c_, and low
  \ part is _c_+1.

: 2x1sprite  ( n0..n7 "name" -- )
  2 free-udg dup constant (2x1sprite!)  ;

: .2x1sprite  ( c -- )  dup emit 1+ emit  ;

-->

( invader-3 ) debug-point

  \ XXX TODO -- make the UDG code selection automatic

>udg @ ocr-first-udg !
  \ The first UDG examined by `ocr` must be the first one of
  \ the next sprite.

binary

  \ invader 3, frame 1
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000010110100000
0000100000010000
0000010000100000

2x1sprite!

decimal  -->

( invader-3 invader-3$ ) debug-point

binary

  \ invader 3, frame 2
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000001001000000
0000010110100000
0000101001010000

2x1sprite invader-3
sprite-string invader-3$  ( -- ca len )

decimal  -->

( invader-2 ) debug-point

binary

  \ invader 2 , frame 1
0000100000100000
0010010001001000
0010111111101000
0011101110111000
0011111111111000
0001111111110000
0000100000100000
0001000000010000

2x1sprite!

decimal  -->

( invader-2 invader-2$ ) debug-point

binary

  \ invader 2, frame 2
0000100000100000
0000010001000000
0000111111100000
0001101110110000
0011111111111000
0011111111111000
0010100000101000
0000011011000000

2x1sprite invader-2
sprite-string invader-2$  ( -- ca len )

decimal  -->

( invader-1 ) debug-point

binary

  \ invader 1, frame 1
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000111001110000
0001100110011000
0000110000110000

2x1sprite!

decimal  -->

( invader-1 invader-1$ ) debug-point

binary

  \ invader 1, frame 2
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000011001100000
0000110110110000
0011000000001100

2x1sprite invader-1
sprite-string invader-1$  ( -- ca len )

decimal  -->

( ufo$ ) debug-point

binary

  \ ufo
  \ XXX TODO -- second frame

0000000000000000
0000011111100000
0001111111111000
0011111111111100
0110110110110110
1111111111111111
0011100110011100
0001000000001000

2x1sprite!
sprite-string ufo$  ( -- ca len )

>udg @ 1- ocr-last-udg !
  \ The last UDG examined by `ocr` must be the last one
  \ of the latest sprite.

decimal  -->

( tank$ ) debug-point

binary

  \ XXX TODO -- second frame

  \ tank
0000000100000000
0000001110000000
0000001110000000
0111111111111100
1111111111111110
1111111111111110
1111111111111110
1111111111111110

2x1sprite!
sprite-string tank$  ( -- ca len )

decimal  -->

( invader-explosion$ ) debug-point

binary

  \ invader explosion
0000010001000000
0010001010001000
0001000000010000
0000100000100000
0110000000001100
0000010000100000
0001001010010000
0010010001001000

2x1sprite!
sprite-string invader-explosion$  ( -- ca len )

decimal  -->

( projectile ) debug-point

binary

  \ projectile
00000000
00000001
00000001
00000001
00000001
00000001
00000000
00000000

1x1sprite projectile

decimal  -->

( ufo-explosion$ ) debug-point

binary

  \ UFO explosion
0000000000000010
0010000001100100
0100011111110000
0000111111111010
0001111011011001
0100110011110000
1000011111000100
0010001100010010

2x1sprite!
sprite-string ufo-explosion$  ( -- ca len )

decimal  -->

( brick ) debug-point

binary

  \ brick
11111011
11111011
11111011
00000000
11011111
11011111
11011111
00000000

1x1sprite brick

decimal  -->

( ruler ) debug-point

binary

  \ horizontal ruler
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000000

1x1sprite ruler

decimal  -->

( Top of container) debug-point

binary

  \ top of container
0000001111100000
0001110000011100
0010001111100010
0010000000000010
0010000111000010
0010001111100010
0010000111000010
0010000010000010

2x1sprite!

decimal  -->

( Bottom of container) debug-point

binary

  \ bottom of container
0010010101010010
0010111101111010
0010111000111010
0010011000110010
0010000000000010
0001110000011100
0000001111100000
0000000000000000

2x1sprite!

decimal  -->

( graphic-bl graphic-space ) debug-point

-->  \ XXX OLD

binary

  \ blank
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

1x1sprite graphic-bl
: graphic-space  ( -- )  graphic-bl .1x1sprite  ;

decimal  -->

( sprites ) debug-point

  \ XXX OLD

binary
0000000000000000
0000000000001000
0000000000001100
0000111111111110
0000111111111111
0000111111111110
0000000000001100
0000000000001000

2x1sprite right-arrow
sprite-string right-arrow$  ( -- ca len )

decimal  -->

( sprites ) debug-point

  \ XXX OLD

binary
0000000000000000
0001000000000000
0011000000000000
0111111111110000
1111111111110000
0111111111110000
0011000000000000
0001000000000000

2x1sprite left-arrow
sprite-string left-arrow$  ( -- ca len )

decimal  -->

( sprites ) debug-point

  \ XXX OLD

binary
0000111111110000
0011000000001100
0011000000001100
0010111111110100
0010000000000100
0010000000000100
0010000000000100
1111111111111111

2x1sprite fire-button
sprite-string fire-button$  ( -- ca len )

decimal  -->

( centered center-type )  debug-point

: centered  ( len -- column )  columns swap - 2/  ;
  \ Convert a string length to the column required
  \ to print the string centered.

: centered-at  ( row len -- )  centered swap at-xy  ;
  \ Set the cursor position to print string _ca len_ centered
  \ on the given row.

: center-type  ( ca len row -- )  over centered-at type  ;
  \ Print string _ca len_ centered on the given row.

: type-blank  ( ca len -- )  nip spaces  ;

: center-type-blank  ( ca len row -- )
  over centered-at type-blank ;
  \ Overwrite string _ca len_ with blanks, centered on the given row.

17 constant message-y  \ row for game messages

: message  ( ca len -- )
  2dup message-y center-type  1500 ms
       message-y center-type-blank  ;
  \ Print a game message _ca len_.

-->

( instructions ) debug-point

: title  ( -- )  s" NUCLEAR INVADERS" 0 center-type  ;

: (c)  ( -- )  127 emit  ;
  \ Print the copyright symbol.

: .copyright  ( -- )
  row
  1 over    at-xy (c) ."  2013 Scainet Soft"
  1 over 1+ at-xy (c) ."  2016 Marcos Cruz"
  8 swap 2+ at-xy           ." (programandala.net)"  ;
  \ Print the copyright notice at the current row.

-->

( instructions ) debug-point

  \ XXX OLD
  \ : .control  ( n -- )  ."  = " .kk# 4 spaces  ;
  \ : .controls  ( -- )
  \   row dup s" [Space] to change controls:" rot center-type
  \   9 over 2+  at-xy ." Left " kk-left#  .control
  \   9 over 3 + at-xy ." Right" kk-right# .control
  \   9 swap 4 + at-xy ." Fire " kk-fire#  .control  ;
  \   \ Print controls at the current row.

: left-key$   ( -- ca len )  kk-left# kk#>string  ;
: right-key$  ( -- ca len )  kk-right# kk#>string  ;
: fire-key$   ( -- ca len )  kk-fire# kk#>string  ;

: controls$  ( -- ca len )
  left-arrow$ left-key$ s+
  s"   " s+ fire-key$ s+ s"   " s+
  right-key$ s+ right-arrow$ s+  ;
  \ String containing the description of the current controls.
  \ XXX TMP --
  \ XXX TODO -- rewrite

: .controls  ( -- )
  s" [Space] to change controls:" row dup >r center-type
  fire-button$ r@ 2+ center-type
  0 r@ 3 + at-xy columns spaces
  controls$ r> 3 + center-type  ;
  \ Print controls at the current row.
  \ XXX TMP --

: .score-table-item  ( ca1 len1 ca2 len2 -- )
  type ."  = " type  ;
  \ Print an item of the score table, with sprite string _ca2
  \ len2_ and description _ca1 len1_

-->

( instructions ) debug-point

9 constant score-table-x

: .score-table  ( -- )
  score-table-x row
  2dup     at-xy s" 10 points" invader-1$ .score-table-item
  2dup 2+  at-xy s" 20 points" invader-2$ .score-table-item
  2dup 4 + at-xy s" 30 points" invader-3$ .score-table-item
       6 + at-xy s" bonus"     ufo$       .score-table-item  ;
   \ Print the score table at the current row.

: show-controls  ( -- )  0 12 at-xy .controls  ;

: menu  ( -- )
  begin  key
    dup enter-key = if  drop exit  then
               bl = if  next-controls show-controls  then
  again  ;

-->

( instructions ) debug-point

: instructions  ( -- )
  cls  title
  0 3 at-xy .score-table
  show-controls
  s" [Enter] to start" 18 center-type
  0 21 at-xy .copyright
  menu  ;

-->

( game-screen ) debug-point

608 constant /arena

: clear-arena  ( -- )  0 2 at-xy /arena spaces  ;
  \ Clear the arena (the whole screen except the status bars).
  \ XXX TODO -- wipe attributes first

: score-bar$  ( -- ca len )
  s"  SCORE<1>    RECORD    SCORE<2>"  ;

: score-bar  ( -- )
  home score-bar$ type .score .record  ;
  \ XXX TODO -- support player 2

: show-player  ( -- )
  10 0 do  at-score 4 spaces 64 ms  .score 64 ms  loop  ;
  \ Show the current player by making its score blink.

-->

( game-screen ) debug-point

22 constant status-bar-y

: bar-ruler  ( -- )
  1 [ status-bar-y 1- ] literal at-xy
  ruler [ columns 2- ] literal .1x1sprites  ;
  \ XXX TODO -- use a line instead

: .life-icons  ( -- )
  lifes @ 0 ?do  tank$ type  loop  ."   "  ;
  \ Print one icon for each remaining life.

: .lifes  ( -- )
  2 status-bar-y at-xy lifes ? .life-icons  ;
  \ Print number of lifes and life icons.

: status-bar  ( -- )  bar-ruler .lifes  ;

: game-screen  ( -- )  init-colors cls score-bar status-bar  ;

-->

( invaders-min-x invaders-max-x ) debug-point

 1 constant invaders-min-x
29 constant invaders-max-x

-->

( invaders-data ) debug-point

  \ Invaders data is stored in a table.
  \ which has the following structure:
  \
  \ +0 = units (0..3)
  \ +2 = active? (0..1)
  \ +4 = y coordinate (row)
  \ +6 = x coordinate (column)
  \ +8 = main graphic (character)

  \ The `invader` variable points to the data of the current
  \ invader in the table.

     10 constant invader-types
6 cells constant /invader-type

create default-invaders-data
  \ Default invaders data table.
  \ This is used to restore the actual data table
  \ before a new game.

here

  \ units   active? y    x                 sprite       x inc
    3 ,     0 ,      5 , invaders-min-x ,  invader-3 ,   1 ,
    3 ,     0 ,      7 , invaders-min-x ,  invader-2 ,   1 ,
    3 ,     0 ,      9 , invaders-min-x ,  invader-2 ,   1 ,
    3 ,     0 ,     11 , invaders-min-x ,  invader-1 ,   1 ,
    3 ,     0 ,     13 , invaders-min-x ,  invader-1 ,   1 ,
    3 ,     0 ,      5 , invaders-max-x ,  invader-3 ,  -1 ,
    3 ,     0 ,      7 , invaders-max-x ,  invader-2 ,  -1 ,
    3 ,     0 ,      9 , invaders-max-x ,  invader-2 ,  -1 ,
    3 ,     0 ,     11 , invaders-max-x ,  invader-1 ,  -1 ,
    3 ,     0 ,     13 , invaders-max-x ,  invader-1 ,  -1 ,

here swap - constant /invaders-data  -->
  \ Space occupied by the invaders data.

  \ XXX TODO -- convert tables to standard structures

( invaders-data ) debug-point

create invaders-data  /invaders-data allot
  \ Current invaders data.

: >invader   ( -- n )  invader-type @ /invader-type *  ;
  \ Pointer of current invader type in a data table.

: 'invader   ( -- a )  >invader invaders-data +  ;
  \ Data address _a_ of the current invader type.

: 'default-invader   ( -- a )
  >invader default-invaders-data +  ;
  \ Default data address _a_ of the current invader type.

: invader-units   ( -- a )  'invader            ;
: invader-active  ( -- a )  'invader cell+      ;
: invader-y       ( -- a )  'invader [ 2 cells ] literal +  ;
: invader-x       ( -- a )  'invader [ 3 cells ] literal +  ;

: invader-xy@    ( -- x y )  invader-y 2@  ;
: invader-char@  ( -- c )  'invader [ 4 cells ] literal + @  ;

: invader-x-inc@  ( -- n )  'invader [ 5 cells ] literal + @  ;

: invader-default-x@    ( -- x y )
  'default-invader [ 3 cells ] literal + @  ;

-->

( brick bricks containers-top containers-bottom ) debug-point

here 1+ s\" \x95\x97\x98\x97\x98\x97\x98\x97\x98\x97\x98" s,
  constant containers-top
here 1+ s\" \x95\x99\x9A\x99\x9A\x99\x9A\x99\x9A\x99\x9A" s,
  constant containers-bottom
  \ Compile strings which hold a brick followed by nuclear
  \ containers (top and bottom parts) and save the addresses of
  \ their first char.

-->

( set-building-size ) debug-point

 4 constant building-top-y
15 constant building-bottom-y

variable building-width

variable building-left-x     variable building-right-x
variable containers-left-x   variable containers-right-x

: set-building-size  ( -- )
  level @ 2* 2+  building-width !
  [ columns 2/ 1- ] literal \ half of the screen
  level @ \ half width of all containers
  2dup 1- - containers-left-x !
  2dup    - building-left-x !
  2dup    + containers-right-x !
       1+ + building-right-x !  ;
  \ Set the size of the building after the current level.

-->

( increase-level update-level init-level ) debug-point

5 constant max-level

: increase-level  ( -- )  level @ 1+ max-level min level !  ;
  \ Increase the level number.

: update-level  ( -- )  increase-level set-building-size  ;

: init-level  ( -- )  level off  update-level  ;
  \ Init the level number and the related variables
  \ (the size of the bulding).

-->

( building ) debug-point

: building  ( -- )

  brick building-width @ 2dup
  building-left-x @ building-bottom-y at-xy .1x1sprites

  level @ 2* 1+  building-left-x @

  building-top-y
  [ building-bottom-y 2- ] literal
  do
    2dup 2dup
    i 1+ at-xy containers-bottom swap type brick .1x1sprite
    i    at-xy containers-top    swap type brick .1x1sprite
  -2 +loop  2drop

  building-left-x @ building-top-y    at-xy .1x1sprites  ;
  \ Draw the building and the nuclear containers.

-->

( init ) debug-point

: init-game  ( -- )
  init-ocr  3 lifes !  init-level  score off  game-screen  ;

: init-invaders-data  ( -- )
  default-invaders-data invaders-data /invaders-data move  ;

: init-ufo  ( -- )  -200 ufo-x !  ;

: total-invaders  ( -- n )
  0   invader-types 0 do
        i invader-type ! invader-units @ +
      loop  ;
  \ Total number of invaders (sum of units of all invader
  \ types).

: init-invaders  ( -- )
  init-invaders-data  invader-type off
  total-invaders invaders !  ;

: init-tank  ( -- )  3 tank-x !  projectile-y off  ;  -->

( init ) debug-point

: parade  ( -- )
  invader-1 dup invader-2 dup invader-3
  building-bottom-y [ building-top-y 1+ ] literal
  do
    invaders-min-x i at-xy dup .2x1sprite
    invaders-max-x i at-xy     .2x1sprite
  2 +loop  ;
  \ Show the invaders at their initial positions.

: init-arena  ( -- )   clear-arena building parade  ;

: level-message  ( -- ca len )
  s" LEVEL " level @ s>d <# # #> s+  ;

: show-level  ( -- ) level-message message  ;

: init-combat  ( -- )
  catastrophe off
  init-invaders init-ufo init-tank init-arena
  show-level show-player  ;  -->

( drive ) debug-point

20 constant tank-y      \ row of the tank
 3 constant tank-min-x  \ mininum column of the tank
27 constant tank-max-x  \ maximum column of the tank

: tank-limit  ( column -- column' )
  tank-max-x min tank-min-x max  ;
  \ Adjust the given column to the limits of the tank.

: drive  ( -- )
  tank-x @ kk-left  pressed? +
           kk-right pressed? abs +
  tank-limit dup tank-x !  1- tank-y
  at-xy space tank$ type space  ;
  \ Move the tank depending on the key pressed.

-->

( invasion ) debug-point

: at-invader  ( -- )  invader-xy@ at-xy  ;
  \ Set the cursor position at the coordinates of the invader.

: invader-frame  ( -- c )
  invader-char@ invader-x @ 2 mod 0> 2* +  ;
  \ Frame of the invader.

: .invader  ( -- )  invader-frame .2x1sprite  ;
  \ Print the current invader.

: broken-container?  ( -- f )
  invader-x @
  invader-x-inc@ 0>  \ flying to the right?
  if    1+ containers-left-x
  else  containers-right-x  then  @ =  ;
  \ Has the current invader broke a container?

: damages  ( -- )  broken-container? catastrophe !  ;

-->

( invasion )

: flying-invader  ( -- )
  invader-x-inc@ dup 0>  \ flying to the right?
  if    at-invader space .invader invader-x +!
  else  invader-x +! at-invader .invader space
  then  ;
  \ XXX TODO -- do not print the space when the invader is at
  \ the start position, so the start position may be the
  \ screen margin

-->

( invasion ) debug-point

: activate-invader  ( -- )
  32 random  26 invaders @ 5 < 16 * -  > invader-active !  ;
  \ Activate the current invader, depending on a random
  \ calculation: If there are less than 5 invaders left, the
  \ chances of activation are 22/32, else 6/32.
  \ XXX TODO -- Simpler and faster? Proportional to the
  \ number of invaders?

: last-invader-type?  ( -- f )
  invader-type @ [ invader-types 1- ] literal =  ;
  \ Is the current invader type the last one?

: next-invader  ( -- )
  last-invader-type?
  if  invader-type off  else  1 invader-type +!  then  ;
  \ Update the invader type to the next one.

variable delay  50 delay !  \ ms

: move-invader  ( -- )
  delay @ ms  \ XXX TMP --
  invader-active @
  if  flying-invader damages  else  activate-invader  then  ;
  \ Move the current invader if it's active, else
  \ just try to activate it.

: invasion  ( -- )
  invader-units @ if  move-invader  then  next-invader  ;
  \ Move the current invader, if there are units left of it,
  \ and then choose the next one.

-->

( ufo ) debug-point

 3 constant ufo-y       \ coordinate (row)
27 constant ufo-max-x   \ coordinate (column)

: ufo-invisible?  ( -- f )  ufo-x @ 0<  ;
  \ Is the UFO invisible?

: at-ufo  ( -- )  ufo-x @ ufo-y at-xy  ;
  \ Set the cursor position at the coordinates of the UFO.

: -ufo  ( -- )  at-ufo 3 spaces init-ufo  ;
  \ Delete and init the UFO.

: ufo-lost?  ( -- f )  ufo-x @ ufo-max-x >  ;
  \ Is the UFO lost?

: flying-ufo  ( -- )  1 ufo-x +! at-ufo space ufo$ type  ;
  \ Update the position of the UFO and show it.

: (ufo)  ( -- )  ufo-lost?  if  -ufo  else  flying-ufo  then  ;
  \ Manage the UFO.

: ufo  ( -- )
  ufo-invisible? if  1 ufo-x +!  else  (ufo)  then  ;
  \ Manage the UFO, if it's visible.

-->

( ufo-impacted ) debug-point

: ufo-bang  ( -- )  18 12 do  i 15 beep  loop  ;
  \ XXX TODO -- explosion sound

: ufo-on-fire  ( -- )
  ufo-x @ 1+ ufo-y at-xy ufo-explosion$ type  ;

: ufo-explosion  ( -- )  ufo-on-fire ufo-bang  ;

: ufo-points  ( -- n )  32 random 12 / 1+ 50 *  ;
  \ Random points for impacting the UFO.

: ufo-bonus  ( -- )
  ufo-points dup ufo-x @ 1+ ufo-y at-xy .  update-score  ;
  \ Update the score with the UFO bonus.

: ufo-impacted  ( -- )  ufo-explosion ufo-bonus 200 ms -ufo  ;

-->

( invader-impacted ) debug-point

: invader-points  ( -- n )
  projectile-y @ 3 - 2/          \ depending on the row
  \ projectile-x @ 15 > abs 5 * +  \ add 5 when x>15  -- XXX why?
  projectile-y @
  dup 5 = if  drop 30
          else  10 > 10 * 20 +  then  ;
  \ Points for impacting an invader.
  \ XXX TODO -- dont't calculate; use the data table

: invader-bonus  ( -- )  invader-points  update-score  ;
  \ Update the score with the invader bonus.

: invader-bang  ( -- ca len )  10 100 beep  ;
  \ XXX TODO -- explosion sound

: invader-on-fire  ( -- )
  at-invader invader-explosion$ type  ;

: -invader  ( -- )  at-invader 2 spaces  ;
  \ Delete the current invader.

: invader-explosion  ( -- )
  invader-on-fire invader-bang -invader  ;

-->

( invader-impacted ) debug-point

: impacted-invader  ( -- n )
  projectile-y @ [ building-top-y 1+ ] literal - 2/
  projectile-x @ [ columns 2/ ] literal > abs 5 * +  ;
  \ Invader type impacted calculated from the projectile
  \ coordinates: Invader types 0 and 5 are at the top, one row
  \ below the top of the building, types 1 and 6 are two lines
  \ below and so on. Types 0..4 are at the left of the
  \ screen; types 5..9 are at the right.

: invader-go-home  ( -- )
  invader-default-x@ invader-x !  at-invader
  invader-char@ .2x1sprite  ;

: current-invader-impacted  ( -- )
  invader-bonus invader-explosion
  -1 invaders +!  -1 invader-units +!
  invader-units @
  if  invader-active off  -invader  invader-go-home  then  ;

: invader-impacted  ( -- )
  invader-type @ >r  impacted-invader invader-type !
  current-invader-impacted  r> invader-type !  ;  -->
  \ A invader has been impacted by the projectile.
  \ Calculate its type, set it the current one and manage it.

( impact ) debug-point

: (impact)  ( -- )
  projectile-y @ ufo-y = if  ufo-impacted exit  then
  invader-impacted  ;
  \ Manage the impact.

: impact  ( -- )
  projectile-y @ building-bottom-y <
  if  (impact)  then  projectile-y off  ;
  \ Manage the impact, if the projectil is high enough.

: projectile-xy  ( -- x y )  projectile-x @ projectile-y @  ;
  \ Coordinates of the projectile.

: hit?  ( -- f )  projectile-xy ocr 0<>  ;
  \ Did the projectile hit the target?

: impact?  ( -- f )  hit? dup if  impact  then  ;
  \ Did the projectil impacted?
  \ If so, do manage the impact.

-->

( shoot ) debug-point

: at-projectile  ( -- )  projectile-xy at-xy  ;
  \ Set the cursor position at the coordinates of the
  \ projectile.

: .projectile  ( -- )  at-projectile projectile .1x1sprite  ;
  \ Show the projectile.

: fire-sound  ( -- )  ;
  \ XXX TODO -- 

: fire  ( -- )
  tank-x @ projectile-x !
  [ tank-y 1- ] literal projectile-y !  fire-sound  ;
  \ The tank fires.
  \ XXX TODO -- several projectiles at the same time

: -projectile  ( -- )  at-projectile space  ;
  \ Delete the projectile.

: projectile-lost?  ( -- f )
  projectile-y @ building-top-y <  ;
  \ Is the projectile lost?

-->

( shoot ) debug-point

: shooted  ( -- )
  -projectile  projectile-lost? if  projectile-y off exit  then
  -1 projectile-y +! impact? ?exit
  .projectile  ;
  \ Manage the projectile.

: shooted?  ( -- f )  projectile-y @ 0<>  ;
  \ Has the tank already shooted?

: fire?  ( -- f )  kk-fire pressed?  ;
  \ Is the fire key pressed?

: shoot  ( -- )
  shooted? if  shooted exit  then  fire? if  fire  then  ;
  \ Manage the shoot.

-->

( new-record? new-record check-record ) debug-point

: new-record?   ( -- f )  score @ record @ >  ;
  \ Is there a new record?

: new-record    ( -- f )  score @ record !  ;
  \ Set the new record.

: check-record  ( -- )  new-record? if  new-record  then  ;
  \ Check if there's a new record, and set it.

-->

( alive game-over next-level ) debug-point

: .game-over  ( -- )  s" GAME OVER" message  ;

: game-over  ( -- )  .game-over check-record  ;

: next-level  ( -- )  update-level show-level  ;

: dead  ( -- )  -1 lifes +!  .lifes  ;
  \ One life lost.

: defeat-tune  ( -- )  100 200 do  i 20 beep  -5 +loop  ;

: defeat  ( -- )  defeat-tune  300 ms  dead  ;

-->

( run ) debug-point

: victory?  ( -- f )  invaders @ 0=  ;

: (combat)  ( -- )
  begin   victory? if  next-level init-combat  then
          break-key? if  quit  then  \ XXX TMP
          drive shoot ufo invasion  catastrophe @
  until   defeat  ;

: combat  ( -- )  init-combat (combat)  ;

: defeat?  ( f )  lifes @ 0=  ;

: game  ( -- )
  init-game  begin  combat defeat?  until  game-over  ;

: run  ( -- )  begin  instructions game  again  ;

-->

( Debugging tools)

  \ Words for testing and debugging the game.

: .udgs  ( -- )  cr udgs 0 do  i 128 + emit  loop  ;
  \ Print all game UDGs.

: ni  ( -- )      next-invader  ;
: m   ( -- )      move-invader broken-container? home .  ;
: in  ( -- )      init-game init-combat  ;

  \ ==========================================================
  \ History

  \ This is mainly a compilation of the git commit comments.

  \ 2016-02-14:
  \
  \ Started changing the layout of the original
  \ source code.
  \
  \ 2016-02-15:
  \
  \ - Convert the source to lowercase.
  \ - Rename Spanish words to English.
  \ - Rename variables using meaningful names.
  \ - Indent the word definitions and the control structures.
  \ - Split lines at 63 columns.
  \ - Add block titles.
  \
  \ 2016-02-16:
  \
  \ - Convert the graphics to binary numbers.
  \ - Implement words to define the graphics.
  \ - Adapt the invaders' data.
  \ - Factorize some words.
  \ - Adapt ACE Forth's `pick`.
  \ - Optimize some code idioms.
  \
  \ 2016-02-17:
  \
  \ - Factor the shoot manager.
  \ - Factor the invaders' manager.
  \ - Make the printing of containers faster.
  \ - Improve the invaders' data manipulation.
  \ - Convert the last `at-yx` to `at-xy`.
  \ - Add first words to support color.
  \ - Factor, modify and combine the presentation and
  \   instructions screens.
  \ - Name the main sprites.
  \ - Improve the logic of the game round loop.
  \ - Factor the arena screen.
  \ - Factor the printing of lifes.
  \
  \ 2016-02-18:
  \
  \ - Fix record init.
  \ - Fix access to invaders' data.
  \ - Factor status bar.
  \ - Simplify printing of lifes (number and icons).
  \ - Simplify selecting the font.
  \ - Fix the phase incrementer.
  \
  \ 2016-02-19:
  \
  \ - Factor the calculation of the last invader type.
  \ - Factor the calculation of the invaders' direction.
  \ - Factor and fix the ending condition in the combat loop.
  \ - Fix the invaders' data.
  \ - Fix the reading of movement keys.
  \ - Fix and improve the phase update.
  \ - Fix the initial position of the building and the
  \   invaders.
  \ - Standardize the pauses.
  \ - Add the invaders' direction to the data table.
  \ - Fix the movement of invaders.
  \ - Improve access to both coordinates of current invader.
  \
  \ 2016-02-20:
  \
  \ - Improve the keyboard reading.
  \ - Make the keyboard controls configurable.
  \ - Fix the storage of invaders' coordinates as a double
  \ number.
  \ - Fix and improve the calculation of the building size.
  \ - Fix the increasing of the level.
  \ - Fix the printing of lifes.
  \ - Fix the OCR init.
  \ - Add level 1.
  \
  \ 2016-02-21:
  \
  \ - Fix the printing of score.
  \ - Fix shooting and impacting.
  \
  \ 2016-02-22:
  \
  \ - Change the graphic codes.
  \ - Change the layout of controls' menu.
  \
  \ 2016-02-23:
  \
  \ - Factor the explosion of invaders.
  \ - Make the usage of UDG codes automatic.

\ vim: filetype=soloforth
