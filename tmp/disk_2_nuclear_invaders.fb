( Nuclear Invaders )                                            \ Description                                                   \ This game is a ZX Spectrum port (for Solo Forth:              \ http://programandala.net/en.program.solo_forth.html) of a     \ game written by Dancresp in 2013 for Jupiter ACE              \ (http://www.zonadepruebas.com/viewtopic.php?t=4231).          \ This version:                                                 \ Copyright (C) 2016 Marcos Cruz (programandala.net)            \ Original version:                                             \ Copyright (C) 2013 Scainet Soft                               \ License                                                       \ You may do whatever you want with this work, so long as you   \ retain the copyright/authorship/acknowledgment/credit         \ notice(s) and this license in all redistributed copies and    \ derived works.  There is no warranty.                                                                                         ( Nuclear Invaders -- load block  )                             2 load                                                          need load-section                                               load-section nuclear-invaders                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ( contains delimited located ?located )                         : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;       variable default-first-locatable  variable first-locatable      variable last-locatable  blk/disk 1- last-locatable !           : delimited  ( ca1 len1 -- ca2 len2 )                             dup 2+ dup allocate-string swap  ( ca1 len1 ca2 len2 )          2dup blank  2dup 2>r drop char+ smove 2r>  ;                  : located  ( ca len -- block | false )                            delimited  last-locatable @ 1+  first-locatable @               default-first-locatable @  first-locatable !                    do  0 i line>string 2over                                           contains if  2drop i unloop exit  then                          break-key? #-28 ?throw \ "user interrupt"                   loop  2drop 0  ;                                              2variable needed-word                                           -->                                                             ( ?located reneeded reneed needed-word [needed] [unneeded] )    : ?located  ( n -- )                                              dup ?exit  needed-word 2@ parsed-name 2! #-268 throw  ;       defer reneeded  ( ca len -- )                                   : locate-reneeded  ( ca len -- )  located ?located load  ;      defer reneed  ( "name" -- )                                     : locate-reneed  ( "name" -- )                                    parse-name save-string locate-reneeded  ;                     : [needed]  ( "name" -- f )                                       parse-name needed-word 2@ 2dup or                               if  compare 0= exit  then  2drop 2drop true  ; immediate      : [unneeded]  ( "name" -- f )                                     postpone [needed] 0=  ; immediate                             : new-needed-word  ( ca len -- ca' len' )                         -trailing -leading save-string 2dup needed-word 2!  ;         -->                                                             ( needed need )                                                 defer needed  ( ca len -- )                                     : locate-needed  ( ca len -- )                                    needed-word 2@ 2>r  new-needed-word  2dup undefined?            if  locate-reneeded  else  2drop  then  2r> needed-word 2!  ; defer need  ( "name" -- )                                       : locate-need  ( "name" -- )  parse-name locate-needed  ;       : set-located-need  ( -- )                                        ['] locate-reneeded ['] reneeded  defer!                        ['] locate-reneed   ['] reneed    defer!                        ['] locate-need     ['] need      defer!                        ['] locate-needed   ['] needed    defer!  ;                   set-located-need                                                blk @ 1+ dup default-first-locatable !  first-locatable !                                                                                                                                       ( locate from need-here )                                       [unneeded] locate [unneeded] from and                           ?\ : locate  ( "name" -- n )  parse-name save-string located  ; [unneeded] from                                                 ?\ : from  ( "name" -- )  locate ?located first-locatable !  ;  [unneeded] need-here ?exit                                      : need-here  ( "name" -- )                                        parse-name                                                      needed-word 2@ 2>r  new-needed-word  2dup undefined?            if  blk @ load  else  2drop  then  2r> needed-word 2!  ;                                                                                                                                                                                                                                                                                                                                                                                                      ( z80-asm )                                                     get-current forth-wordlist set-current                          need ?pairs  need 3dup                                          : 8*   ( n1 -- n2 )  2* 2* 2*  ;                                : z80-asm  ( -- )  assembler  ;                                 also assembler definitions base @ hex                           -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( z80-asm )                                                     0 constant b   1 constant c   2 constant d   3 constant e       4 constant h   5 constant l   6 constant m   7 constant a       0 constant bc  2 constant de  4 constant hl                     6 constant sp  6 constant af                                    DD constant ix-op  FD constant iy-op                            : ix  ( -- rphl )  ix-op c, hl  ;                               : iy  ( -- rphl )  iy-op c, hl  ;                               : ?page  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;        -->                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( z80-asm )                                                     : m1  ( 8b "name" -- )                                            create c, does>  ( -- )  ( pfa ) c@ c,  ;                     : m2  ( 8b "name" -- )                                            create c, does>  ( r -- )  ( r pfa ) c@ + c,  ;               : m3  ( 8b "name" -- )                                            create c, does>  ( r -- )  ( r pfa ) c@ swap 8* + c,  ;       : m4  ( 8b "name" -- )                                            create c, does>  ( 8b -- )  ( 8b pfa ) c@ c, c,  ;            : m5  ( 8b "name" -- )                                            create c, does>  ( 16b -- )  ( 16b pfa ) c@ c, ,  ;           : m6  ( 8b "name" -- )                                            create c, does>  ( r -- )  ( r pfa ) CB c, c@ + c,  ;           -->                                                                                                                                                                                           ( z80-asm )                                                     : m7  ( 8b "name" -- )                                            create c, does>  ( r bit -- )                                     ( r bit pfa ) CB c, c@ swap 8* + + c,  ;                    : m8  ( 16b "name" -- )                                           create , does>  ( -- )  ( pfa ) @ ,  ;                        : m9  ( 8b "name" -- )                                            create c, does>  ( a -- )                                         ( a pfa )  c@ c, here 1+ - ?page c,  ;                      -->                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( z80-asm )                                                     : ma  ( 8b "name" -- )                                            create c, does>  ( disp rphl -- )                                 ( disp rphl pfa ) c@ c, drop c,  ;                          : mb  ( 8b "name" -- )                                            create c, does>  ( disp rphl -- )                                 ( disp rphl pfa ) CB c, c@ c, drop c,  ;                    : mc  ( 8b "name" -- )                                            create c, does>  ( disp rphl bit -- )                             ( disp rphl bit pfa )                                           CB c, c@ rot drop rot c, swap 8* + c,  ;                    -->                                                                                                                                                                                                                                                                                                                             ( z80-asm )                                                     00 m1 nop 02 m3 stap 03 m3 incp 04 m3 inc 05 m3 dec 07 m1 rlca  08 m1 exaf 09 m3 addp 0A m3 ftap 0B m3 decp 0F m1 rrca 10 m9    djnz 17 m1 rla 18 m9 jr  1F m1 rra 20 m9 jrnz 22 m5 sthl 27 m1  daa 28 m9 jrz 2A m5 fthl 2F m1 cpl 30 m9 jrnc 32 m5 sta 37 m1   scf 38 m9 jrc 3A m5 fta 3F m1 ccf 76 m1 halt 80 m2 add 88 m2    adc 90 m2 sub 98 m2 sbc B8 m2 cp C1 m3 pop C2 m5 jpnz C3 m5 jp  C5 m3 push C6 m4 add# C7 m2 rst C9 m1 ret CA m5 jpz CD m5 call  CE m4 adc# D2 m5 jpnc D3 m4 out 41 m3 outbc D6 m4 sub# D9 m1    exx DA m5 jpc DB m4 in 40 m3 inbc 0DE m4 sbc# E2 m5 jppo E3 m1  exsp E6 m4 and# E9 m1 jphl EA m5 jppe EB m1 exde EE m4 xor# F2  m5 jpp F3 m1 di  F6 m4 or# F9 m1 ldsp FA m5 jpm FB m1 ei FE m4  cp# 00 m6 rlc 08 m6 rrc 10 m6 rl 18 m6 rr 20 m6 sla  28 m6 sra  38 m6 srl  40 m7 bit 80 m7 res C0 m7 set B0ED m8 ldir B8ED m8   lddr 44ED m8 neg 57ED m8 ldai 47ED m8 ldia 56ED m8 im1 5EED m8  im2 B1ED m8 cpir 6FED m8 rld -->                                ( z80-asm )                                                     : 0outbc  ( -- )  ED c, 71 c,  ;                                : jpix  ( -- )  ix-op c, jphl  ;                                : ldp#  ( 16b rp -- )  8* 1+ c, ,  ;                            : ld#  ( 8b r -- )  8* 06 + c, c,  ;                            : ld  ( r1 r2 -- )  8* 40 + + c,  ;                             : sbcp  ( rp -- )  ED c, 8* 42 + c,  ;                          : adcp  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;                     : stp  ( a rp -- )  ED c, 8* 43 + c, ,  ;                       : ftp  ( a rp -- )  ED c, 8* 4B + c, ,  ;                       : addix  ( rp -- )  ix-op c, addp  ;                            : addiy  ( rp -- )  iy-op c, addp  ;                            : clr  ( rp -- )  0 swap ldp#  ;                                : ldp  ( rp1 rp2 -- )  2dup ld 1+ swap 1+ swap ld  ;            CF m4 hook       \ rst 0x08                                     D7 m1 prt  -->   \ rst 0x16                                     ( z80-asm )                                                     86 ma addx 8E ma adcx 96 ma subx 9E ma sbcx A6 ma andx          AE ma xorx B6 ma orx  BE ma cpx  34 ma incx 35 ma decx          06 mb rlcx 0E mb rrcx 16 mb rlx  1E mb rrx  26 mb slax          2E mb srax 3E mb srlx 46 mc bitx 86 mc resx C6 mc setx          : ftx   ( disp rpi r -- )   nip 8* 46 + c, c,  ;                : stx   ( r disp rphl -- )  drop swap 70 + c, c,  ;             : st#x  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;            : ftpx  ( disp rpi rp -- )  3dup 1+ ftx rot 1+ -rot ftx  ;      : stpx  ( disp rpi rp -- )  3dup 1+ stx rot 1+ -rot stx  ;      -->                                                                                                                                                                                                                                                                                                                                                                                             ( z80-asm )                                                     20 constant z  28 constant nz  30 constant cy  38 constant nc   C2 constant z'  CA constant nz' D2 constant cy' DA constant nc' E2 constant pe' EA constant po' F2 constant m'  FA constant p'  : ?ret  ( op -- )  8 xor 2- c,  ;                               : retc  ( -- )  cy' ?ret ;    : retnc  ( -- )  nc' ?ret  ;      : retz  ( -- )  z' ?ret ;     : retnz  ( -- )  nz' ?ret  ;      : retm  ( -- )  m' ?ret ;     : retp  ( -- )  p' ?ret  ;        : retpe  ( -- )  pe' ?ret ;   : retpo  ( -- )  po' ?ret  ;      : ?call  ( a op -- )  8 xor 2+ c, ,  ;                          : callc  ( -- )  cy' ?call ;    : callnc  ( -- )  nc' ?call  ;  : callz  ( -- )  z' ?call ;     : callnz  ( -- )  nz' ?call  ;  : callm  ( -- )  m' ?call ;     : callp  ( -- )  p' ?call  ;    : callpe  ( -- )  pe' ?call ;   : callpo ( -- )  po' ?call  ;   -->                                                                                                                             ( z80-asm )                                                     : >relmark  ( -- orig )  here 1-  ;                             : relresolve  ( orig dest -- )  1- over - ?page swap c!  ;      : >relresolve  ( orig -- )  here relresolve  ;                  : <relresolve  ( dest -- )  here 1- swap relresolve  ;          : ahead  ( -- orig  )  18 , >relmark  ;                         : if  ( op -- orig cs-id )  , >relmark 0A  ;                    : then  ( orig cs-id -- )  0A ?pairs >relresolve  ;             : else  ( orig cs-id -- cs-id ) \ XXX TODO document               0A ?pairs 18 if rot swap then 0A  ;                           : begin  (  -- dest cs-id )  <mark 0B  ;                        : while  (  op -- orig cs-id )  if 2+  ;                        : until  (  dest cs-id op -- )  , 0B ?pairs <relresolve  ;      : again  (  dest cs-id -- )  18 until  ;                        : repeat  (  dest cs-id1 orig cs-id2 )  2swap again 2- then  ;  : step    ( dest cs-id -- )  10 until  ;  -->                   ( z80-asm )                                                     : if'  (  op -- orig cs-id )  c, >mark 08  ;                    : then'  (  orig cs-id -- )  08 ?pairs >resolve  ;              : else'  (  cs-id -- cs-id )                                      08 ?pairs C3 if' rot swap then' 08  ;                         : begin'  (  -- dest cs-id )  <mark 09  ;                       : while'  (  op -- orig cs-id )  if' 2+  ;                      : until'  (  cs-id op -- )  c, 09 ?pairs <resolve  ;            : again'  (  cs-id -- )  C3 until'  ;                           : repeat'  (  dest cs-id1 orig cs-id2 )                           2swap again' 2- then'  ;                                      : |mark  ( -- a )  here 2-  ;                                   : |resolve  ( a -- )  |mark swap !  ;                           -->                                                                                                                                                                                             ( z80-asm )                                                     A0 m2 and  B0 m2 or  A8 m2 xor                                  : subp  ( rp -- )  a and sbcp  ;                                : tstp  ( rp -- )  dup a ld 1+ or  ;                            -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( z80-asm )                                                     6 cells allocate-string                                         : unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop      base ! set-current previous                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( execute-hl call-xt )                                          need z80-asm  need macro                                        macro execute-hl  ( -- )                                          0000 bc stp  |mark  \ save the Forth IP                         0000 bc ldp# |mark  \ point IP to phony_compiled_word           jphl          \ execute the xt in HL                            >resolve \ phony_compiled_word                                  here cell+ ,      \ point to the phony xt following             0000 bc ldp#  |resolve  \ restore the Forth IP                  endm                                                          macro call-xt  ( xt -- )                                          hl ldp#  execute-hl                                             endm                                                                                                                                                                                                                                                          ( bench{ }bench }bench. bench. benched )                        need reset-frames  need frames@                                 : bench{  ( -- )  reset-frames  ;                               : }bench  ( -- d )  frames@ ;                                   : bench.  ( d -- )                                                2dup d. ." frames (" 50 m/ nip . ." s) "  ;                   : }bench.  ( -- )  frames@ bench.  ;                            : benched  ( xt n -- d )                                          bench{ 0 do  dup execute  loop  }bench rot drop  ;            : benched.  ( xt n -- )                                           bench{ 0 do  dup execute  loop  }bench. drop  ;                                                                                                                                                                                                                                                                                                                                               ( all-benchmarks )                                              need byte-magazine-benchmark                                    need interface-age-benchmark                                    need vector-loop-benchmark                                      : all-benchmarks  ( n1 n2 -- )                                    byte-magazine-benchmark                                         interface-age-benchmark                                         vector-loop-benchmark  ;                                        .( To run all benchmarks type:) cr                              .(   n1 n2 all-benchmarks) cr                                                                                                                                                                                                                                                                                                                                                                                                                                 ( ?--> update flush thru )                                      [unneeded] ?-->                                                 ?\ : ?-->  ( f -- )  if  postpone -->  then  ; immediate        [unneeded] update                                               ?\ : update  ( -- )  disk-buffer @ $8000 or disk-buffer !  ;    [unneeded] flush                                                ?\ : flush  ( -- )  save-buffers empty-buffers  ;               [unneeded] thru                                                 ?\ : thru  ( block1 block2 -- )  1+ swap ?do  i load  loop  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ( continued ?load reload loads +load +thru loader )             [unneeded] continued                                            ?\ : continued  ( u -- )  ?loading (load)  ;                    [unneeded] ?load                                                ?\ : ?load  ( block f -- )  if  dup load  then  drop  ;         [unneeded] reload                                               ?\ : reload  ( -- )  empty-buffers  scr @ load  ;               [unneeded] loads                                                ?\ : loads  ( block n -- )  bounds ?do  i load  loop  ;         [unneeded] +load  [unneeded] +thru  and                         ?\ : +load  ( n -- )  blk @ + load  ;                           [unneeded] +thru                                                ?\ : +thru  ( n1 n2 -- )  1+ swap do  i +load  loop  ;          [unneeded] loader ?exit                                         : loader  ( block "name" -- )                                     create ,  does>  ( pfa )  @ load  ;                           ( .line lineblock>source lineload load-section )                [unneeded] .line                                                ?\ : .line  ( n1 n2 -- )  line>string -trailing type  ;  exit   [unneeded] lineblock>source [unneeded] lineload and             ?\ : lineblock>source  ( n1 n2 -- )  blk !  c/l * >in !  ;      need ?( [unneeded] lineload ?(                                  : lineload  ( n1 n2 -- )                                          dup 0= #-259 ?throw                                             nest-source lineblock>source interpret unnest-source  ; ?)    [unneeded] load-section ?( need locate                          variable loading-section                                        : end-section  ( -- )  loading-section off  ;  end-section      : load-section  ( "name" -- )                                     loading-section on                                              blocks @ locate ?do   loading-section @ 0= ?leave  i load                       loop  end-section  ; ?)                       ( ascii-char? control-char? )                                   : ascii-char?    ( c -- f )  128 <  ;                           : control-char?  ( c -- f )  bl <  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ( [false] [true] [if] [else] [then] )                           [unneeded] [true]  ?\   0 constant [false] immediate exit       [unneeded] [false] ?\  -1 constant [true]  immediate exit       need str=                                                       : [else] ( "ccc" -- )                                             1 begin  begin  parse-name dup while  2dup s" [if]" str=                        if    2drop 1+                                                  else  2dup s" [else]" str=                                            if    2drop 1- dup if  1+  then                                 else  s" [then]" str= if  1-  then                              then                                                      then  ?dup 0= if exit then                               repeat  2drop                                            refill 0= until  drop  ; immediate                          : [if]  ( f "ccc" -- )  0= if postpone [else] then  ; immediate : [then]  ( -- )  ; immediate                                   ( ?( )                                                          need str=                                                       : ?(  ( f "ccc<space><question><paren><space>" -- )               0= ?exit  begin   parse-name dup                                          while   s" ?)" str= ?exit                                       repeat  ; immediate                                 : ?)  ( -- )  ; immediate                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ( body>name name>body link>name name>link name<name )           [unneeded] body>name                                            ?\ : body>name  ( pfa -- nt ) body> >name  ;                    [unneeded] name>body                                            ?\ : name>body  ( nt -- pfa ) name> >body  ;                    [unneeded] link>name                                            ?\ need alias  ' cell+ alias link>name  ( nt -- pfa )           [unneeded] name>link                                            ?\ need alias  ' cell- alias name>link  ( nt -- pfa )           [unneeded] name<name                                            ?\ need name>link  : name<name  ( nt1 -- nt2 )  name>link @s  ;                                                                                                                                                                                                                                                                                                                                 ( >>link name>> )                                               [unneeded] >>link                                               ?\ need alias  ' cell+ alias >>link  ( xtp -- lfa )             [unneeded] name>>                                               ?\ : name>>  ( nt -- xtp )  [ 2 cells ] literal -  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ( name>interpret name>compile comp' [comp'] )                   need ?(                                                         [unneeded] name>interpret ?(                                    : name>interpret  ( nt -- xt | 0 )                                dup name> swap compile-only? 0= and  ;  ?)                    [unneeded] name>compile ?(                                      : (comp')  ( nt -- xt )                                           immediate?  if    ['] execute                                               else  ['] compile,  then  ;                       : name>compile  ( nt -- x xt )  dup name> swap (comp')  ;  ?)   [unneeded] comp' ?(  need need-here  need-here name>compile     : comp'  ( "name" -- x xt )                                       defined dup ?defined name>compile  ;  ?)                      [unneeded] [comp'] ?(  need need-here  need-here comp'          : [comp']  ( Compilation: "name" -- ) ( Run-time: -- x xt )       comp' postpone 2literal  ; immediate compile-only  ?)         ( ?pairs [compile] smudge smudged )                             [unneeded] ?pairs                                               ?\ : ?pairs  ( x1 x2 -- )  <> #-22 ?throw  ;  exit              [unneeded] [compile]                                            ?\ : [compile]  ( "name" -- )  ' compile,  ; immediate  exit    need ?(                                                         [unneeded] smudged ?(  need c!toggle-bits                       : smudged  ( nt -- )                                              smudge-mask swap system-bank c!toggle-bits default-bank  ; ?) [unneeded] smudge ?(  need need-here  need-here smudged         : smudge  ( -- )  latest smudged  ;  ?)                                                                                                                                                                                                                                                                                                                                                         ( ]l ]2l exec eval save-here restore-here )                     need [if]                                                       [needed] ]l [if]                                                : ]l  ( x -- )  ] postpone literal  ; immediate compile-only    [then]                                                          [needed] ]2l [if]                                               : ]2l  ( xd -- )  ] postpone 2literal  ; immediate compile-only [then]                                                          [needed] save-here [needed] restore-here or [if]                variable here-backup                                            : save-here  ( -- )  here here-backup !  ;                      : restore-here  ( -- )  here-backup @ there  ;                  [then]                                                                                                                                                                                                                                                          ( possibly exec eval cliteral )                                 need ?(                                                         [unneeded] possibly ?(                                          : possibly  ( "name" -- )                                         defined ?dup if  name> execute  then  ; ?)                    [unneeded] exec ?(                                              : exec  ( "name" -- i*x )                                         defined ?dup 0= #-13 ?throw  name> execute  ; ?)              [unneeded] eval ?(                                              : eval  ( i*x "name" -- j*x )  parse-name evaluate  ; ?)        [unneeded] cliteral ?(                                          : cliteral  ( b -- )                                              compile clit c,  ; immediate compile-only ?)                                                                                                                                                                                                                  ( [const] [2const] [cconst] )                                   need ?(                                                         [unneeded] [const] ?(  need eval                                : [const]  ( "name" -- )                                          eval postpone literal  ; immediate compile-only  ?)           [unneeded] [2const] ?(  need eval                               : [2const]  ( "name" -- )                                         eval postpone 2literal  ; immediate compile-only  ?)          [unneeded] [cconst] ?(  need eval  need cliteral                : [cconst]  ( "name" -- )                                         eval postpone cliteral  ; immediate compile-only  ?)                                                                                                                                                                                                                                                                                                                                          ( warnings )                                                    need user  need search-wordlist                                 user warnings  \ flag                                           : no-warnings?  ( -- f )  warnings @ 0=  ;                      : not-redefined?  ( ca len -- ca len xt false | ca len true )     2dup get-current search-wordlist 0=  ;                        : ?warn  ( ca len -- ca len | ca len xt )                           no-warnings? if  unnest exit  ( ca len )  then                not-redefined? if  unnest                   then                ( ca len | ca len xt )  ;                                                                                                                                                                                                                                                                                                                                                                                                                                     ( warn.throw warn.message warn-throw )                          need warnings  need [if]                                        [needed] warn.throw [if]                                        : warn.throw  ( ca len -- ca len )                                ?warn ( ca len xt )  drop 2drop .error-word  #-257 .throw  ;  ' warn.throw ' warn defer!  warnings on   [then]                [needed] warn.message [if]                                      : warn.message  ( ca len -- ca len )                              ?warn ( ca len xt )  ." redefined " >name .name  ;            ' warn.message ' warn defer!  warnings on  [then]               [needed] warn-throw [if]                                        : warn-throw  ( ca len -- ca len )                                ?warn ( ca len xt )  #-257 throw  ;                           ' warn-throw ' warn defer!  warnings on  [then]                                                                                                                                                 ( string-parameter )                                            : string-parameter  ( -- ca len )                                 rp@ cell+ dup >r    ( a1 ) ( R: a1 )                            @ count             ( ca len ) ( R: a1 )                        dup char+ r@ @ +    ( ca len a2 ) ( R: a1 )                     r> !  ;                                                       : string-parameter2  ( -- ca len )                                rp@ cell+ dup >r    ( a1 ) ( R: a1 )                            dup @ count         ( a1 ca len ) ( R: a1 )                     dup char+ rot +    ( ca len a2 ) ( R: a1 )                      r> !  ;                                                       : string-parameter3  ( -- ca len )                                rp@ cell+ dup       ( a1 )                                      dup @ count         ( a1 ca len )                               rot dup >r over char+ over +    ( ca len a2 )                   r> !  ;                                                       ( buffer: cvariable enum link@ link, )                          [unneeded] buffer:                                              ?\ : buffer:  ( u "name" -- )  create allot  ;  exit            [unneeded] cvariable                                            ?\ : cvariable  ( "name"  -- )  create 1 allot  ;  exit         [unneeded] enum                                                 ?\ : enum  (  n "name" -- n+1 )  dup constant 1+  ;  exit       [unneeded] link@  [unneeded] link, and ?exit                    defer link@  ( node1 -- node2 )  ' @ ' link@ defer!             : link,  ( node -- )  here over @ , swap !  ;                                                                                                                                                                                                                                                                                                                                                                                                                   ( storer cstorer 2storer )                                      need ?(                                                         [unneeded] storer ?(                                            : storer  ( x a "name" -- )                                       create  2,  does>   ( -- ) ( pfa )  2@ !  ; ?)                [unneeded] cstorer ?(                                           : cstorer  ( c ca "name" -- )                                     create  2,  does>   ( -- ) ( pfa )  2@ c!  ; ?)               [unneeded] 2storer ?(                                           : 2storer  ( xd a "name" -- )                                     create  , 2,                                                    does>   ( -- ) ( pfa )  dup cell+ 2@ rot @ 2!  ; ?)                                                                                                                                                                                                                                                                           ( !> 2!> c!> )                                                  need ?(                                                         [unneeded] !> ?(                                                : !>  ( Int: x "name" -- ) ( Comp: "name" -- ) ( Exe: x -- )      ' >body compiling? if    postpone literal postpone ! exit                          then  !  ; immediate ?)                    [unneeded] 2!> ?(                                               : 2!>  ( Int: xd "name" -- ) ( Comp: "name" -- ) ( Exe: xd -- )   ' >body compiling? if    postpone literal postpone 2! exit                         then  2!  ; immediate ?)                   [unneeded] c!> ?(                                               : c!>  ( Int: c "name" -- ) ( Comp: "name" --) ( Exe: c -- )      ' >body compiling? if    postpone literal postpone c! exit                         then  c!  ; immediate ?)                                                                                                                                                   ( value to 2value 2to cvalue cto )                              need alias  need ?(                                             [unneeded] value [unneeded] to and ?(                           ' constant alias value  ( x "name"  -- )                        need !>  ' !> alias to  ?)                                      [unneeded] 2value [unneeded] 2to and ?(                         ' 2constant alias 2value  ( xd "name"  -- )                     need 2!>  ' 2!> alias 2to  ?)                                   [unneeded] cvalue [unneeded] cto and ?(                         need cconstant ' cconstant alias cvalue  ( c "name"  -- )       need c!>  ' c!> alias cto  ?)                                                                                                                                                                                                                                                                                                                                                                   ( 2nip pick roll )                                              need [if]                                                       [needed] 2nip [if]  code 2nip  ( x1 x2 x3 x4 -- x3 x4 )           E1 c, D1 c, F1 c, F1 c, C3 c, pushhlde ,  end-code  [then]    [needed] pick [if]                                              code pick  ( xu .. x1 x0 u -- xu .. x1 x0 xu )                    E1 c,  29 c,  39 c,  C3 c, fetchhl ,  end-code  [then]        [needed] pick [if]  need z80-asm                                code roll  ( xu xn .. x0 u -- xn .. x0 xu )                       hl pop  hl addp  hl de ldp  sp addp                             bc push  m c ld  hl incp  m b ld                                bc push  de bc ldp  hl de ldp  bc tstp                          0000 jpz |mark 0 unresolved !   hl decp  hl decp  lddr          0 unresolved @ >resolve  hl pop  bc pop  exsp                   jpnext  end-code                                              [then]                                                          ( 3drop 4drop 3dup )                                            need [if]                                                       [needed] 3drop [if]                                             code 3drop  ( x1 x2 x3 -- )                                       E1 c,  E1 c,  E1 c,  jpnext  end-code  [then]                 [needed] 4drop [if]                                             code 4drop  ( x1 x2 x3 x4 -- )                                    E1 c,  E1 c,  E1 c,  E1 c,  jpnext  end-code  [then]          [needed] 3dup [if]                                              code 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )                      D9 c,                                                           C1 c,  D1 c,  E1 c,  E5 c,  D5 c,  C5 c,  E5 c,  D5 c,  C5 c,   D9 c,  jpnext  end-code  [then]                                                                                                                                                                                                                               ( 2rot swapped )                                                need [if]                                                       [needed] 2rot [if]                                              need roll                                                       : 2rot  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )                5 roll 5 roll  ;                                              [then]                                                          [needed] swapped [if]                                           : swapped  ( i*x n1 n2 -- j*x )                                   >r 1+ cells sp@ +     ( i*x a1 ) ( R: n2 )                      r> 2+ cells sp@ +     ( i*x a1 a2 )                             over @ over @         ( i*x a1 a2 x1 x2 )                       >r swap !  r> swap !  ;                                       [then]                                                                                                                                                                                          ( nup drup dip 0dup -dup )                                      need [if]                                                       [needed] nup [if]  code nup  ( x1 x2 -- x1 x1 x2 )                E1 c,  D1 c,  D5 c,  C3 c, pushhlde ,  end-code  [then]       [needed] drup [if]  code drup  ( x1 x2 -- x1 x1 )                 D1 c,  E1 c,  E5 c,  E5 c,  jpnext  end-code  [then]          [needed] dip [if]  code dip  ( x1 x2 -- x2 x2 )                   E1 c, D1 c, E5 c, E5 c,  jpnext  end-code  [then]             [needed] 0dup [if]  code 0dup  ( x -- x | 0 0 )                   E1 c,  78 04 + c,  B0 05 + c,                                   C2 c, pushhl ,  E5 c,  jppushhl  end-code  [then]             [needed] -dup [if]  code -dup  ( x -- x | 0 0 )                   E1 c,  CB c, 7C c,  C2 c, pushhl ,  E5 c,  jppushhl  end-code   [then]                                                                                                                                                                                        ( ndrop 2ndrop )                                                need [if]  need z80-asm                                         [needed] ndrop [if]                                             code ndrop  ( x1..xn n -- )                                       hl pop  hl addp  exde  \ DE = n cells                           0 hl ldp#  sp addp  \ HL = stack pointer                        de addp  ldsp  \ update SP                                      jpnext  end-code                                              [then]                                                          [needed] 2ndrop [if]                                            code 2ndrop  ( dx1..dxn n -- )                                    hl pop  hl addp  hl addp  exde  \ DE = n cells                  0 hl ldp#  sp addp  \ HL = stack pointer                        de addp  ldsp  \ update SP                                      jpnext  end-code                                              [then]                                                          ( alias! alias realias )                                        need name>>  need !s                                            [defined] alias!                                                ?\ : alias!  ( xt nt -- )  name>> !s  ;                         [unneeded] alias                                                ?\ : alias  ( xt "name" -- )  header reveal latest alias!  ;    [unneeded] realias ?exit                                        : realias  ( xt "name" -- )                                       defined dup 0= #-13 ?throw alias!  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ( :noname )                                                     : :noname  ( -- xt )                                              here  dup lastxt !  last off  !csp                              docolon code-field,                                             noname? on  ]  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( deferred defers defer@ action-of )                            [unneeded] deferred                                             ?\ : deferred  ( xt "name" -- )  defer latest name> defer!  ;   [unneeded] defers                                               ?\ : defers  ( "name" -- )  ' defer@ compile,  ; immediate      [unneeded] defer@                                               ?\ : defer@  ( xt1 -- xt2 )  >defer @  ;                        [unneeded] deferred?                                            ?\ : deferred?  ( xt -- f )  c@ $C3 =  ;                        [unneeded] action-of ?exit                                      : action-of  ( Interpretation: "name" -- xt )                                ( Compilation:    "name" -- )                                   ( Runtime:        -- xt )                            ' compiling? if    postpone literal postpone defer@                          else  defer@  then  ; immediate                                                                                  ( <is> [is] is  )                                               : <is>  ( xt "name" -- )  ' defer!  ;                           : [is]  ( xt "name" -- )                                          postpone ['] postpone defer!  ; immediate compile-only        : is  ( xt "name" -- )                                            compiling? if  postpone [is]  else  <is>  then  ; immediate                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ( abort" )                                                      [defined] abort-message ?\ 2variable abort-message              : (abort")  ( n -- )                                              r> count rot if  abort-message 2! -2 throw  then + >r  ;      : abort"  ( Compilation: "ccc<quote>" -- )                        postpone (abort") ,"  ; immediate compile-only                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ( error>ordinal error>line )                                    : error>ordinal  ( -n1 -- +n2 )                                   abs dup 256 < ?exit                                                 dup 1000 < if  [ 256 091 - ] literal - exit  then               [ 1000 286 - 256 091 - + ] literal -   ;                  : error>line  ( -n1 -- n2 )                                       error>ordinal dup >r                                            begin  dup dup 16 / - r@ <>  while  1+  repeat  rdrop  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( error-messages-block .throw-message )                         need error>line  need .line                                     variable error-messages-block                                   s" Standard error codes" located error-messages-block !         : .throw-message  ( n -- )                                        error-messages-block @                                          if    cr error>line error-messages-block @ .line space          else  .throw#  then  ;                                        ' .throw-message ' .throw defer!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ( ?compiling ?executing )                                       [unneeded] ?compiling                                           ?\ : ?compiling  ( -- )  compiling? 0= -14 ?throw  ;            [unneeded] ?executing                                           ?\ : ?executing  ( -- )  compiling? -263 ?throw  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( warning" )                                                    need string-parameter                                           : (warning")  ( f -- )                                            string-parameter rot if  type  else  2drop  then  ;           : warning"                                                        postpone (warning") ,"  ; immediate compile-only                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( case )                                                        0 constant case  immediate compile-only                         : of                                                              postpone over  postpone =  postpone if  postpone drop           ; immediate compile-only                                      : endof  ( orig1 -- orig2 )                                       postpone else  ; immediate compile-only                       : endcase                                                         postpone drop  begin  ?dup  while  postpone then  repeat        ; immediate compile-only                                                                                                                                                                                                                                                                                                                                                                                                                                      ( eforth-case )                                                 0 constant case  immediate compile-only                         : of                                                              postpone over postpone = postpone if  postpone drop             ; immediate compile-only                                      : endof  ( orig1 -- orig2 )                                       postpone else  ; immediate compile-only                       : (endcase) ( 0 orig1..orign -- )                                 begin  ?dup  while  postpone then  repeat  ;                  : endcase                                                         ( Compilation: 0 orig1..orign -- )                              ( Run-time: x -- )                                              postpone drop (endcase)  ; immediate compile-only                                                                                                                                                                                                             ( 94-doc-case )                                                 0 constant case  immediate compile-only                         : of                                                              1+ >r                                                           postpone over  postpone =   \ copy and test case value          postpone if                 \ add orig to control flow stack    postpone drop               \ discards case value if =          r>  ; immediate compile-only                                  : endof                                                           >r  postpone else  r>  ; immediate compile-only               : endcase                                                         postpone drop  \ discard case value                             0 ?do  postpone then  loop  ; immediate compile-only                                                                                                                                                                                                          ( abersoft-case )                                               : case                                                            csp @ !csp  ; immediate compile-only                          : of                                                              postpone over  postpone =  postpone if  postpone drop           ; immediate compile-only                                      : endof                                                           postpone else  ; immediate compile-only                       : endcase                                                         postpone drop                                                   begin  sp@ csp @ <>  while  postpone then  repeat               csp !  ;  immediate                                                                                                                                                                                                                                                                                                           ( between-of )                                                  need between                                                    : (between-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )                    2>r dup dup 2r> between 0= if  invert  then  ;                : between-of  ( Compilation: -- of-sys )                                      ( Run-time: x1 x2 x3 -- | x1 )                      postpone (between-of) postpone of  ;  immediate compile-only                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( less-of )                                                     [defined] nup ?\ : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;     : (less-of)  ( x1 x2 -- x1 x1 | x1 x1' )                          nup nup >= if  invert  then  ;                                : less-of  ( Compilation: -- of-sys )                                      ( Run-time: x1 x2 -- | x1 )                            postpone (less-of) postpone of  ;  immediate compile-only                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( greater-of )                                                  [defined] nup ?\ : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;     : (greater-of)  ( x1 x2 -- x1 x1 | x1 x1' )                       nup nup <= if  invert  then  ;                                : greater-of  ( Compilation: -- of-sys )                                      ( Run-time: x1 x2 -- | x1 )                         postpone (greater-of) postpone of  ; immediate compile-only                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ( within-of )                                                   need within                                                     : (within-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )                     2>r dup dup 2r> within 0= if  invert  then  ;                 : within-of  ( Compilation: -- of-sys )                                      ( Run-time: x1 x2 x3 -- | x1 )                       postpone (within-of) postpone of  ; immediate compile-only                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ( any-of )                                                      need any?  need pick                                            : (any-of)  ( x0 x1..xn n -- x0 x0 | x0 0 )                       dup 1+ pick >r any? r> tuck and  ;                            : any-of  ( Compilation: -- of-sys )                                      ( Run-time: x0 x1..xn n -- | x0 )                       postpone (any-of) postpone of  ; immediate compile-only                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ( default-of )                                                  : default-of  ( -- )                                              postpone dup postpone of  ; immediate compile-only                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ( or-of )                                                       : (or-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )                         2>r dup dup dup r> = swap r> = or 0= if  invert  then  ;      : or-of  ( Compilation: -- of-sys )                                      ( Run-time: x1 x2 x3 -- | x1 )                           postpone (or-of) postpone of  ; immediate compile-only                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ( attr )                                                        need z80-asm need (attr-addr)                                   code attr ( col line -- b )                                       de pop  hl pop  l d ld                                          (attr-addr) call                                                m l ld  0 h ld#                                                 jppushhl                                                        end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( attr-addr )                                                   need z80-asm need (attr-addr)                                   code attr-addr ( col line -- a )                                  de pop  hl pop  l d ld                                          (attr-addr) call                                                jppushhl                                                        end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \ (attr-addr) \                                                 need z80-asm                                                    create (attr-addr)  ( -- a )                                      asm                                                             e a ld  \ line to a 0x00..0x17 (max 00010111)                   rrca rrca rrca  \ rotate bits left                              a e ld  \ store in d as an intermediate value                   E0 and#  \ pick up bits 11100000 (was 00011100)                 d xor  \ combine with column 0x00..0x1F                         a l ld  \ low byte now correct                                  e a ld  \ bring back intermediate result from d                 03 and#  58 xor#                                                a h ld  \ high byte correct                                     ret                                                             end-asm                                                                                                                       ( rdraw )                                                       need z80-asm                                                    code rdraw  ( gx gy -- )                                          hl pop  de pop  bc push                                         de bc ldp                                                       1 e ld#                                                         b 7 bit  \ negative x?                                          nz if  c a ld  neg  -1 e ld#  a c ld  then  \ negative x        l b ld   \ y                                                    1 d ld#                                                         h 7 bit  \ negative y?                                          nz if  b a ld  neg  -1 d ld#  a b ld  then  \ negative y        24BA call \ alternative entry to the DRAW-LINE ROM routine      bc pop                                                          jpnext end-code                                                                                                               ( (rdraw )                                                      need z80-asm                                                    create (rdraw                                                   asm                                                             end-asm                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ( adraw )                                                       need plot  need os-coordx  need os-coordy                       2variable x1  2variable incx  2variable y1  2variable incy      : adraw  ( gx gy -- )                                             [ os-coordy ] literal c@ ( y0 )                                 dup 0 swap y1 2! - dup abs rot                                  [ os-coordx ] literal c@ ( x0 )                                 dup 0 swap x1 2! - dup abs rot                                  max >r dup 0<  \ negative xdiff?                                if    abs 0 swap r@ ud/mod dnegate                              else  0 swap r@ ud/mod  then                                    incx 2! drop dup 0<  \ negative ydiff?                          if    abs 0 swap r@ ud/mod dnegate                              else  0 swap r@ ud/mod  then                                    -->                                                                                                                           ( adraw )                                                         incy 2! drop r> 1+ 0                                            do  x1 @ y1 @ plot                                                  x1 2@ incx 2@ d+ x1 2!                                          y1 2@ incy 2@ d+ y1 2!  loop  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ( ocr )                                                         need z80-asm  need ocr-chars                                    code ocr  ( col line -- n )                                       de pop  hl pop  bc push                                         l b ld  e c ld  ocr-charset fthl                                c a ld  rrca  rrca  rrca  E0 and#  b xor  a e ld                c a ld  18 and#  40 xor#  a d ld                                0 de stp |mark 0 unresolved !                                   ocr-chars fta  a b ld                                           begin                                                             bc push  hl push                                                0 de ldp#  \ restore the screen address                         |mark 0 unresolved @ !                                      -->                                                                                                                                                                                             ( ocr )                                                             08 b ld# \ scans                                                begin                                                             de ftap  m xor  \ scan match?                                   here jrnz >relmark 1 unresolved !                               d inc  hl incp  \ update the pointers                         step  \ next scan                                               bc pop  bc pop                                                  ocr-chars fta  b sub  a b ld                                    ocr-first fta  b add  a b ld                                    here jr >relmark 2 unresolved !                                 1 unresolved @ >relresolve                                      hl pop  0008 de ldp#  de addp  bc pop                         step                                                            2 unresolved @ >relresolve  0 h ld#  b l ld                     bc pop  jppushhl  end-code                                    ( ocr-charset ocr-first ocr-chars ascii-ocr udg-ocr )           variable ocr-charset                                            variable ocr-first                                              variable ocr-chars                                              need os-chars  need os-udg                                      : ascii-ocr  ( -- )                                               os-chars @ 256 + ocr-charset !                                  32 ocr-first !                                                  95 ocr-chars !  ;                                             : udg-ocr  ( n -- )                                               os-udg @ ocr-charset !                                          128 ocr-first !                                                 ocr-chars !  ;                                                19 udg-ocr  \ default                                                                                                                                                                           ( pixel-addr )                                                  need (pixel-addr)                                               code pixel-addr  ( gx gy -- n a )                                 E1 c,  D1 c,            \ pop hl / pop de                       C5 c,                   \ push bc                               40 05 + c,              \ ld b,l ; b=y                          48 03 + c,              \ ld c,e ; c=x                          CD c, (pixel-addr) ,       \ call (pixel-addr)                  C1 c,                   \ pop bc                                16 c, 0 c,  58 07 + c,  \ ld d,0 / ld e,a                       C3 c, pushhlde ,        \ jp pushhlde                           end-code                                                                                                                                                                                                                                                                                                                      \ (pixel-addr) \                                                create (pixel-addr)  ( -- a )                                     asm                                                             3E c, BF c,   \ ld a,191 ; max Y coordinate                     90 00 + c,    \ sub b                                           C3 c, 22B0 ,  \ jp 0x22B0 ; and return                          end-asm                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \ (pixel-addr) \                                                need z80-asm                                                    create (pixel-addr)  ( -- a )                                     asm                                                             BF a ld#  b sub                                                 a b ld  rra  scf  rra  a and  rra                               b xor  F8 and#  b xor  a h ld                                   c a ld                                                          rlca rlca rlca  b xor  C7 and#                                  b xor  rlca  rlca                                               a l ld                                                          c a ld  07 and#                                                 ret                                                             end-asm                                                                                                                                                                                       ( plot )                                                        need (pixel-addr)                                               code plot  ( gx gy -- )                                           D9 c,               \ exx ; save Forth IP                       E1 c,               \ pop hl                                    C1 c,               \ pop bc                                    40 05 + c,          \ ld b,l                                    ED c, 43 c, 5C7D ,  \ ld (0x5C7D),bc ; update COORDS            CD c, (pixel-addr) ,   \ call (pixel-addr)                      CD c, 22EC ,        \ call 0x22EB ; ROM PLOT-SUB + 7            D9 c,               \ exx ; restore Forth IP                    DD c, 21 c, next ,  \ ld ix,next ; restore ix                   jpnext              \ jp (ix)                                   end-code                                                                                                                                                                                      ( set-pixel )                                                   need (pixel-addr)  need z80-asm                                 code set-pixel  ( gx gy -- )                                      hl pop  de pop  bc push                                         l b ld  e c ld  (pixel-addr) call                               a b ld  b inc  1 a ld#                                          begin  rrca  step                                               m or  a m ld  \ combine pixel with byte in the screen           bc pop  jpnext                                                  end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( reset-pixel )                                                 need (pixel-addr)  need z80-asm                                 code reset-pixel  ( gx gy -- )                                    hl pop  de pop  bc push                                         l b ld  e c ld  (pixel-addr) call                               a b ld  b inc  1 a ld#                                          begin  rrca  step                                               cpl  m and  a m ld  \ combine pixel with byte in the screen     bc pop  jpnext                                                  end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( toggle-pixel )                                                need (pixel-addr)  need z80-asm                                 code toggle-pixel  ( gx gy -- )                                   hl pop  de pop  bc push                                         l b ld  e c ld  (pixel-addr) call                               a b ld  b inc  1 a ld#                                          begin  rrca  step                                               m xor  a m ld  \ combine pixel with byte in the screen          bc pop  jpnext                                                  end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( test-pixel )                                                  need (pixel-addr)  need z80-asm                                 code test-pixel  ( gx gy -- f )                                   hl pop  de pop  bc push                                         l b ld  e c ld                                                  (pixel-addr) call                                               a b ld  b inc  m a ld                                           begin  rlca  step \ rotate to bit 0                             bc pop  \ restore the Forth IP                                  1 and#  \ pixel?                                                ' true jpnz                                                     ' false jp                                                      end-code                                                                                                                                                                                                                                                      ( pixels )                                                      need z80-asm                                                    code pixels  ( -- u )                                             exx                                                             4000 hl ldp#  l b ld  l c ld                                    begin  \ byte                                                     08 d ld#                                                        begin  \ bit                                                      m rrc  cy if  bc incp  then  d dec                            z until                                                         hl incp  h a ld  58 cp#                                       z until                                                         bc push                                                         exx                                                             jpnext                                                          end-code                                                      ( slow-pixels )                                                 need bits                                                       : pixels  ( -- u )  16384 6144 bits  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ( 0udg! udg! 0udg: udg: )                                       need os-udg                                                     : 0udg!  ( b0..b7 n -- )                                          8 * os-udg @ + dup 7 + do  i c!  -1 +loop  ;                  : udg!  ( b0..b7 c -- )  128 - 0udg!  ;                         : udg:  ( b0..b7 c "name" -- )  dup constant  udg!  ;           : 0udg:  ( b0..b7 n "name" -- )  dup constant 0udg!  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ( 0udg[ udg[ )                                                  need os-udg                                                     variable first-udg                                              variable current-udg                                            variable current-scan                                           [defined] binary ?\  : binary  ( -- )  2 base !  ;              : 0udg[  ( b -- )                                                 dup first-udg !  current-udg !  current-scan off  binary  ;   : udg[  ( c -- )  128 - 0udg[  ;                                : |  ( b -- )                                                     os-udg @ current-udg @ 8 * current-scan @ + + c!                1 current-udg +!  ;                                           : || ( b -- )                                                     |  1 current-scan +!  first-udg @ current-udg !  ;            : ||]  ( b -- )  ||  decimal  ;                                                                                                 ( at-accept clear-accept set-accept )                           2variable accept-xy       \ coordinates of the edited string    variable accept-buffer    \ address of the edited string        variable /accept          \ max length of the edited string     variable >accept          \ offset to the cursor position       : at-accept  ( -- )  accept-xy 2@ at-xy  ;                      : clear-accept  ( -- )                                            at-accept span @ spaces at-accept  span off  ;                : set-accept  ( ca1 len1 -- ca1' )                                clear-accept /accept @ min  ( ca1 len1' )                       dup span ! 2dup system-bank type default-bank                   dup >r                                                          accept-buffer @  ( ca1 len1' ca2 )                              smove accept-buffer @  ( ca2 )                                  r> +  ( ca1' )  ;                                                                                                             ( acceptx )                                                     need at-accept  need set-accept                                 : .acceptx  ( -- )                                                accept-buffer @ >accept @ at-accept type                        1 inverse  >accept @ span @ <                                   if accept-buffer @ >accept @ + c@ emit  else  space  then       0 inverse                                                       accept-buffer @ span @ >accept @ 1+ min /string type            ;                                                             -->                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( acceptx )                                                     need toggle-capslock                                            : accept-edit  ( -- )  clear-accept init-accept  ;              : accept-left  ( -- )  ;                                        : accept-right  ( -- )  ;                                       : accept-up  ( -- )  ;                                          : accept-down  ( -- )  ;                                        : accept-delete  ( -- )  ;                                      create accept-commands ] noop noop noop noop noop noop          toogle-capslock accept-edit accept-left accept-right            accept-down accept-up accept-delete noop noop noop noop noop    noop noop noop noop noop noop noop noop noop noop noop noop [   : >accept-command  ( c -- a )  cells accept-commands +  ;       : accept-command  ( c -- )  >accept-command perform  ;          -->                                                                                                                             ( acceptx )                                                     : init-acceptx  ( ca len -- )                                     /accept !  accept-buffer !  >accept off  xy accept-xy 2!  ;   : (acceptx) ( ca len -- len' )  2dup init-accept                  over + over ( bot eot cur )                                     begin  key dup 13 <> \ not carriage return?                     while                                                             dup 12 =  \ delete?                                             if    drop  >r over r@ < dup  \ any chars?                            if  8 dup emit  bl emit  emit  then  r> +                 else  \ printable                                                     >r  2dup <>  \ more?                                            if r@ over c!  char+  r@ emit                                   then r> drop                                              then                                                          repeat  drop nip swap -  ;  -->                               ( acceptx )                                                     : acceptx ( ca len -- len' )                                      span off  ?dup 0= if  drop 0  else  (acceptx)  then  ;        : ax  ( -- )  ['] acceptx ['] accept defer!  ;                  : a0  ( -- )  ['] default-accept ['] accept defer!  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ( nuf? )                                                        need aborted?                                                   [defined] 'cr' ?\ 13 constant 'cr' \ code of carriage return    : nuf?  ( -- f )  'cr' aborted?  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( aborted? )                                                    : aborted?  ( c -- f )                                            key? dup  if    key 2drop key =                                           else  nip  then  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( break? )                                                      : break?  ( -- f )                                                key? dup if  key 2drop break-key?  then  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ( kk-ports kk, kk@ )                                            /kk 3 <> dup                                                    ?\ : kk,  ( bitmask port -- ) , c,  ;                           ?\ : kk@  ( a -- bitmask port ) dup c@ swap 1+ @ ;              /kk 4 <> dup                                                    ?\ : kk,  ( d -- )  2,  ;                                       ?\ : kk@  ( a -- bitmask port )  2@  ;                          -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( kk-ports )                                                    $01 $F7FE 2constant kk-1  $02 $F7FE 2constant kk-2              $04 $F7FE 2constant kk-3  $08 $F7FE 2constant kk-4              $10 $F7FE 2constant kk-5                                        $01 $FBFE 2constant kk-q  $02 $FBFE 2constant kk-w              $04 $FBFE 2constant kk-e  $08 $FBFE 2constant kk-r              $10 $FBFE 2constant kk-t                                        $01 $FDFE 2constant kk-a  $02 $FDFE 2constant kk-s              $04 $FDFE 2constant kk-d  $08 $FDFE 2constant kk-f              $10 $FDFE 2constant kk-g                                        $01 $FDFE 2constant kk-cs  $02 $FDFE 2constant kk-z             $04 $FDFE 2constant kk-x   $08 $FDFE 2constant kk-c             $10 $FDFE 2constant kk-v                                        -->                                                                                                                                                                                             ( kk-ports )                                                    $01 $EFFE 2constant kk-0  $02 $EFFE 2constant kk-9              $04 $EFFE 2constant kk-8  $08 $EFFE 2constant kk-7              $10 $EFFE 2constant kk-6                                        $01 $DFFE 2constant kk-p  $02 $DFFE 2constant kk-o              $04 $DFFE 2constant kk-i  $08 $DFFE 2constant kk-u              $10 $DFFE 2constant kk-y                                        $01 $BFFE 2constant kk-en  $02 $BFFE 2constant kk-l             $04 $BFFE 2constant kk-k   $08 $BFFE 2constant kk-j             $10 $BFFE 2constant kk-h                                        $01 $7FFE 2constant kk-sp $02 $7FFE 2constant kk-ss             $04 $7FFE 2constant kk-m  $08 $7FFE 2constant kk-n              $10 $7FFE 2constant kk-b                                        -->                                                                                                                                                                                             ( kk-ports )                                                    need kk,                                                        40 constant keys                                                create kk-ports                                                 kk-1  kk,  kk-2  kk,  kk-3 kk,  kk-4 kk,  kk-5 kk,              kk-q  kk,  kk-w  kk,  kk-e kk,  kk-r kk,  kk-t kk,              kk-a  kk,  kk-s  kk,  kk-d kk,  kk-f kk,  kk-g kk,              kk-cs kk,  kk-z  kk,  kk-x kk,  kk-c kk,  kk-v kk,              kk-0  kk,  kk-9  kk,  kk-8 kk,  kk-7 kk,  kk-6 kk,              kk-p  kk,  kk-o  kk,  kk-i kk,  kk-u kk,  kk-y kk,              kk-en kk,  kk-l  kk,  kk-k kk,  kk-j kk,  kk-h kk,              kk-sp kk,  kk-ss kk,  kk-m kk,  kk-n kk,  kk-b kk,                                                                                                                                                                                                                                                                              ( kk-1# )                                                       need enum                                                       0                                                               enum kk-1#  enum kk-2#  enum kk-3# enum kk-4# enum kk-5#        enum kk-q#  enum kk-w#  enum kk-e# enum kk-r# enum kk-t#        enum kk-a#  enum kk-s#  enum kk-d# enum kk-f# enum kk-g#        enum kk-cs# enum kk-z#  enum kk-x# enum kk-c# enum kk-v#        enum kk-0#  enum kk-9#  enum kk-8# enum kk-7# enum kk-6#        enum kk-p#  enum kk-o#  enum kk-i# enum kk-u# enum kk-y#        enum kk-en# enum kk-l#  enum kk-k# enum kk-j# enum kk-h#        enum kk-sp# enum kk-ss# enum kk-m# enum kk-n# enum kk-b#        drop                                                                                                                                                                                                                                                                                                                            ( kk-chars )                                                    create kk-chars                                                 '1' c,  '2' c,  '3' c,  '4' c,  '5' c,                          'q' c,  'w' c,  'e' c,  'r' c,  't' c,                          'a' c,  's' c,  'd' c,  'f' c,  'g' c,                          128 c,  'z' c,  'x' c,  'c' c,  'v' c,                          '0' c,  '9' c,  '8' c,  '7' c,  '6' c,                          'p' c,  'o' c,  'i' c,  'u' c,  'y' c,                          129 c,  'l' c,  'k' c,  'j' c,  'h' c,                          130 c,  131 c,  'm' c,  'n' c,  'b' c,                                                                                                                                                                                                                                                                                                                                                                                                                          ( pressed pressed? )                                            need [if]                                                       [needed] pressed? [needed] pressed or [if]                      need @p                                                         : pressed? ( n1 n2 -- f )  @p and 0=  ;                         [then]                                                          [needed] pressed [if]                                           need pressed?  need kk-ports                                    : pressed  ( -- false | n1 n2 true )                              0 \ false by default                                            [ kk-ports keys /kk * bounds swap ] literal literal             do  i kk@ pressed? if  drop i kk@ 1 leave  then  /kk +loop  ; [then]                                                                                                                                                                                                                                                          ( only-one-pressed )                                            need kk-ports                                                   0. 2variable kk-pressed                                         : only-one-pressed  ( -- false | n1 n2 true )                     0. kk-pressed 2! \ none by default                              [ kk-ports keys /kk * bounds swap ] literal literal             do  i kk@ pressed?                                              if  kk-pressed 2@ + if                                          then                                                            /kk +loop                                                       kk-pressed 2@ 2dup + if  1  else  2drop 0  then  ;                                                                                                                                                                                                                                                                                                                                            ( inkey )                                                       need z80-asm                                                    code inkey  ( -- c | 0 )                                          a xor                                                           01 iy 5 bitx  \ a new key pressed?                              nz if                                                             5C08 hl ldp#  \ LAST-K system variable                          m a ld                                                          01 iy 5 resx                                                  then                                                            pusha jp                                                        end-code                                                                                                                                                                                                                                                                                                                      ( under+ +under )                                               need [if]                                                       [needed] under+ [if]                                            code under+  ( n1|u1 x n2|u2 -- n3|u3 x )                         D9 c, D1 c, C1 c, E1 c, 19 c, E5 c, C5 c, D9 c,                 jpnext  end-code                                              [then]                                                          [needed] +under [if]                                            code +under  ( n1|u1 n2|u2 x -- n3|u3 x )                         D9 c, C1 c, D1 c, E1 c, 19 c, E5 c, C5 c, D9 c,                 jpnext  end-code                                              [then]                                                                                                                                                                                                                                                                                                                          ( within between % u% )                                         [unneeded] within                                               ?\ : within  ( n1|u1 n2|u2 n3|u3 -- f )  over - >r - r> u<  ;   [unneeded] between ?exit                                        : between  ( n1|u1 n2|u2 n3|u3 -- f )  over - -rot - u< 0=  ;   [unneeded] %                                                    ?\ : %  ( n1 n2 -- n3 )  100 swap */  ;                         [unneeded] u%                                                   ?\ : u%  ( u1 u2 -- u3 )  >r 100 um* r> um/mod nip  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ( polarity <=> )                                                code polarity  ( n -- -1 | 0 | 1 )                                D1 c, 78 02 + c,  B0 03 + c,  CA c, ' false ,                   CB c, 10 03 + c,  ED c, 62 c,                                   78 05 + c,  F6 c, 01 c,  68 07 + c,  jppushhl                   end-code                                                      [unneeded] <=>                                                  ?\ : <=>  ( n1 n2 -- -1|0|1 )  - polarity  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ( u<= u>= <= >= 0>= 0<= 0max )                                  [unneeded] u<=  ?\ : u<=  ( u1 u2 -- f )  u> 0=  ;  exit        [unneeded] u>=  ?\ : u>=  ( u1 u2 -- f )  u< 0=  ;  exit        [unneeded] <=   ?\ : <=   ( n1 n2 -- f )  > 0=   ;  exit        [unneeded] >=   ?\ : >=   ( n1 n2 -- f )  < 0=   ;  exit        [unneeded] 0>=  ?\ : 0>=  ( n1 n2 -- f )  0< 0=  ;  exit        [unneeded] 0<=  ?\ : 0<=  ( n1 n2 -- f )  0> 0=  ;  exit        [unneeded] 0max ?exit                                           code 0max  ( n -- n | 0 )                                         E1 c,  CB c, 10 05 + c,  DA c, ' false ,  CB c, 18 05 + c,      jppushhl  end-code                                                                                                                                                                                                                                                                                                                                                                            ( lshift )                                                      need z80-asm                                                    code lshift  ( x1 u -- x2 )                                       exx                                                             bc pop  \ C = loop counter                                      c b ld                                                          hl pop  \ hi 8 bits ignored!                                    b inc  ahead 0 unresolved !                                     begin  hl addp  0 unresolved @ >relresolve  step                hl push                                                         exx                                                             jpnext                                                          end-code                                                                                                                                                                                                                                                      ( lshift )                                                      code lshift  ( x1 u -- x2 )                                       D1 c,           \ pop de                                        E1 c,           \ pop hl                                        1C c,           \ inc e                                         here            \ begin:                                        1D c,           \ dec e                                         CA c, pushhl ,  \ jp z,push_hl                                  29 c,           \ add hl,hl                                     C3 c, ,         \ jp begin                                      end-code                                                                                                                                                                                                                                                                                                                                                                                      ( rshift )                                                      need z80-asm                                                    code rshift  ( x1 u -- x2 )                                       exx                                                             bc pop  \ C = loop counter                                      c b ld                                                          hl pop  \ hi 8 bits ignored!                                    b inc  ahead 0 unresolved !                                     begin  h srl  l rr  0 unresolved @ >relresolve  step            hl push                                                         exx                                                             jpnext                                                          end-code                                                                                                                                                                                                                                                      ( rshift )                                                      code rshift  ( x1 u -- x2 )                                       D1 c,           \ pop de                                        E1 c,           \ pop hl                                        1C c,           \ inc e                                         here            \ begin:                                        1D c,           \ dec e                                         CA c, pushhl ,  \ jp z,push_hl                                  CB c, 3C c,     \ srl h                                         CB c, 1D c,     \ rr l                                          C3 c, ,         \ jp begin                                      end-code                                                                                                                                                                                                                                                                                                                      ( clshift )                                                     code clshift  ( b1 u -- b2 )                                      D1 c,  E1 c,  78 05 + c,  1C c,                                 here                                                            1D c,  CA c, pusha ,  80 07 + c,  C3 c, ,                       end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( crshift )                                                     code crshift  ( b1 u -- b2 )                                      D1 c,  E1 c,  78 05 + c,  1C c,                                 here                                                            1D c,  CA c, pusha ,                                            C3 c, ,                                                         end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( bits )                                                        need z80-asm                                                    code bits  ( ca len -- u )                                        0 hl ldp#  \ init bit count                                     exx  \ save IP and count                                        de pop  hl pop  \ memory zone                                   begin                                                             d a ld  e or  nz if                                               08 b ld#  \ bits per byte                                       begin  m rrc  cy if  exx hl incp exx  then  step                hl incp  de decp  \ next byte                               2swap again then                                                exx jppushhl end-code                                                                                                                                                                                                                                         ( 2/ cell/ )                                                    need [if]                                                       [needed] 2/ [needed] cell/ or [if]                              code 2/  ( x1 -- x2 )                                             E1 c,           \ pop hl                                        CB c, 2C c,     \ sra h                                         CB c, 1D c,     \ rr l                                          jppushhl        \ jp pushhl                                     end-code                                                      [then]                                                          [unneeded] cell/  ?\ need alias  ' 2/ alias cell/                                                                                                                                                                                                                                                                                                                                               ( sqrt )                                                        need d2*  need 2/                                               [defined] cell-bits ?\ 16 constant cell-bits                    : (sqrt)  ( radicand -- remainder root )                          0 0                           ( radicand remainder root )       [ cell-bits 2/ ] literal 0 do                                     >r d2* d2* r>               \ shift remainder left 2 bits       2*                          \ shift root left 1 bit             2dup 2* u> if               \ check for next bit of root          >r r@ 2* - 1- r>          \ reduce remainder                    1+                        \ add a bit to root                 then                                                          loop  cr .s rot drop  ;                                       : sqrt  ( radicand -- root )  (sqrt) nip  ;                                                                                                                                                     ( sqrt )                                                        need 2/                                                         : sqrt  ( n1 -- n2 )                                              dup 0< -24 ?throw  \ invalid numeric argument                   dup                                                             if  dup 2/  20 0                                                    do      2dup / + 2/                                             loop    swap drop                                           then  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ( sm/rem )                                                      : sm/rem  ( d1 n1 -- n2 n3 )                                      2dup xor >r  \  sign of quotient                                over >r      \  sign of remainder                               abs >r dabs r> um/mod                                           swap r> ?negate                                                 swap r> ?negate  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ( /-rem /- -rem */-rem */- )                                    need sm/rem                                                     : /-rem  ( n1 n2 -- n3 n4 )  >r  s>d  r> sm/rem  ;              : /-  (  n1 n2 -- n3 )  /-rem nip  ;                            : -rem  ( n1 n2 -- n3 )  /-rem drop  ;                          : */-rem  (  n1 n2 n3 -- n4 n5 )  >r  m*  r> sm/rem  ;          : */-  ( n1 n2 n3 -- n4 )  */-rem nip  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ( fm/mod )                                                      : fm/mod  ( d1 n1 -- n2 n3 )                                      dup >r                \ save divisor                            sm/rem                                                          over 0<> over 0< and  \ quotient<0 and remainder<>0?            if                                                                swap r> +           \ add divisor to remainder                  swap 1-             \ decrement quotient                      else r> drop then  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ( /_mod /_ _mod */_mod */_ )                                    need fm/mod                                                     : /_mod  ( n1 n2 -- n3 n4 )  >r s>d r> fm/mod  ;                : /_  ( n1 n2 -- n3 )  /_mod nip  ;                             : _mod  ( n1 n2 -- n3 )  /_mod drop  ;                          : */_mod  ( n1 n2 n3 -- n4 n5 )  >r m* r> fm/mod  ;             : */_  ( n1 n2 n3 -- n4 )   */_mod nip  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ( any? either neither )                                         need [if]                                                       [needed] any? [if]  need roll  variable (any?)                  : any?  ( x0 x1..xn n -- f )                                      dup 1+ roll (any?) !                                            0 swap 0 do  swap (any?) @ = or  loop  ;                      [then]                                                          [needed] either [if]                                            : either  ( n1|u1 n2|u2 n3|u3 -- f )                              -rot over = -rot = or  ;                                      [then]                                                          [needed] neither [if]                                           : neither  ( n1|u1 n2|u2 n3|u3 -- f )                             -rot over <> -rot <> and  ;                                   [then]                                                                                                                          ( split join )                                                  need [if]                                                       [needed] split [if]                                             code split  ( x -- b1 b2 )                                        E1 c,                                                           16 c, 00 c,  58 05 + c,  68 04 + c,  26 c, 00 c,                C3 c, pushhlde ,  end-code                                    [then]                                                          [needed] join [if]                                              code join  ( b1 b2 -- x )                                         D1 c,  60 03 + c,  D1 c,  68 03 + c,                            jppushhl  end-code                                            [then]                                                                                                                                                                                                                                                          ( !s c!s )                                                      : !s  ( x a -- )  system-bank ! default-bank  ;                 : c!s  ( c ca -- )  system-bank c! default-bank  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( get-default-bank set-default-bank )                           : get-default-bank  ( -- +n )  default-bank# c@  ;              : set-default-bank  ( +n -- )  default-bank# c!  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( @p !p )                                                       need ?(                                                         [unneeded] @p ?(                                                code @p  ( a -- b )                                               E1 c,  C5 c,  48 05 + c,  40 04 + c,  ED c, 68 c,               C1 c,  26 c, 00 c,  jppushhl  end-code                        ?)                                                              [unneeded] !p ?(                                                code !p  ( b a -- )                                               E1 c,  D1 c,  C5 c,  48 05 + c,  40 04 + c,  ED c, 59 c,        C1 c,  jpnext  end-code                                       ?)                                                                                                                                                                                                                                                                                                                              ( parse-line )                                                  : parse-line  ( "ccc<eol>" -- ca len )                            source span @ min c/l min  >in @ span @ min /string             dup >in +! save-string  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( evaluate )                                                    : execute-parsing  ( ca len xt -- )                               >in @ >r >in off                                                source >r >r ;                                                : evaluate  ( ca len -- )  ['] interpret execute-parsing  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( parse-char )                                                  : parse-char  ( "c"  -- c )  stream drop c@ 1 parsed  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ( word )                                                        : word  ( c "<chars>ccc<char>" -- ca )                            dup  stream                 ( c c ca len )                      dup >r   rot skip           ( c ca' len' )                      over >r  rot scan           ( ca" len" )                        dup if  char-  then         \ skip trailing delimiter           r> r> rot -   >in +!        \ update `>in`                      tuck -                      ( ca' len )                         here place  here            ( ca )                              bl over count + c!  ;       \ append trailing blank                                                                                                                                                                                                                                                                                                                                                                                                           ( defined? )                                                    : defined?  ( ca len -- f )  undefined? 0=  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ( save-input restore-input )                                    : save-input ( -- xn ... x1 n )                                   source-id 0>                                                    if tib #tib @ 2dup c/l 2 + allocate throw dup >r swap cmove        r> to tib  >in @                                                source-id file-position throw                                   5                                                            else blk @ >in @ 2 then                                         ;                                                             -->                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( save-input restore-input )                                    : restore-input ( xn ... x1 n -- f )                              source-id 0>                                                    if dup 5 <> if 0 ?do drop loop -1 exit then                        drop source-id reposition-file ?dup                             if >r 2drop drop r> exit then                                   >in ! #tib ! to tib false                                    else dup 2 <> if 0 ?do drop loop -1 exit then                      drop >in ! blk ! false                                       then                                                            ;                                                                                                                                                                                                                                                                                                                                                                                             ( char [char] )                                                 need cliteral                                                   : char  ( "name" -- c )  parse-name drop c@  ;                  : [char]  ( "name" -- c )                                         char postpone cliteral  ; immediate compile-only                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( color@ color! color-mask@ color-mask! color 2color )          need os-attr-t  need os-mask-t                                  : color@  ( -- b )  os-attr-t c@  ;                             : color!  ( b -- )  os-attr-t c!  ;                             : color-mask@  ( -- b )  os-mask-t c@  ;                        : color-mask!  ( b -- )  os-mask-t c!  ;                        : color  ( b "name" -- )                                          create ,  does>  ( -- ) ( pfa ) @ color!  ;                   : 2color  ( b1 b2 "name" -- )                                     create 2,  does>  ( -- ) ( pfa ) 2@ color! color-mask!  ;                                                                                                                                                                                                                                                                                                                                                                                                     ( permcolor@ permcolor! permcolor-mask@ permcolor-mask! )       need os-attr-p  need os-mask-p                                  : permcolor@  ( -- b )  os-attr-p c@  ;                         : permcolor!  ( b -- )  os-attr-p c!  ;                         : permcolor-mask@  ( -- b )  os-mask-p c@  ;                    : permcolor-mask!  ( b -- )  os-mask-p c!  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ( permcolor 2permcolor )                                        need permcolor!  need permcolor-mask!                           : permcolor  ( b "name" -- )                                      create ,                                                        does>  ( -- ) ( pfa ) @ permcolor!  ;                         : 2permcolor  ( b1 b2 "name" -- )                                 create 2,                                                       does>  ( -- ) ( pfa ) 2@ permcolor! permcolor-mask!  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ( paper@ paper! ink@ ink! )                                     need lshift  need rshift  need color@  need color!              : paper>  ( n1 -- n2 )  %00111000 and 3 rshift  ;               : >paper  ( n1 -- n2 )  %00000111 and 3 lshift  ;               : paper@  ( -- b )  color@ paper>  ;                            : paper!  ( b -- )  >paper color@ %11000111 and or color!  ;    : ink@  ( -- b )                                                  color@ %00000111 and  ;                                       : ink!  ( b -- )                                                  %00000111 and color@ %11111000 and or color!  ;                                                                                                                                                                                                                                                                                                                                                                                                               ( bright@ bright! flash! flash@ )                               need color@  need color!                                        : bright@  ( -- f )                                               color@ %01000000 and 0=  ;                                    : bright!  ( f -- )                                               %10000000 and color@ %10111111 and or color!  ;               : flash@  ( -- f )                                                color@ %10000000 and 0=  ;                                    : flash!  ( f -- )                                                %10000000 and color@ %01111111 and or color!  ;                                                                                                                                                                                                                                                                                                                                                                                                               ( inverse overprint )                                           code inverse  ( f -- )                                            E1 c,  78 04 + c,  B0 05 + c,  28 c, 06 c,                      FD c, CB c, 57 c, C6 08 02 * + c,  jpnext                       FD c, CB c, 57 c, 86 08 02 * + c,  jpnext  end-code           code overprint  ( f -- )                                          E1 c,  78 04 + c,  B0 05 + c,  28 c, 06 c,                      FD c, CB c, 57 c, C6 08 00 * + c,  jpnext                       FD c, CB c, 57 c, 86 08 00 * + c,  jpnext  end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ( printer tabulate )                                            [unneeded] printer                                              ?\ : printer  ( -- )  3 channel printing on  ;  exit            need column                                                     variable /tabulate  8 /tabulate !                               : tabulate  ( -- )  column 1+ /tabulate @ tuck mod - spaces  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( 'cr' 'tab' 'bs' crs tab tabs backspace backspaces )           [unneeded] 'tab' [unneeded] tab [unneeded] tabs and and         ?\ 6 constant 'tab'                                             [unneeded] 'bs' [unneeded] backspace [unneeded] backspaces      and and ?\ 8 constant 'bs'                                      [unneeded] 'cr' [unneeded] crs and ?\ 13 constant 'cr'          [unneeded] tab [unneeded] tabs and                              ?\ : tab  ( -- )  'tab' emit  ;                                 [unneeded] backspace [unneeded] backspaces and                  ?\ : backspace    ( -- )  'bs'  emit  ;                         [unneeded] crs  ?\ : crs   ( n -- )  'cr'  emits  ;             [unneeded] tabs ?\ : tabs  ( n -- )  'tab' emits  ;             [unneeded] backspaces                                           ?\ : backspaces    ( n -- )  'bs'  emits  ;                                                                                                                                                     ( column last-column row last-row at-x at-y )                   [unneeded] column [unneeded] last-column and                    [unneeded] at-y and                                             ?\ : column  ( -- col )  xy drop  ;                             [unneeded] last-column                                          ?\ : last-column  ( -- row  )  column 1-  ;                     [unneeded] row [unneeded] last-row [unneeded] at-x and and      ?\ : row  ( -- row )  xy nip  ;                                 [unneeded] last-row                                             ?\ : last-row  ( -- row  )  row 1-  ;                           [unneeded] at-x                                                 ?\ : at-x  ( col -- )  row at-xy  ;                             [unneeded] at-y                                                 ?\ : at-y  ( row -- )  column swap at-xy  ;                                                                                                                                                     ( rnd random )                                                  2variable rnd-seed  $0111 rnd-seed !                            : rnd  ( -- u )                                                   rnd-seed 2@ $62DC um* rot 0 d+ over rnd-seed 2!  ;            : random  ( n -- 0..n-1 )  rnd um* nip  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ( random-range )                                                need random                                                     : random-range ( n1 n2 -- n3 ) over - 1+ random +  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ( fast-rnd fast-random )                                        need z80-asm  need os-seed                                      code fast-rnd  ( -- u )                                           os-seed fthl                                                    hl de ldp                                                       hl addp  de addp  hl addp  de addp  hl addp                     de addp  hl addp  hl addp  hl addp  hl addp  de addp            h inc  hl incp                                                  os-seed sthl                                                    jppushhl   end-code                                           : fast-random  ( n -- 0..n-1 )  fast-rnd um* nip  ;                                                                                                                                                                                                                                                                                                                                             ( crnd crandom )                                                need os-seed                                                    code crnd  ( -- b )                                               os-seed fthl                                                    ED c, 5F c,  a d ld  m e ld                                     de addp  l add  h xor                                           os-seed sthl                                                    pusha jp                                                        end-code                                                      : crandom  ( b -- 0..b-1 )  crnd um* nip  ;                                                                                                                                                                                                                                                                                                                                                                                                                     ( randomize randomize0 )                                        [defined] randomize                                             ?\  need os-seed  : randomize  ( n -- )  os-seed !  ;           [needed] randomize ?exit                                        need os-frames                                                  : randomize0  ( n -- )                                            ?dup 0=  if  os-frames @  then  randomize  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( columns rows set-mode-output set-font )                       [unneeded] columns [unneeded] rows and                          ?\ need value  32 value columns  24 value rows  exit            [unneeded] set-font                                             ?\ need os-chars  : set-font  ( a -- )  os-chars !  ;  exit     need os-chans                                                   : set-mode-output  ( a -- )                                       os-chans @ 2dup ! 2dup 5 + ! 15 + !  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ( set-banked-mode-output )                                      need set-mode-output                                            0 constant (output-routine)                                     code (banked-mode-output)  ( -- )                                 C5 c,  CD c, 0 ,                                                here cell- ' (output-routine) >body !                           C1 c,  DD c, 21 c, next ,  jpnext  end-code                   : set-banked-mode-output  ( a -- )                                (output-routine) !  \ patch `(banked-mode-output)`              ['] (banked-mode-output) set-mode-output  ;                                                                                                                                                                                                                                                                                                                                                                                                                   ( bleep )                                                       code bleep  ( duration pitch -- )                                 E1 c,  D1 c,  C5 c,  CD c, 03B5 ,                               C1 c,  DD c, 21 c, next ,                                       jpnext                                                          end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( beep>bleep )                                                  : beep>bleep  ( frequency duration1 -- duration2 pitch )          over 1000 */ swap                                               4375 100 rot */ 30 -  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ( laser-gun )                                                   need z80-asm                                                    code laser-gun  ( -- )                                            bc push                                                         5 b ld#                                                         0500 hl ldp#                                                    begin   0001 de ldp#                                                    hl push  03B5 call  hl pop  \ ROM beeper                        0010 de ldp#  de subp                                           jrnz                                                    bc pop  next ix ldp#  jpnext                                    end-code                                                                                                                                                                                                                                                                                                                      ( white-noise )                                                 need z80-asm                                                    code white-noise  ( u -- )                                        de pop                                                          bc push  \ save the Forth IP                                    de bc ldp  0000 hl ldp#  \ bc=duration, hl=start of ROM         5C48 fta  a sra  a sra  a sra  07 and#  a d ld                  begin   m e ld  hl incp  bc decp  bc push                               08 b ld#  \ bit counter                                         begin   e a ld  10 and#  e rl  d or  FE out  \ beep                     step                                                    bc pop  bc tstp                                                 jrnz                                                    bc pop  jpnext \ restore the Forth IP and go next               end-code                                                                                                                      ( ambulance )                                                   need z80-asm                                                    code ambulance  ( n -- )                                          de pop  bc push  e b ld                                         begin   bc push  0320 hl ldp#  000A de ldp#                             <mark   hl push                                                         03B5 call  \ ROM beeper                                         hl pop  hl decp                                                 hl tstp                                                         jrnz                                                    bc pop                                                          step                                                    bc pop  next ix ldp#  jpnext                                    end-code                                                                                                                                                                                      ( parse-escaped-string )                                        only forth definitions                                          need wid-of  need parse-char                                    vocabulary escaped-voc                                          wid-of escaped-voc constant escaped-wordlist                    also escaped-voc definitions                                    7 1 2constant a  8 1 2constant b  27 1 2constant e              12 1 2constant f  10 1 2constant l  13 1 2constant n            '"' 1 2constant q  13 1 2constant r  9 1 2constant t            11 1 2constant v  0 1 2constant z                               '"' 1 2constant "  '\' 1 2constant \                            : m  ( -- c1 c2 2 )  10 13 2  ;                                 : (x)  ( "c" -- n )                                               parse-char upper 16 digit? 0= #-260 ?throw  ;                 : x  ( "cc" -- c 1 )  (x) 16 * (x) + 1  ;                       -->                                                             ( parse-escaped-string )                                        only forth definitions  need char>string   need search-wordlist                         need chars>string  need s+              : unescape-char  ( c -- c1..cn n )                                dup char>string escaped-wordlist search-wordlist                if  nip execute  else  '\' 2  then  ;                         : parse-escaped-string  ( "ccc<quote>"  -- ca len )               0 0  \ dummy empty string to start with                         begin  parse-char dup '"' <>  while  \ not finished?              dup '\' =  \ possibly escaped char?                             if    drop parse-char unescape-char                             else  1  then  chars>string s+                                repeat  drop  ;                                                                                                                                                                                                                                               ( s\" )                                                         need parse-escaped-string                                       : s\"  ( Interpretation: "ccc<quote>" -- ca len )                      ( Compilation: "ccc<quote>" -- )                                ( Run-time: -- ca len )                                    parse-escaped-string compiling? if  postpone sliteral  then     ; immediate                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ( .\" )                                                         need parse-escaped-string                                       : .\"  ( Compilation: "ccc<quote>" -- )                                ( Run-time: -- ca len )                                    compile (.")  parse-escaped-string s,                           ; immediate compile-only                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( str= str< str> trim )                                         [unneeded] str=                                                 ?\ : str=  ( ca1 len1 ca2 len2 -- f )  compare 0=  ;  exit      [unneeded] str<                                                 ?\ : str<  ( ca1 len1 ca2 len2 -- f )  compare 0<  ;  exit      [unneeded] str>                                                 ?\ : str>  ( ca1 len1 ca2 len2 -- f )  compare 0>  ;  exit      [unneeded] trim                                                 : trim ( ca1 len1 -- ca2 len2 )  -leading -trailing  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ( sconstant char>string chars>string +place hunt )              : sconstant  ( ca len "name" -- )                                 here >r s, r> count 2constant  ;                              : char>string  ( c -- ca len )  1 allocate-string tuck c! 1  ;  : chars>string  ( c1..cn n -- ca len )                            dup if    dup allocate-string swap 2dup 2>r  ( c1..cn ca n )              bounds do  i c!  loop  2r>                                else  pad swap  then  ;                                   : +place  ( ca1 len1 ca2 )                                        2dup c@ + over c!  dup c@ 1+ + smove  ;                       : hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )                         search 0= if  chars + 0  then  ;                                                                                                                                                                                                                                                                                              ( s+ )                                                          need pick                                                       [defined] lengths                                               ?\ : lengths   2over nip over  ;                                : s+  ( ca1 len1 ca2 len2 -- ca3 len3 )                           lengths + >r           ( ca1 len2 ca2 len2 ) ( r: len3 )        r@ allocate-string >r  ( r: len3 ca3 )                          2 pick r@ +            ( ca1 len1 ca2 len2 len1+ca3 )           smove                  ( ca1 len1 )  \ 2nd string to buffer     r@ smove               \  1st string to buffer                  r> r>  ;                                                                                                                                                                                                                                                                                                                                                                                      ( #spaces #chars )                                              need under+                                                     : #spaces  ( ca len -- +n )                                       0 rot rot  0 do  count bl = under+  loop  drop abs  ;         : #chars  ( ca len c -- +n )                                      0 2swap 0 do                                                      ( c count ca ) count over = under+  loop  2drop abs  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( /name first-name trim last-name )                             : /name  ( ca1 len1 -- ca2 len2 ca3 len3 )                        bl skip 2dup bl scan  ;                                       : first-name  ( ca1 len1 -- ca2 len2 )  /name nip -  ;          need trim                                                       : last-name  ( ca1 len1 -- ca2 len2 )                             trim  begin  2dup bl scan bl skip dup                                 while  2nip  repeat  2drop  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ( prefix? suffix? )                                             need str=  need ?(                                              [unneeded] prefix? ?(                                           : prefix?  ( ca1 len1 ca2 len2 -- f )                             tuck 2>r min 2r> str=  ; ?)                                   [unneeded] suffix? (?                                           need pick                                                       : suffix? ( ca1 len1 ca2 len2 -- f )                              2swap dup 3 pick - /string str=  ; ?)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ( -prefix -suffix )                                             need ?(                                                         [unneeded] -prefix ?(  need prefix?                             : -prefix  ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )           dup >r 2over 2swap prefix?                                      if  swap r@ + swap r> -  else  rdrop  then  ; ?)              [unneeded] -suffix ?(  need suffix?                             : -suffix ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )            dup >r 2over 2swap suffix?                                      if  r> -  else  rdrop  then  ; ?)                                                                                                                                                                                                                                                                                                                                                                                                                             ( ud>str d>str chop s"" )                                       [unneeded] ud>str                                               ?\ : ud>str  ( ud -- ca len )  <# #s #>  ;                      [unneeded] d>str                                                ?\ : d>str  ( ud -- ca len )  tuck dabs <# #s rot sign #>  ;    [unneeded] chop                                                 ?\ : chop  ( ca len -- ca' len' )  1- swap char+ swap  ;        [unneeded] s""                                                  ?\ : s""  ( -- ca len )  0 allocate-string 0  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( save-counted-string )                                         : save-counted-string  ( ca1 len1 -- ca2 )                        dup 1+ allocate-string dup >r place r>  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( string/ char-in-string? char-position? ruler )                need ?(                                                         code string/  ( ca1 len1 len2 -- ca2 len2 )                       D9 c, C1 c, D1 c, E1 c, 19 c, A7 c, ED c, 42 c,                 E5 c, C5 c, D9 c, jpnext  end-code                            [unneeded] char-in-string? ?(  need -rot                        : char-in-string? ( ca len c -- f )                               -rot bounds ?do   dup i c@ = if  drop true unloop exit  then                loop  drop false  ; ?)                            [unneeded] char-position? ?(  need -rot                         : char-position?  ( ca len c -- +n true | false )                 -rot 0 ?do   2dup i + c@ = if  2drop i true unloop exit  then          loop  2drop false  ; ?)                                [unneeded] ruler ?(                                             : ruler  ( c len -- ca len )                                      dup allocate-string swap 2dup 2>r rot fill 2r>  ; ?)          ( os-chars os-chans os-flags2 os-seed os-frames os-udg )        [unneeded] os-chars    ?\ 23606 constant os-chars               [unneeded] os-chans    ?\ 23631 constant os-chans               [unneeded] os-flags2   ?\ 23658 constant os-flags2              [unneeded] os-seed     ?\ 23670 constant os-seed                [unneeded] os-frames   ?\ 23672 constant os-frames              [unneeded] os-udg      ?\ 23675 constant os-udg                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( os-coords os-coordx os-coordy )                               [unneeded] os-coords      ?\ 23677 constant os-coords           [unneeded] os-coordx      ?\ 23677 constant os-coordx           [unneeded] os-coordy      ?\ 23678 constant os-coordy                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ( os-attr-p os-mask-p os-attr-t os-mask-t os-p-flag )           [unneeded] os-attr-p      ?\ 23693 constant os-attr-p           [unneeded] os-mask-p      ?\ 23694 constant os-mask-p           [unneeded] os-attr-t      ?\ 23695 constant os-attr-t           [unneeded] os-mask-t      ?\ 23696 constant os-mask-t           [unneeded] os-p-flag      ?\ 23697 constant os-mask-t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ( ms )                                                          need os-frames                                                  : ms  ( u -- )                                                    20 / os-frames @ +                                              begin  dup os-frames @ u<  until drop  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( ms88 )                                                        need z80-asm                                                    code ms88  ( u -- )                                               de pop                                                          begin \ .reMS:                                                  d a ld                                                          e or nz if                                                        de push \ push bc                                               #133 de ldp#                                                    begin  \ .reMS2:                                                  dec decp  d a ld  e or                                        z until \ jr nz,reMS2                                           de pop \ pop bc                                                 de decp  l dec                                               z until \ jr nz,reMS                                             then  jpnext  end-code                                        ( frames@ frames! reset-frames )                                need os-frames                                                  : frames@  ( -- d )                                               os-frames @ [ os-frames 2+ ] literal c@  ;                    : frames!  ( d -- )                                               [ os-frames 2+ ] literal c! os-frames !  ;                    : reset-frames  ( -- )  0. frames!  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ( pause )                                                       need z80-asm  need call-xt  need execute-hl                     code pause ( u -- )                                               de pop  bc push                                                 begin                                                             de push                                                         ' (wait) call-xt  hl pop  execute-hl                            de pop  halt  de decp  de tstp  \ finished?                   z until                                                         bc pop  jpnext                                                  end-code                                                                                                                                                                                                                                                                                                                                                                                      ( pause )                                                       need z80-asm  need call-xt                                      defer (wait)  ' noop ' (wait) defer!                            code pause ( u -- )                                               de pop  bc push                                                 begin                                                             de push                                                         ' (wait) call-xt                                                de pop  halt  de decp  de tstp  \ finished?                   z until                                                         bc pop  jpnext                                                  end-code                                                                                                                                                                                                                                                                                                                      ( pause )                                                       need z80-asm  need execute-hl                                   code pause ( u -- )                                               de pop  bc push                                                 begin                                                             de push                                                         (wait) fthl  execute-hl                                         de pop  halt  de decp  de tstp  \ finished?                   z until                                                         bc pop  jpnext                                                  end-code                                                                                                                                                                                                                                                                                                                                                                                      ( pause )                                                       need z80-asm  need execute-hl                                   variable (wait)  ' noop (wait) !                                code pause ( u -- )                                               de pop  bc push                                                 begin                                                             de push                                                         ' (wait) >body fthl  execute-hl                                 de pop  halt  de decp  de tstp  \ finished?                   z until                                                         bc pop  jpnext                                                  end-code                                                                                                                                                                                                                                                                                                                      ( pause )                                                       need z80-asm  need execute-hl                                   variable (wait)  ' noop (wait) !                                code pause ( u -- )                                               de pop  bc push                                                 begin                                                             de push                                                         ' (wait) >body fthl execute-hl                                  de pop  halt  de decp  de tstp  \ finished?                   z until                                                         bc pop  jpnext                                                  end-code                                                                                                                                                                                                                                                                                                                      ( just-pause )                                                  need z80-asm                                                    code just-pause ( u -- )                                          de pop  bc push                                                 begin                                                             halt  de decp  de tstp  \ finished?                           z until                                                         bc pop  jpnext                                                  end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( leapy-year? )                                                 : leapy-year?  ( n -- f )                                         dup 400 mod 0= if  drop true   exit  then                       dup 100 mod 0= if  drop false  exit  then                             4 mod 0= if       false  exit  then                       false  ;                                                      exit                                                            need baden-case                                                 : leapy-year?  ( n -- f )                                         case 400 mod 0= of  true   endof                                case 100 mod 0= of  false  endof                                case   4 mod 0= of  true   endof                                othercase false  ;                                                                                                                                                                                                                                            ( set-date get-date )                                           create (date)  1 c,  1 c,  2016 ,                               : get-date  ( -- day month year )                                 (date) c@                                                       [ (date) 1+ ] literal c@                                        [ (date) 2+ ] literal @  ;                                    : set-date  ( day month year -- )                                 [ (date) 2+ ] literal !                                         [ (date) 1+ ] literal c!                                        (date) !  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                   ( set-time get-time reset-time )                                need frames@  need frames!  need m+  need alias  need ud*       : get-time  ( -- second minute hour )                             frames@ 50 um/mod nip s>d   ( sec . )                                   60 um/mod s>d       ( sec min . )                               60 um/mod           ( sec min hour )  ;               : set-time  ( second minute hour -- )                             3600 um*  rot 60 * m+  rot m+  ( seconds )                      50. ud* frames!  ;                                            ' reset-frames alias reset-time  ( -- )                                                                                                                                                                                                                                                                                                                                                                                                                         ( .time .system-time .date .system-date .time&date time&date )  need get-time  need get-date                                    : .00  ( n -- )  s>d <# # # #> type  ;                          : .0000  ( n -- )  s>d <# # # # # #> type  ;                    : .time  ( second minute hour -- )                                .00 ':' emit .00 ':' emit .00  ;                              : .system-time  ( -- )  get-time .time  ;                       : .date  ( day month year -- )                                    .0000 '-' emit .00 '-' emit .00  ;                            : .system-date  ( -- )  get-date  .date  ;                      : .time&date  ( second minute hour day month year -- )            .date 'T' emit .time  ;                                       : time&date  ( -- second minute hour day month year )             get-time get-date  ;                                                                                                                                                                          ( ~~ )                                                          need :noname  need defer  need is                               variable ~~?    ~~? on      \ active?                           variable ~~x    ~~x off     \ x coordinate                      variable ~~y    ~~y off     \ y coordinate                      variable ~~key  ~~key off   \ quit key, or zero if no pause     : ~~show  ( nt line block -- )                                    ~~x @ ~~y @ at-xy ." Block " . ." Line " . .name .s   ;       : ~~control  ( -- )                                               ~~key @ ?dup 0= ?exit  key = if  quit  then  ;                2variable ~~backup-xy                                           defer ~~save  ( -- )  defer ~~restore  ( -- )                   :noname  ( -- )  xy ~~backup-xy 2!        ; is ~~save           :noname  ( -- )     ~~backup-xy 2@ at-xy  ; is ~~restore        -->                                                                                                                             ( ~~ )                                                          : (~~)  ( nt line block -- )                                      ~~? @                                                           if    ~~save ~~show ~~control ~~restore                         else  2drop drop  then  ;                                     : ~~  ( -- )                                                      latest      postpone literal                                    >in @ c/l / postpone literal                                    blk @       postpone literal                                    postpone (~~)  ; immediate compile-only                                                                                                                                                                                                                                                                                                                                                                                                                       ( wid>link wid>name named-wid wid>vocabulary )                  need alias                                                      ' cell+ alias wid>link  ( wid -- a )                            : (wid>name)  ( wid -- a )  [ 2 cells ] literal +  ;            : wid>name  ( wid -- nt|0 )  (wid>name) @  ;                    : named-wid  ( wid -- )  (wid>name) latest swap !  ;            : wid>vocabulary  ( wid "name" -- )                               create dup , named-wid                                          does>  ( -- )  ( pfa )  @ context !  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ( get-order order@ )                                            need recurse                                                    : order@  ( a -- u*wid u )                                        dup @ dup if    >r cell+  recurse  r> swap 1+ exit                        then  nip  ;                                        : get-order  ( -- u*wid u )  context order@  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( wid-of swap-current trail find-name-in find )                 [unneeded] wid-of                                               ?\ : wid-of  ( "name" -- wid )  ' >body  ;  exit                [unneeded] trail                                                ?\ : trail  ( -- nt )  context @ @  ;  exit                     need [if]     [needed] swap-current [if]                        : swap-current  ( wid1 -- wid2 )                                  get-current swap set-current  ;    [then]                     [needed] find-name-in [if]                                      : find-name-in  ( ca len wid -- nt | 0 )  @ find-name-from  ;   [then]                                                          [needed] find [if]                                              : find  ( ca -- ca 0 | xt 1 | xt -1 )                             dup count find-name dup                                         if  nip name>immediate? 1 or negate  then  ;  [then]                                                                          ( nuclear-invaders )                                            \ Version 0.0.0+201605131201                                    \ Description                                                   \ This game is a ZX Spectrum port (for Solo Forth:              \ http://programandala.net/en.program.solo_forth.html) of a     \ game written by Dancresp in 2013 for Jupiter ACE              \ (http://www.zonadepruebas.com/viewtopic.php?t=4231).          \ Copyright (C) 2016 Marcos Cruz (programandala.net)            \ Copyright (C) 2013 Scainet Soft                               \ License                                                       \ You may do whatever you want with this work, so long as you   \ retain the copyright/authorship/acknowledgment/credit         \ notice(s) and this license in all redistributed copies and    \ derived works.  There is no warranty.                         only forth definitions                                          blk @ 1- last-locatable !                                       need roll      need inkey   need bleep        need beep>bleep   need os-chars  need os-udg  need 2/           need abort"       need value     need case    need random       need columns      need rows      need ocr     need ms           need s+           need 2value    need row     need char>string  need s\"          need alias     need plot    need adraw        need inverse      need overprint need column                                      4 constant /kk                                                  need kk-ports  need kk-1#   need pressed?     need kk-chars     [defined] binary  ?\ : binary  ( -- )  2 base !  ;              need defer                                                      need :noname  need benched    need ~~   13 ~~key !              defer (debug-point)  ' noop ' (debug-point) defer!              : debug-point  ( -- )                                             (debug-point)                                                   depth if                                                          cr ." Latest word: " latest .name                               cr .s  #-258 throw \ stack imbalance                          then                                                            ;                                                             debug-point                                                     16384 constant sys-screen  6912 constant /sys-screen                                       6144 constant /sys-screen-bitmap     22528 constant attributes  768 constant /attributes                  2 constant arena-top-y                                         21 constant tank-y                                          tank-y constant arena-bottom-y                                      23 constant status-bar-y                                    debug-point                                                     0 constant black    1 constant blue   2 constant red            3 constant magenta  4 constant green  5 constant cyan           6 constant yellow   7 constant white                            : papery   ( color -- paper-attribute )           8 *  ;        : brighty  ( attribute -- brighty-attribute )   64 or  ;        : flashy   ( attribute -- flashy-attribute )   128 or  ;        debug-point                                                     : set-color  ( b -- )  23695 c!  ;                              : color  ( b "name" -- )                                          create c,  does> ( -- )  ( pfa ) c@ set-color  ;              debug-point                                                                   white color text-color                                          black color arena-color                            white papery red + color brick-color                                  blue brighty color tank-color                                           blue color life-color                                          green color invader-color                              yellow brighty color container-color                                    yellow color projectile-color                                  magenta color ufo-color                             : init-colors  ( -- )                                             0 paper 7 ink 0 flash 0 bright                                  0 overprint 0 inverse 1 border  ;                             debug-point                                                     variable tank-x        \ column                                 variable projectile-x  \ column                                 variable projectile-y  \ row, 0 if no shoot                     variable ufo-x         \ column                                 variable lifes         \ counter (0..3)                         variable level         \ counter (1..5)                         variable score         \ counter                                variable record        \ max score                              variable invaders      \ counter (all units of every type)      variable invader-type  \ element of table  (0..9)               variable catastrophe   \ flag (game end condition)              record off                                                      debug-point                                                     13 constant enter-key                                           0 value kk-left#    0 value kk-right#    0 value kk-fire#       0. 2value kk-left   0. 2value kk-right   0. 2value kk-fire      : wait  ( -- )  begin  inkey  until  ;                          : enter-key?  ( -- f )  inkey enter-key =  ;                    : wait-for-enter  ( -- )  begin  enter-key?  until  ;           : kk#>c  ( n -- c )  kk-chars + c@  ;                           : kk#>string  ( n -- ca len )                                     case  kk-en# of  s" Enter"         endof                              kk-sp# of  s" Space"         endof                              dup kk#>c upper char>string rot  \ default                endcase  ;                                                    3 constant /controls                                            create controls  here                                               kk-5# c,  kk-8# c,  kk-en# c,   \ cursor with Enter             kk-r# c,  kk-t# c,  kk-en# c,   \ Spanish Dvorak keyboard       kk-z# c,  kk-x# c,  kk-en# c,   \ from the original game        kk-5# c,  kk-8# c,  kk-0#  c,   \ cursor joystick               kk-5# c,  kk-8# c,  kk-sp# c,   \ cursor with Space             kk-1# c,  kk-2# c,  kk-5#  c,   \ Sinclair joystick 1           kk-6# c,  kk-7# c,  kk-0#  c,   \ Sinclair joystick 2           kk-o# c,  kk-p# c,  kk-q#  c,   \ QWERTY                        kk-n# c,  kk-m# c,  kk-q#  c,   \ QWERTY                        kk-q# c,  kk-w# c,  kk-p#  c,   \ QWERTY                        kk-z# c,  kk-x# c,  kk-p#  c,   \ QWERTY                    here swap - /controls / constant max-controls                   max-controls 1- constant last-control                           : >controls  ( n -- a )  /controls * controls +  ;              : #>kk  ( n -- d )  /kk * kk-ports + kk@  ;                     : set-controls  ( n -- )                                          >controls     dup c@  dup to kk-left#   #>kk 2to kk-left                   1+ dup c@  dup to kk-right#  #>kk 2to kk-right                  1+     c@  dup to kk-fire#   #>kk 2to kk-fire  ;   variable current-controls                                       current-controls off                                            current-controls @ set-controls                                 : next-controls  ( -- )                                           current-controls @ 1+  dup last-control > 0= abs *              dup current-controls !  set-controls  ;                       debug-point                                                     : beep  ( n1 n2 -- )  beep>bleep bleep  ;                       debug-point                                                             $80 constant first-udg  \ first UDG code in Solo Forth          $FF constant last-udg   \ last UDG code in Solo Forth           128 constant udgs       \ number of UDGs \ XXX TMP --             8 constant /udg       \ bytes per UDG                 udgs /udg * constant /udg-set   \ size of the UDG set in bytes  create udg-set /udg-set allot                                   udg-set os-udg !                                                : udg>bitmap  ( c -- a )  first-udg - /udg * udg-set +  ;       : >scan  ( n c -- a )  udg>bitmap +  ;                          : scan!  ( c b n -- c )  rot >scan c!  ;                        variable used-udgs  used-udgs off                               : ?free-udg  ( n -- )                                             used-udgs +!  used-udgs @ udgs > abort" Too many UDGs"  ;     debug-point                                                     : font!  ( a -- )  os-chars !  ;                                : font@  ( -- a )  os-chars @  ;                                variable ocr-first-udg                                          variable ocr-last-udg                                           : init-ocr  ( -- )                                                ocr-first-udg @ udg>bitmap ocr-charset !                        ocr-first-udg @ ocr-first !                                     ocr-last-udg @ ocr-first-udg @ - 1+ ocr-chars !  ;  \ chars   : rom-font  ( -- )  15360 font!  ;                              warnings @  warnings off                                        variable ~~base                                                 : ~~(  ( -- )  base @ ~~base ! decimal  ;                       : ~~)  ( -- )  ~~base @ base !  ;                               : ~~  ( -- )                                                      postpone ~~(  postpone ~~  postpone ~~)  ; immediate          ~~? off                                                         warnings !                                                      : XXX  ( -- )                                                     ~~? on                                                          base @ >r decimal latest .name .s r> base !                     key drop ;                                                    debug-point                                                      1 constant score-y                                             14 constant record-x                                            variable players  1 players !  \ XXX TODO -- not used yet       variable player   1 player !   \ XXX TODO -- not used yet       : score-x  ( -- x )  3 player @ 1- 22 * +  ;                    : (.score)  ( n x y -- )                                          at-xy s>d <# # # # # #> text-color type  ;                    : score-xy  ( -- x y )  score-x score-y  ;                      : at-score  ( -- )  score-xy at-xy  ;                           : .score  ( -- )  score @ score-xy (.score)  ;                  : .record  ( -- )  record @ record-x score-y (.score)  ;        : update-score  ( n -- )  score +! .score  ;                        variable >udg  first-udg >udg !  \ next free UDG            variable latest-sprite-width                                    variable latest-sprite-height                                   variable latest-sprite-udg                                      : ?udg  ( c -- )  last-udg > abort" Too many UDGs"  ;           : free-udg  ( n -- c )                                            >udg @ dup latest-sprite-udg !                                  tuck +  dup >udg !  1- ?udg  ;                                : latest-sprite-size!  ( width height -- )                        latest-sprite-height !  latest-sprite-width !  ;              : ?sprite-height  ( -- )                                          latest-sprite-height @ 1 >                                      abort" Sprite height not supported for sprite strings"  ;     : sprite-string  ( "name" -- )                                    ?sprite-height                                                  here latest-sprite-udg @  latest-sprite-width @ dup >r          0 ?do  dup c, 1+  loop  drop  r> 2constant  ;                 : (1x1sprite!)  ( b0..b7 c -- )                                   1 ?free-udg  1 1 latest-sprite-size!                            /udg 0 do                                                         dup /udg 1+ i - roll i scan!                                  loop  drop  ;                                                 : 1x1sprite!  ( b0..b7 -- )                                       1 free-udg (1x1sprite!)  ;                                    : 1x1sprite  ( n0..n7 "name" -- )                                 1 free-udg dup constant (1x1sprite!)  ;                        ' emit alias .1x1sprite   ( c -- )                             ' emits alias .1x1sprites  ( c n -- )                           : (2x1sprite!)  ( n0..n7 c -- )                                   2 ?free-udg  2 1 latest-sprite-size!                            /udg 0 do                                                         dup /udg 1+ i - pick flip i scan! 1+  \ first UDG               dup /udg 1+ i - roll      i scan! 1-  \ second UDG            loop  drop  ;                                                 : 2x1sprite!  ( n0..n7 -- )                                       2 free-udg (2x1sprite!)  ;                                    : 2x1sprite  ( n0..n7 "name" -- )                                 2 free-udg dup constant (2x1sprite!)  ;                       : .2x1sprite  ( c -- )  dup emit 1+ emit  ;                     debug-point                                                     2 constant udg/invader                                          >udg @ ocr-first-udg !                                          binary                                                          0000001111000000                                                0001111111111000                                                0011111111111100                                                0011100110011100                                                0011111111111100                                                0000011001100000                                                0000110110110000                                                0011000000001100                                                2x1sprite invader-1                                             sprite-string invader-1$  ( -- ca len )                         0000001111000000                                                0001111111111000                                                0011111111111100                                                0011100110011100                                                0011111111111100                                                0000111001110000                                                0001100110011000                                                0001100000011000                                                2x1sprite!                                                      0000001111000000                                                0001111111111000                                                0011111111111100                                                0011100110011100                                                0011111111111100                                                0000111001110000                                                0001100110011000                                                0000110000110000                                                2x1sprite!                                                      0000001111000000                                                0001111111111000                                                0011111111111100                                                0011100110011100                                                0011111111111100                                                0000111001110000                                                0001100110011000                                                0001100000011000                                                2x1sprite!                                                      0000100000100000                                                0000010001000000                                                0000111111100000                                                0001101110110000                                                0011111111111000                                                0011111111111000                                                0010100000101000                                                0000011011000000                                                2x1sprite invader-2                                             sprite-string invader-2$  ( -- ca len )                         binary                                                          0000100000100000                                                0000010001000000                                                0000111111100000                                                1111101110111110                                                0011111111111000                                                0001111111110000                                                0000100000100000                                                0001000000010000                                                2x1sprite!                                                      0000100000100000                                                0010010001001000                                                0010111111101000                                                0011101110111000                                                0011111111111000                                                0001111111110000                                                0000100000100000                                                0001000000010000                                                2x1sprite!                                                      0000100000100000                                                0000010001000000                                                0000111111100000                                                1111101110111110                                                0011111111111000                                                0001111111110000                                                0000100000100000                                                0001000000010000                                                2x1sprite!                                                      0000000110000000                                                0000001111000000                                                0000011111100000                                                0000110110110000                                                0000111111110000                                                0000001001000000                                                0000010110100000                                                0000101001010000                                                2x1sprite invader-3                                             sprite-string invader-3$  ( -- ca len )                         0000000110000000                                                0000001111000000                                                0000011111100000                                                0000110110110000                                                0000111111110000                                                0000010110100000                                                0000100000010000                                                0000100000010000                                                2x1sprite!                                                      0000000110000000                                                0000001111000000                                                0000011111100000                                                0000110110110000                                                0000111111110000                                                0000010110100000                                                0000100000010000                                                0000010000100000                                                2x1sprite!                                                      0000000110000000                                                0000001111000000                                                0000011111100000                                                0000110110110000                                                0000111111110000                                                0000010110100000                                                0000100000010000                                                0000100000010000                                                2x1sprite!                                                      0000000000000000                                                0000011111100000                                                0001111111111000                                                0011111111111100                                                0110110110110110                                                1111111111111111                                                0011100110011100                                                0001000000001000                                                2x1sprite ufo                                                   sprite-string ufo$  ( -- ca len )                               0000000000000000                                                0000011111100000                                                0001111111111000                                                0011111111111100                                                0011011011011010                                                1111111111111111                                                0011100110011100                                                0001000000001000                                                2x1sprite!                                                      0000000000000000                                                0000011111100000                                                0001111111111000                                                0011111111111100                                                0101101101101100                                                1111111111111111                                                0011100110011100                                                0001000000001000                                                2x1sprite!                                                      0000000000000000                                                0000011111100000                                                0001111111111000                                                0011111111111100                                                0010110110110110                                                1111111111111111                                                0011100110011100                                                0001000000001000                                                2x1sprite!                                                      11111011                                                        11111011                                                        11111011                                                        00000000                                                        11011111                                                        11011111                                                        11011111                                                        00000000                                                        1x1sprite brick                                                 >udg @ 1- ocr-last-udg !                                        11111111                                                        11111111                                                        11111000                                                        11111100                                                        11100100                                                        10000000                                                        00000000                                                        00000000                                                        1x1sprite broken-top-brick                                      00000000                                                        10000000                                                        10100000                                                        11100100                                                        11111100                                                        11111000                                                        11111101                                                        11111111                                                        1x1sprite broken-bottom-brick                                   2 constant udg/tank                                             0000000100000000                                                0000001110000000                                                0000001110000000                                                0111111111111100                                                1111111111111110                                                1111111111111110                                                1111111111111110                                                1111111111111110                                                2x1sprite!                                                      sprite-string tank$  ( -- ca len )                              0000010001000000                                                0010001010001000                                                0001000000010000                                                0000100000100000                                                0110000000001100                                                0000010000100000                                                0001001010010000                                                0010010001001000                                                2x1sprite!                                                      sprite-string invader-explosion$  ( -- ca len )                 00000000                                                        00000001                                                        00000001                                                        00000001                                                        00000001                                                        00000001                                                        00000000                                                        00000000                                                        1x1sprite projectile                                            0000000000000010                                                0010000001100100                                                0100011111110000                                                0000111111111010                                                0001111011011001                                                0100110011110000                                                1000011111000100                                                0010001100010010                                                2x1sprite!                                                      sprite-string ufo-explosion$  ( -- ca len )                     0000001111100000                                                0001110000011100                                                0010001111100010                                                0010000000000010                                                0010000111000010                                                0010001111100010                                                0010000111000010                                                0010000010000010                                                2x1sprite container-top                                         00000000                                                        00011100                                                        00100010                                                        00100010                                                        00100010                                                        00100001                                                        00100001                                                        00100001                                                        1x1sprite broken-top-left-container                             00000000                                                        00011100                                                        00100010                                                        00100010                                                        01000010                                                        01000010                                                        01000010                                                        10000010                                                        1x1sprite broken-top-right-container                            0010010101010010                                                0010111101111010                                                0010111000111010                                                0010011000110010                                                0010000000000010                                                0001110000011100                                                0000001111100000                                                0000000000000000                                                2x1sprite container-bottom                                      00000001                                                        00000111                                                        00011110                                                        00100110                                                        00100000                                                        00011100                                                        00000011                                                        00000000                                                        1x1sprite broken-bottom-left-container                          11000000                                                        01110000                                                        00111100                                                        00110010                                                        00000010                                                        00011100                                                        11100000                                                        00000000                                                        1x1sprite broken-bottom-right-container                         0000000000000000                                                0000000000001000                                                0000000000001100                                                0000111111111110                                                0000111111111111                                                0000111111111110                                                0000000000001100                                                0000000000001000                                                2x1sprite right-arrow                                           sprite-string right-arrow$  ( -- ca len )                       0000000000000000                                                0001000000000000                                                0011000000000000                                                0111111111110000                                                1111111111110000                                                0111111111110000                                                0011000000000000                                                0001000000000000                                                2x1sprite left-arrow                                            sprite-string left-arrow$  ( -- ca len )                        0000111111110000                                                0011000000001100                                                0011000000001100                                                0010111111110100                                                0010000000000100                                                0010000000000100                                                0010000000000100                                                1111111111111111                                                2x1sprite fire-button                                           sprite-string fire-button$  ( -- ca len )                       debug-point                                                     : centered  ( len -- column )  columns swap - 2/  ;             : centered-at  ( row len -- )  centered swap at-xy  ;           : center-type  ( ca len row -- )  over centered-at type  ;      : type-blank  ( ca len -- )  nip spaces  ;                      : center-type-blank  ( ca len row -- )                            over centered-at type-blank ;                                 17 constant message-y  \ row for game messages                  : message  ( ca len -- )                                          2dup message-y text-color center-type  1500 ms                       message-y center-type-blank  ;                           debug-point                                                     : title  ( -- )  s" NUCLEAR INVADERS" 0 center-type  ;          : (c)  ( -- )  127 emit  ;                                      : .copyright  ( -- )                                              row                                                             1 over    at-xy (c) ."  2013 Scainet Soft"                      1 over 1+ at-xy (c) ."  2016 Marcos Cruz"                       8 swap 2+ at-xy           ." (programandala.net)"  ;          : left-key$   ( -- ca len )  kk-left# kk#>string  ;             : right-key$  ( -- ca len )  kk-right# kk#>string  ;            : fire-key$   ( -- ca len )  kk-fire# kk#>string  ;             : controls$  ( -- ca len )                                        left-arrow$ left-key$ s+                                        s"   " s+ fire-key$ s+ s"   " s+                                right-key$ s+ right-arrow$ s+  ;                              : .controls  ( -- )                                               s" [Space] to change controls:" row dup >r center-type          fire-button$ r@ 2+ center-type                                  0 r@ 3 + at-xy columns spaces                                   controls$ r> 3 + center-type  ;                               : .score-table-item  ( ca1 len1 ca2 len2 -- )                     type text-color ."  = " type  ;                               9 constant score-table-x                                        : .score-table  ( -- )                                            score-table-x row                                               2dup     at-xy s" 10 points"                                             invader-color invader-1$ .score-table-item             2dup 2+  at-xy s" 20 points"                                             invader-color invader-2$ .score-table-item             2dup 4 + at-xy s" 30 points"                                             invader-color invader-3$ .score-table-item                  6 + at-xy s" bonus"                                                 ufo-color ufo$ .score-table-item  ;                  : at-controls  ( -- )  0 12 at-xy  ;                            : show-controls  ( -- )  at-controls .controls  ;               : menu  ( -- )                                                    begin                                                             break-key? if  quit  then  \ XXX TMP                            key                                                             dup enter-key = if  drop exit  then                                        bl = if  next-controls show-controls  then         again  ;                                                      : instructions  ( -- )                                            text-color  cls  title                                          0 3 at-xy .score-table                                          show-controls                                                   s" [Enter] to start" 18 center-type                             0 21 at-xy .copyright                                           menu  ;                                                       arena-bottom-y arena-top-y - 1+ columns * constant /arena       arena-top-y columns * attributes + constant arena-top-attribute : black-arena  ( -- )  arena-top-attribute /arena erase  ;      : wipe-arena  ( -- )  0 arena-top-y at-xy /arena spaces  ;      : -arena  ( -- )  black-arena wipe-arena  ;                     : score-bar$  ( -- ca len )                                       text-color s"  SCORE<1>    RECORD    SCORE<2>"  ;             : score-bar  ( -- )                                               home score-bar$ type .score .record  ;                        : show-player  ( -- )                                             10 0 do  at-score 4 spaces 64 ms  .score 64 ms  loop  ;       need pixel-addr                                                 : row>pixel  ( n1 -- n2 )  8 * 191 swap -  ;                    : ruler  ( -- )                                                   [ 0 tank-y row>pixel 8 - pixel-addr nip ] literal               columns $FF fill  ;                                           : at-lifes  ( -- )  0 status-bar-y at-xy  ;                     : .lifes  ( -- )                                                  at-lifes life-color                                             lifes @ 0 ?do  tank$ type  loop  ."   "  ;                    : status-bar  ( -- )  ruler .lifes  ;                           : game-screen  ( -- )  init-colors cls score-bar status-bar  ;                      0 constant invaders-min-x                   columns udg/invader - constant invaders-max-x                        10 constant invader-types                                  6 cells constant /invader-type                                  create default-invaders-data                                    here                                                                3 ,     0 ,      5 , invaders-min-x ,  invader-3 ,   1 ,        3 ,     0 ,      7 , invaders-min-x ,  invader-2 ,   1 ,        3 ,     0 ,      9 , invaders-min-x ,  invader-2 ,   1 ,        3 ,     0 ,     11 , invaders-min-x ,  invader-1 ,   1 ,        3 ,     0 ,     13 , invaders-min-x ,  invader-1 ,   1 ,        3 ,     0 ,      5 , invaders-max-x ,  invader-3 ,  -1 ,        3 ,     0 ,      7 , invaders-max-x ,  invader-2 ,  -1 ,        3 ,     0 ,      9 , invaders-max-x ,  invader-2 ,  -1 ,        3 ,     0 ,     11 , invaders-max-x ,  invader-1 ,  -1 ,        3 ,     0 ,     13 , invaders-max-x ,  invader-1 ,  -1 ,    here swap - constant /invaders-data                             create invaders-data  /invaders-data allot                      : >invader   ( -- n )  invader-type @ /invader-type *  ;        : 'invader   ( -- a )  >invader invaders-data +  ;              : 'default-invader   ( -- a )                                     >invader default-invaders-data +  ;                           : invader-units   ( -- a )  'invader            ;               : invader-active  ( -- a )  'invader cell+      ;               : invader-y       ( -- a )  'invader [ 2 cells ] literal +  ;   : invader-x       ( -- a )  'invader [ 3 cells ] literal +  ;   : invader-xy@    ( -- x y )  invader-y 2@  ;                    : invader-char@  ( -- c )  'invader [ 4 cells ] literal + @  ;  : invader-x-inc@  ( -- n )  'invader [ 5 cells ] literal + @  ; : invader-default-x@    ( -- x y )                                'default-invader [ 3 cells ] literal + @  ;                    4 constant building-top-y                                      15 constant building-bottom-y                                   variable building-width                                         variable building-left-x     variable building-right-x          variable containers-left-x   variable containers-right-x        : set-building-size  ( -- )                                       level @ 2* 2+  building-width !                                 [ columns 2/ 1- ] literal \ half of the screen                  level @ \ half width of all containers                          2dup 1- - containers-left-x !                                   2dup    - building-left-x !                                     2dup    + containers-right-x !                                       1+ + building-right-x !  ;                               5 constant max-level                                            : increase-level  ( -- )  level @ 1+ max-level min level !  ;   : update-level  ( -- )  increase-level set-building-size  ;     : init-level  ( -- )  level off  update-level  ;                : floor  ( y -- )                                                 building-left-x @ swap at-xy                                    brick-color brick building-width @ .1x1sprites  ;             : building-top  ( -- )  building-top-y floor  ;                 : building-bottom  ( -- )  building-bottom-y  floor  ;          : containers-bottom  ( n -- )                                     container-color                                                 0 ?do  container-bottom .2x1sprite  loop  ;                   : containers-top  ( n -- )                                        container-color                                                 0 ?do  container-top .2x1sprite  loop  ;                      : .brick  ( -- )  brick-color brick .1x1sprite  ;               : building  ( -- )                                                building-bottom                                                 level @  building-left-x @                                      building-top-y [ building-bottom-y 2- ] literal                 do                                                                2dup i 1+ at-xy .brick containers-bottom .brick                 2dup i    at-xy .brick containers-top    .brick               -2 +loop  2drop  building-top  ;                                                  1 constant tank-min-x                       columns udg/tank - 1- constant tank-max-x                       : tank-range  ( column -- column' )                               tank-max-x min tank-min-x max  ;                              : ?space   ( -- )  column if  text-color space  then  ;         : moving-tank?  ( -- -1|0|1 )                                     kk-left pressed? kk-right pressed? abs +  ;                   : .tank  ( -- )  tank-color tank$ type  ;                       : at-tank  ( -- )  tank-x @ tank-y at-xy  ;                     : tank-ready  ( -- )  at-tank .tank  ;                          : -tank  ( -- )  at-tank text-color 2 spaces  ;                 : move-tank  ( -1|1 -- )                                          tank-x @ + tank-range dup tank-x ! tank-y at-xy  ;            : drive  ( -- )                                                   moving-tank? ?dup 0= ?exit  -tank move-tank .tank  ;          : init-game  ( -- )                                               init-ocr  3 lifes !  init-level  score off  game-screen  ;    : init-invaders-data  ( -- )                                      default-invaders-data invaders-data /invaders-data move  ;    : init-ufo  ( -- )  -200 ufo-x !  ;                             : total-invaders  ( -- n )                                        0   invader-types 0 do                                                i invader-type ! invader-units @ +                            loop  ;                                                   : init-invaders  ( -- )                                           init-invaders-data  invader-type off                            total-invaders invaders !  ;                                  : init-tank  ( -- )                                               columns udg/tank - 2/ tank-x !  \ middle of the screen          projectile-y off  ;                                           : parade  ( -- )                                                  invader-color                                                   invader-1 dup invader-2 dup invader-3                           building-bottom-y [ building-top-y 1+ ] literal                 do                                                                invaders-min-x i at-xy dup .2x1sprite                           invaders-max-x i at-xy     .2x1sprite                         2 +loop  ;                                                    : init-arena  ( -- )   -arena building tank-ready parade  ;     : level-message  ( -- ca len )                                    text-color s" LEVEL " level @ s>d <# # #> s+  ;               : show-level  ( -- )  level-message message  ;                  : init-combat  ( -- )                                             catastrophe off init-invaders init-ufo init-tank init-arena     show-level show-player  ;                                     : at-invader  ( -- )  invader-xy@ at-xy  ;                      4 constant frames/invader                                       : sprite>frame  ( c1 x -- c2 )                                    frames/invader mod udg/invader * +  ;                         : invader-frame  ( -- c )                                         invader-char@ invader-x @ sprite>frame  ;                     : .invader  ( -- )  invader-color invader-frame .2x1sprite  ;   variable broken-wall-x                                          : flying-to-the-right?  ( -- f )  invader-x-inc@ 0>  ;          red papery c,  here  red c,  constant broken-brick-colors       : broken-wall-color  ( -- )                                       broken-brick-colors flying-to-the-right? + c@ set-color  ;    : broken-bricks-coordinates  ( -- x1 y1 x2 y2 )                   broken-wall-x @ invader-y @ 1+  2dup 2-  ;                    : broken-left-wall  ( -- )                                        broken-bricks-coordinates                                       at-xy broken-bottom-brick .1x1sprite                            at-xy broken-top-brick  .1x1sprite  ;                         : broken-right-wall  ( -- )                                       broken-bricks-coordinates                                       at-xy broken-top-brick .1x1sprite                               at-xy broken-bottom-brick .1x1sprite  ;                       : broken-wall  ( -- )                                             broken-wall-color flying-to-the-right?                          if  broken-left-wall  else  broken-right-wall  then  ;        : broken-wall?  ( -- f )                                          invader-x @ flying-to-the-right?                                if    1+ building-left-x                                        else  building-right-x                                          then  @ dup broken-wall-x ! =  ;                              : broken-left-container  ( -- )                                   invader-x @ 2+ invader-y @ at-xy                                broken-top-right-container .1x1sprite                           invader-x @ 1+ invader-y @ 1+ at-xy                             broken-bottom-left-container .1x1sprite  ;                    : broken-right-container  ( -- )                                  invader-x @ 1- invader-y @ at-xy                                broken-top-left-container .1x1sprite                            invader-x @ invader-y @ 1+ at-xy                                broken-bottom-right-container .1x1sprite  ;                   : broken-container  ( -- )                                        container-color                                                 flying-to-the-right?  if    broken-left-container                                     else  broken-right-container  then  ;   : broken-container?  ( -- f )                                     invader-x @ flying-to-the-right?                                if    1+ containers-left-x                                      else     containers-right-x  then  @ =  ;                     : damages  ( -- )                                                 broken-wall? if  broken-wall exit  then                         broken-container? dup if    broken-container                                          then  catastrophe !  ;                  : flying-invader  ( -- )                                          invader-x-inc@ dup 0>  \ flying to the right?                   if    at-invader text-color space .invader invader-x +!         else  invader-x +! at-invader .invader ?space  then  ;        : activate-invader  ( -- )                                        32 random  26 invaders @ 5 < 16 * -  > invader-active !  ;    : last-invader-type?  ( -- f )                                    invader-type @ [ invader-types 1- ] literal =  ;              : next-invader  ( -- )                                            last-invader-type?                                              if  invader-type off  else  1 invader-type +!  then  ;        variable delay  50 delay !  \ ms                                : move-invader  ( -- )                                            delay @ ms  \ XXX TMP --                                        invader-active @                                                if  flying-invader damages  else  activate-invader  then  ;   : invasion  ( -- )                                                invader-units @ if  move-invader  then  next-invader  ;        3 constant ufo-y       \ row                                   27 constant ufo-max-x   \ column                                : ufo-invisible?  ( -- f )  ufo-x @ 0<  ;                       : at-ufo  ( -- )  ufo-x @ ufo-y at-xy  ;                        : -ufo  ( -- )  at-ufo 3 spaces init-ufo  ;                     : ufo-lost?  ( -- f )  ufo-x @ ufo-max-x >  ;                   : ufo-frame  ( -- c )  ufo ufo-x @ sprite>frame  ;              : flying-ufo  ( -- )                                              1 ufo-x +! at-ufo ufo-color space ufo-frame .2x1sprite  ;     : (move-ufo)  ( -- )                                              ufo-lost?  if  -ufo  else  flying-ufo  then  ;                : move-ufo  ( -- )                                                ufo-invisible? if  1 ufo-x +!  else  (move-ufo)  then  ;      : ufo-bang  ( -- )  18 12 do  i 15 beep  loop  ;                : ufo-on-fire  ( -- )                                             ufo-x @ 1+ ufo-y at-xy ufo-explosion$ type  ;                 : ufo-explosion  ( -- )  ufo-on-fire ufo-bang  ;                : ufo-points  ( -- n )  32 random 12 / 1+ 50 *  ;               : ufo-bonus  ( -- )                                               ufo-points dup ufo-x @ 1+ ufo-y at-xy .  update-score  ;      : ufo-impacted  ( -- )  ufo-explosion ufo-bonus 200 ms -ufo  ;  : invader-points  ( -- n )                                        projectile-y @ 3 - 2/          \ depending on the row           projectile-y @                                                  dup 5 = if  drop 30                                                     else  10 > 10 * 20 +  then  ;                         : invader-bonus  ( -- )  invader-points  update-score  ;        : invader-bang  ( -- ca len )  10 100 beep  ;                   : invader-on-fire  ( -- )                                         at-invader invader-explosion$ type  ;                         : -invader  ( -- )  at-invader 2 spaces  ;                      : invader-explosion  ( -- )                                       invader-on-fire invader-bang -invader  ;                      : impacted-invader  ( -- n )                                      projectile-y @ [ building-top-y 1+ ] literal - 2/               projectile-x @ [ columns 2/ ] literal > abs 5 * +  ;          : replace-invader  ( -- )                                         invader-active off                                              invader-default-x@ invader-x !  at-invader                      invader-color invader-char@ .2x1sprite  ;                     : current-invader-impacted  ( -- )                                invader-bonus invader-explosion                                 -1 invaders +!  -1 invader-units +!                             invader-units @ if  replace-invader  then  ;                  : invader-impacted  ( -- )                                        invader-type @ >r  impacted-invader invader-type !              current-invader-impacted  r> invader-type !  ;                : (impact)  ( -- )                                                projectile-y @ ufo-y = if  ufo-impacted exit  then              invader-impacted  ;                                           : impact  ( -- )                                                  projectile-y @ building-bottom-y <                              if  (impact)  then  projectile-y off  ;                       : projectile-xy  ( -- x y )  projectile-x @ projectile-y @  ;   : hit?  ( -- f )  projectile-xy ocr 0<>  ;                      : impact?  ( -- f )  hit? dup if  impact  then  ;               : at-projectile  ( -- )  projectile-xy at-xy  ;                 : .projectile  ( -- )                                             projectile-color at-projectile projectile .1x1sprite  ;       : fire-sound  ( -- )  ;                                         : fire  ( -- )                                                    tank-x @ projectile-x !                                         [ tank-y 1- ] literal projectile-y !  fire-sound  ;           : -projectile  ( -- )  at-projectile text-color space  ;        : projectile-lost?  ( -- f )                                      projectile-y @ building-top-y <  ;                            : shooted  ( -- )                                                 -projectile  projectile-lost? if  projectile-y off exit  then   -1 projectile-y +! impact? ?exit                                .projectile  ;                                                : shooted?  ( -- f )  projectile-y @ 0<>  ;                     : fire?  ( -- f )  kk-fire pressed?  ;                          : shoot  ( -- )                                                   shooted? if  shooted exit  then  fire? if  fire  then  ;      : new-record?   ( -- f )  score @ record @ >  ;                 : new-record    ( -- f )  score @ record !  ;                   : check-record  ( -- )  new-record? if  new-record  then  ;     : .game-over  ( -- )  s" GAME OVER" message  ;                  : game-over  ( -- )  .game-over check-record  ;                 : next-level  ( -- )  update-level show-level  ;                : dead  ( -- )  -1 lifes +!  .lifes  ;                          : defeat-tune  ( -- )  100 200 do  i 20 beep  -5 +loop  ;       : defeat  ( -- )  defeat-tune  300 ms  dead  ;                  : victory?  ( -- f )  invaders @ 0=  ;                          : (combat)  ( -- )                                                begin   victory? if  next-level init-combat  then                       break-key? if  quit  then  \ XXX TMP                            drive shoot move-ufo invasion  catastrophe @            until   defeat  ;                                             : combat  ( -- )  init-combat (combat)  ;                       : defeat?  ( f )  lifes @ 0=  ;                                 : game  ( -- )                                                    init-game  begin  combat defeat?  until  game-over  ;         : run  ( -- )  begin  instructions game  again  ;               : .udgs  ( -- )  cr udgs 0 do  i 128 + emit  loop  ;            : ni  ( -- )      next-invader  ;                               : m   ( -- )      move-invader broken-container? home .  ;      : in  ( -- )      init-game init-combat  ;                      : bc  ( -- )                                                      cls                                                             space broken-top-right-container .1x1sprite                     container-top .2x1sprite                                        broken-top-left-container .1x1sprite space cr                   container-bottom .2x1sprite 8 emit 8 emit                       broken-bottom-left-container .1x1sprite                         xy swap 1+ swap at-xy                                           container-bottom .2x1sprite                                     container-bottom .2x1sprite 8 emit                              broken-bottom-right-container .1x1sprite cr  ;                init-level                                                      end-section                                                                                                                     