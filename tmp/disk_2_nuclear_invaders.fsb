  \ 000.fsb

( Nuclear Invaders )

\ Description

\ This game is a ZX Spectrum port (for Solo Forth:
\ http://programandala.net/en.program.solo_forth.html) of a
\ game written by Dancresp in 2013 for Jupiter ACE
\ (http://www.zonadepruebas.com/viewtopic.php?t=4231).

\ This version:
\ Copyright (C) 2016 Marcos Cruz (programandala.net)

\ Original version:
\ Copyright (C) 2013 Scainet Soft

\ License

\ You may do whatever you want with this work, so long as you
\ retain the copyright/authorship/acknowledgment/credit
\ notice(s) and this license in all redistributed copies and
\ derived works.  There is no warranty.

  \ vim: filetype=soloforth
( Nuclear Invaders -- load block  )

2 load
  \ Compile the `need` utility, which must be on block 2.

locate nuclear-invaders
  \ Find the block of the game, which must be after the library
  \ blocks.

dup 1- last-locatable !
  \ Do not look for needed words beyond the source of the game.
  \ This makes things faster when a needed word is not found:
  \ `need` does not waste time searching the rest of the
  \ blocks.

load
  \ Compile the game.

  \ vim: filetype=soloforth
  \ 002_need.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The `need` utility which manages the library dependencies.
  \ It must be at block 2 of the library.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( contains delimited located )

  \ XXX TMP
  \ XXX INFORMER
  \ : contains  ( ca1 len1 ca2 len2 -- f )  2dup cr type ." in"
  \ 2over -trailing cr type ." ?" cr .s key drop search nip nip ;

: contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;

  \ doc{
  \
  \ contains ( ca1 len1 ca2 len2 -- f )
  \
  \ Does the string ca1 len1 contains the string ca2 len2?
  \
  \ }doc

variable default-first-locatable  variable first-locatable
variable last-locatable  blk/disk 1- last-locatable !
  \ Variables that define the range of blocks to be searched
  \ by `located` and its descendants.

: delimited  ( ca1 len1 -- ca2 len2 )
  dup 2+ dup allocate-string swap  ( ca1 len1 ca2 len2 )
  2dup blank  2dup 2>r drop char+ smove 2r>  ;

  \ doc{
  \
  \ delimited   ( ca1 len1 -- ca2 len2 )
  \
  \ Add a leading space and trailing space to the string _ca1
  \ len1_, returning the result _ca2 len2_ in the circular
  \ string buffer.
  \
  \ }doc

: located  ( ca len -- block | false )
  delimited  last-locatable @ 1+  first-locatable @
  default-first-locatable @  first-locatable !
  do  0 i line>string 2over
      contains if  2drop i unloop exit  then
      break-key? ?leave
  loop  2drop false  ;

  \ doc{
  \
  \ located  ( ca len -- block | false )
  \
  \ Locate the first block whose header contains the string _ca
  \ len_ (but surrounded by spaces), and return its number. If
  \ not found, return _false_.  The search is case-sensitive.
  \
  \ }doc

-->

( ?located locate from reneeded reneed )

: ?located  ( block | 0 -- )  dup 0= #-268 ?throw  ;

  \ XXX FIXME -- the word shown by the exception may have been
  \ overwritten in the circular string buffer.

  \ doc{
  \
  \ ?located ( f -- )
  \
  \ If f is zero, throw an exception -268.
  \
  \ }doc

: locate  ( "name" -- block | false )
  parse-name save-string located  ;

  \ doc{
  \
  \ locate  ( "name" -- block | false )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and return its number. If not
  \ found, return _false_.
  \ The search is case-sensitive.
  \
  \ }doc

: from  ( "name" -- )  locate ?located first-locatable !  ;

  \ doc{
  \
  \ from  ( "name" -- )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and set it the first one `located`
  \ will search from. If not found, throw an exception -268.
  \
  \ This word is intended to prevent undesired matches clashes
  \ during the execution of `need` and related words. "name" is
  \ supposed to be a conventional marker. Usage examples:

  \ ----
  \ ( x )
  \
  \ : x  ( -- )  ." Wrong x!" ;
  \
  \ ( use-x )
  \
  \ from ==data-structures== need x
  \
  \ ( y )  ==data-structures==
  \
  \ : y ." Y data structure; ;
  \
  \ ( x )
  \
  \ : x ." X data structure; ;
  \
  \ ----

  \ }doc

: reneeded  ( ca len -- )  located ?located load  ;

  \ doc{
  \
  \ reneeded  ( ca len -- )
  \
  \ Locate the first block whose header contains the string
  \ _ca len_ (surrounded by spaces), and load it. If not found,
  \ throw an exception -268.
  \
  \ }doc

: reneed  ( "name" -- )  parse-name save-string reneeded  ;

  \ doc{
  \
  \ reneed  ( ca len -- )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and load it.
  \
  \ }doc

-->

( needed-word [needed] [unneeded] needed need )

2variable needed-word

  \ XXX TODO -- make `[needed]` and `[unneeded]` optional.

: [needed]  ( "name" -- wf )
  parse-name needed-word 2@ 2dup or
  if  compare 0=  exit  then  2drop 2drop true   ; immediate

  \ doc{
  \
  \ [needed]  ( "name" -- wf )
  \
  \ Is "name" the needed word specified by the last execution
  \ of `need` or `needed`?
  \
  \ }doc

: [unneeded]  ( "name" -- wf )
  postpone [needed] 0=  ; immediate

  \ doc{
  \
  \ [unneeded]  ( "name" -- wf )
  \
  \ Is "name" different than the needed word specified by the
  \ last execution of `need` or `needed`?
  \
  \ }doc

: needed  ( ca len -- )
  needed-word 2@ 2>r
  -trailing -leading save-string 2dup needed-word 2!
  2dup undefined?
  if  reneeded  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ needed  ( ca len -- )
  \
  \ If the string _ca len_ is not the name of a word found in
  \ the current search order, locate the first block of the
  \ library where "name" is included in the block header
  \ (surrounded by spaces), and load it.
  \
  \ }doc

: need  ( "name" -- )  parse-name needed  ;

  \ doc{
  \
  \ need  ( "name" -- )
  \
  \ If "name" is not found in the current search order, locate
  \ the first block of the library where "name" is included is
  \ the block header (surrounded by spaces), and load it.
  \
  \ }doc

blk @ 1+ dup default-first-locatable !  first-locatable !

  \ vim: filetype=soloforth
  \ alias.alias.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ An implementation of `alias`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( alias )

: alias  ( xt "name" -- )  defer latest name> defer!  ;

  \ doc{
  \
  \ alias  ( xt "name" -- )
  \
  \ Create an alias _name_ that will execute _xt_.
  \
  \ Aliases don't inherit the precedence (set by `immediate`)
  \ and restricted (set by `compile-only`) attributes from the
  \ original word.
  \
  \ Aliases have their own execution token, different from the
  \ original _xt_.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ assembler.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Two versions of a Z80 assembler, called `z80-asm` (default)
  \ and `z80-asm,` (experimental), and some related words.

  \ -----------------------------------------------------------
  \ Authors

  \ The original assembler, for the 8080, was written by John
  \ Cassady, in 1980-1981, and published on Forth Dimensions
  \ (volume 3, number 6, page 180, 1982-03).
  \
  \ Coos Haak wrote an improved version for Z80 for his own ZX
  \ Spectrum Forth, in the middle 1980's.
  \
  \ Lennart Benschop included Coos Haak's assembler in his
  \ Spectrum Forth-83 (1988).
  \
  \ Marcos Cruz (programandala.net) adapted, modified and
  \ improved the Spectrum Forth-83 version for Solo Forth,
  \ 2015, 2016.

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( z80-asm, )

  \ XXX UNDER DEVELOPMENT -- Fork of `z80-asm`, with modified
  \ syntax.
  \
  \ 2015-12-25 First changes:
  \
  \ 1. "," suffixes in Z80 instructions;
  \ 2. one single set of conditions;
  \ 3. "a" and "r" prefixes in control structures;
  \ 4. condition "m" renamed to "ne".

  \ XXX TODO
  \
  \ - combine changes 2..4 with the previous version.
  \ - rename `|mark` and `|resolve`
  \ - remove all "retCOND" and "callCOND" and "jpCOND"
  \   (or make them optional
  \ - make absolute-jump control structures optional.
  \

  \ Z80 assembler for Solo Forth

  \ XXX TODO `get-order` here and `set-order` at the end.

only forth definitions

need ?pairs  need 3dup

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm,  ( -- )  assembler  ;

also assembler definitions hex

-->

( z80-asm, -- registers )

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?page  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;
  \ Branch too long?

-->

( z80-asm, -- defining words for z80 instructions)

: m1  ( 8b "name" -- )
  create c, does>  ( -- )  ( pfa ) c@ c,  ;
  \ 1-byte opcode without parameters.

: m2  ( 8b "name" -- )
  create c, does>  ( r -- )  ( r pfa ) c@ + c,  ;
  \ 1-byte opcode with register encoded in bits 0-3.

: m3  ( 8b "name" -- )
  create c, does>  ( r -- )  ( r pfa ) c@ swap 8* + c,  ;
  \ 1-byte opcode with register encoded in bits 3-5.

: m4  ( 8b "name" -- )
  create c, does>  ( 8b -- )  ( 8b pfa ) c@ c, c,  ;
  \ 1-byte opcode with 1-byte parameter.

: m5  ( 8b "name" -- )
  create c, does>  ( 16b -- )  ( 16b pfa ) c@ c, ,  ;
  \ 1-byte opcode with 2-byte parameter.

: m6  ( 8b "name" -- )
  create c, does>  ( r -- )  ( r pfa ) CB c, c@ + c,  ;
  \ Rotation of registers.

  -->

( z80-asm, -- defining words for z80 instructions)

: m7  ( 8b "name" -- )
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;
  \ Bit manipulation of registers.

: m8  ( 16b "name" -- )
  create , does>  ( -- )  ( pfa ) @ ,  ;
  \ 2-byte opcodes.

: m9  ( 8b "name" -- )
  create c, does>  ( a -- )
    ( a pfa )  c@ c, here 1+ - ?page c,  ;
  \ Relative jumps.

-->

( z80-asm, -- defining words for z80 instructions)

: ma  ( 8b "name" -- )
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;
  \ Index registers with register.

: mb  ( 8b "name" -- )
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;
  \ Rotation with index registers.

: mc  ( 8b "name" -- )
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;
  \ Bit manipulation with index registers.

-->

( z80-asm, -- opcodes)

  \ XXX FIXME ftap

00 m1 nop, 02 m3 stap, 03 m3 incp, 04 m3 inc, 05 m3 dec, 07 m1
rlca, 08 m1 exaf, 09 m3 addp, 0A m3 ftap, 0B m3 decp, 0F m1
rrca, 10 m9 djnz, 17 m1 rla, 18 m9 jr,  1F m1 rra, 20 m9 jrnz,
22 m5 sthl, 27 m1 daa, 28 m9 jrz, 2A m5 fthl, 2F m1 cpl, 30 m9
jrnc, 32 m5 sta, 37 m1 scf, 38 m9 jrc, 3A m5 fta, 3F m1 ccf, 76
m1 halt, 80 m2 add, 88 m2 adc, 90 m2 sub, 98 m2 sbc, B8 m2 cp,
C1 m3 pop, C2 m5 jpnz, C3 m5 jp, C5 m3 push, C6 m4 add#, C7 m2
rst, C9 m1 ret, CA m5 jpz, CD m5 call, CE m4 adc#, D2

-->

( z80-asm, -- opcodes)

m5 jpnc, D3 m4 out, 41 m3 outbc, D6 m4 sub#, D9 m1 exx, DA m5
jpc, DB m4 in, 40 m3 inbc, 0DE m4 sbc#, E2 m5 jppo, E3 m1
exsp, E6 m4 and#, E9 m1 jphl, EA m5 jppe, EB m1 exde, EE m4
xor#, F2 m5 jpp, F3 m1 di,  F6 m4 or#, F9 m1 ldsp, FA m5 jpm,
FB m1 ei, FE m4 cp#, 00 m6 rlc, 08 m6 rrc, 10 m6 rl, 18 m6
rr, 20 m6 sla,  28 m6 sra, 38 m6 srl,  40 m7 bit, 80 m7 res, C0
m7 set, B0ED m8 ldir, B8ED m8 lddr, 44ED m8 neg, 57ED m8 ldai,
47ED m8 ldia, 56ED m8 im1 5EED m8 im2 B1ED m8 cpir, 6FED m8
rld,

-->

( z80-asm, -- opcodes)

: jpix,  ( -- )  ix-op c, jphl,  ;
: ldp#,  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#,  ( 8b r -- )  8* 06 + c, c,  ;
: ld,  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp,  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp,  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp,  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp,  ( a rp -- )  ED c, 8* 4B + c, ,  ;

: addix,  ( rp -- )  ix-op c, addp,  ;
: addiy,  ( rp -- )  iy-op c, addp,  ;

  \ Macros

: clr,  ( rp -- )  0 swap ldp#,  ;
: ldp,  ( rp1 rp2 -- )  2dup ld, 1+ swap 1+ swap ld,  ;

  \ ZX Spectrum specific

CF m4 hook, \ rst 0x08
D7 m1 prt,  \ rst 0x16

-->

( z80-asm, -- index register opcodes)

86 ma addx, 8E ma adcx, 96 ma subx, 9E ma sbcx, A6 ma andx,
AE ma xorx, B6 ma orx,  BE ma cpx,  34 ma incx, 35 ma decx,
06 mb rlcx, 0E mb rrcx, 16 mb rlx,  1E mb rrx,  26 mb slax,
2E mb srax, 3E mb srlx, 46 mc bitx, 86 mc resx, C6 mc setx,

: ftx,   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx,   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x,  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx,  ( disp rpi rp -- )  3dup 1+ ftx, rot 1+ -rot ftx,  ;
: stpx,  ( disp rpi rp -- )  3dup 1+ stx, rot 1+ -rot stx,  ;

-->

( z80-asm, -- conditions)

  \ Conditions are Z80 opcodes for the required jump
  \ instruction.
  \
  \ Example: `z aif` compiles a `jp nz`, so `z` is the code for
  \ `jp nz`.
  \
  \ Control structures that compile relative jumps modify the
  \ opcode accordingly. Example: `z rif` compiles a `jr nz `

C2 constant z  CA constant nz D2 constant cy DA constant nc
E2 constant pe EA constant po F2 constant ne  FA constant p

  \ XXX FIXME condition `m` has been renamed to `ne` because of
  \ the register `m`; but maybe all registers should be
  \ renamed.
  \ XXX TODO ne->ns and p->ps

: jp>jr  ( op1 -- op2 )  dup nc > #-273 ?throw  A2 -  ;
  \ Convert an absolute-jump condition to a relative-jump
  \ condition.  Throw error #-273 if the condition is
  \ invalid.

-->

( z80-asm, -- conditional ret and call)

  \ Conditional ret

: ?ret,  ( op -- )  8 xor 2- c,  ;

: retc,  ( -- )  cy ?ret,  ;    : retnc,  ( -- )  nc ?ret,  ;
: retz,  ( -- )  z ?ret,  ;     : retnz,  ( -- )  nz ?ret,  ;
: retm,  ( -- )  ne ?ret,  ;     : retp,  ( -- )  p ?ret,  ;
: retpe,  ( -- )  pe ?ret,  ;   : retpo,  ( -- )  po ?ret,  ;

  \ Conditional call

: ?call,  ( a op -- )  8 xor 2+ c, ,  ;

: callc,  ( -- )  cy ?call, ;
: callnc,  ( -- )  nc ?call,  ;
: callz,  ( -- )  z ?call, ;
: callnz,  ( -- )  nz ?call,  ;
: callm,  ( -- )  ne ?call, ;
: callp,  ( -- )  p ?call,  ;
: callpe,  ( -- )  pe ?call, ;
: callpo, ( -- )  po ?call,  ;

-->

( z80-asm, -- control structures with relative jumps)

  \ XXX TODO document

: >relmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.

: relresolve  ( orig dest -- )  1- over - ?page swap c!  ;
  \ Resolve a relative branch.

: >relresolve  ( orig -- )  here relresolve  ;
  \ Resolve a forward relative branch.

: <relresolve  ( dest -- )  here 1- swap relresolve  ;
  \ Resolve a backward relative branch.

-->

( z80-asm, -- control structures with relative jumps)

: ahead  ( -- orig  )  18 , >relmark  ;
  \ Create a relative branch forward.
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.
  \ Note: 0x18 is the Z80 opcode for `jr`.

: rif  ( op -- orig cs-id )  jp>jr , >relmark 0A  ;

: rthen  ( orig cs-id -- )  0A ?pairs >relresolve  ;

: relse  ( orig cs-id -- cs-id ) \ XXX TODO document
  0A ?pairs 18 rif rot swap rthen 0A  ;
  \ Note 0x18 is the opcode of `jr`.

: rbegin  (  -- dest cs-id )  <mark 0B  ;

: rwhile  (  op -- orig cs-id )  jp>jr rif 2+  ;

: runtil  (  dest cs-id op -- )  , 0B ?pairs <relresolve  ;
  \ compile a relative conditional jump

: ragain  (  dest cs-id -- )  18 runtil  ;
  \ compile `jr`

: rrepeat  (  dest cs-id1 orig cs-id2 )
  2swap ragain 2- rthen  ;

: rstep    ( dest cs-id -- )  10 runtil  ;  -->
  \ compile `djnz`

( z80-asm, -- control structures with absolute jumps)

  \ XXX TODO document

: aif  (  op -- orig cs-id )  c, >mark 08  ;

: athen  (  orig cs-id -- )  08 ?pairs >resolve  ;

: aelse  (  cs-id -- cs-id )
  08 ?pairs C3 aif rot swap athen 08  ;
  \ C3 = opcode of `jp`

: abegin  (  -- dest cs-id )  <mark 09  ;

: awhile  (  op -- orig cs-id )  aif 2+  ;

: auntil  (  cs-id op -- )  c, 09 ?pairs <resolve  ;
  \ Compile an absolute conditional jump.

: aagain  (  cs-id -- )  C3 auntil  ;
  \ Compile an absolute jump.

: arepeat  (  dest cs-id1 orig cs-id2 )
  2swap aagain 2- athen  ;

: |mark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: |resolve  ( a -- )  |mark swap !  ;
  \ Resolve an absolute forward reference.

-->

( z80-asm, -- last opcodes and macros)

  \ `and`, `or` and `xor` are defined at the end, in order to
  \ avoid name clashes with the Forth words that have the same
  \ name:

A0 m2 and,  B0 m2 or,  A8 m2 xor,

  \ Macro, 16-bit subtract:
: subp,  ( rp -- )  a and sbcp,  ;

  \ Macro to test 16-bit register for zero:
: tstp,  ( rp -- )  dup a ld, 1+ or,  ;

-->

( z80-asm, -- unresolved macro endm )

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the stack check at the end of
  \ the definition.

only forth definitions also assembler

: macro  ( "name" -- )  : asm  ;
: endm  ( -- )  end-asm postpone ;  ;  immediate

decimal only forth

( z80-asm )

\ Z80 assembler for Solo Forth

  \ XXX NOTE: first version

  \ XXX TODO `get-order` here and `set-order` at the end.

only forth definitions

need ?pairs  need 3dup

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm  ( -- )  assembler  ;

also assembler definitions hex

-->

( z80-asm -- registers )

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?page  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;
  \ Branch too long?

-->

( z80-asm -- defining words for z80 instructions)

: m1  ( 8b "name" -- )
  \ 1-byte opcode without parameters.
  create c, does>  ( -- )  ( pfa ) c@ c,  ;

: m2  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 0-3.
  create c, does>  ( r -- )  ( r pfa ) c@ + c,  ;

: m3  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 3-5.
  create c, does>  ( r -- )  ( r pfa ) c@ swap 8* + c,  ;

: m4  ( 8b "name" -- )
  \ 1-byte opcode with 1-byte parameter.
  create c, does>  ( 8b -- )  ( 8b pfa ) c@ c, c,  ;

: m5  ( 8b "name" -- )
  \ 1-byte opcode with 2-byte parameter.
  create c, does>  ( 16b -- )  ( 16b pfa ) c@ c, ,  ;

: m6  ( 8b "name" -- )
  \ Rotation of registers.
  create c, does>  ( r -- )  ( r pfa ) CB c, c@ + c,  ;

  -->

( z80-asm -- defining words for z80 instructions)

: m7  ( 8b "name" -- )
  \ Bit manipulation of registers.
  \ XXX OLD
  \ create c, does>  ( bit r -- )
  \  ( bit r pfa ) CB c, c@ + swap 8* + c,  ;
  \ XXX NEW
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;

: m8  ( 16b "name" -- )
  \ 2-byte opcodes.
  create , does>  ( -- )  ( pfa ) @ ,  ;

: m9  ( 8b "name" -- )
  \ Relative jumps.
  create c, does>  ( a -- )
    ( a pfa )  c@ c, here 1+ - ?page c,  ;

-->

( z80-asm -- defining words for z80 instructions)

: ma  ( 8b "name" -- )
  \ Index registers with register.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;

: mb  ( 8b "name" -- )
  \ Rotation with index registers.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;

: mc  ( 8b "name" -- )
  \ Bit manipulation with index registers.
  \ XXX OLD
  \  create c, does>  ( bit rphl disp -- )
  \   ( bit rphl disp pfa ) CB c, rot drop c@ -rot c, 8* + c,  ;
  \ XXX NEW
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;

-->

( z80-asm -- opcodes)

  \ XXX FIXME ftap

00 m1 nop 02 m3 stap 03 m3 incp 04 m3 inc 05 m3 dec 07 m1 rlca
08 m1 exaf 09 m3 addp 0A m3 ftap 0B m3 decp 0F m1 rrca 10 m9
djnz 17 m1 rla 18 m9 jr  1F m1 rra 20 m9 jrnz 22 m5 sthl 27 m1
daa 28 m9 jrz 2A m5 fthl 2F m1 cpl 30 m9 jrnc 32 m5 sta 37 m1
scf 38 m9 jrc 3A m5 fta 3F m1 ccf 76 m1 halt 80 m2 add 88 m2
adc 90 m2 sub 98 m2 sbc B8 m2 cp C1 m3 pop C2 m5 jpnz C3 m5 jp
C5 m3 push C6 m4 add# C7 m2 rst C9 m1 ret CA m5 jpz CD m5 call
CE m4 adc# D2 m5 jpnc D3 m4 out 41 m3 outbc D6 m4 sub# D9 m1
exx DA m5 jpc DB m4 in 40 m3 inbc 0DE m4 sbc# E2 m5 jppo E3 m1
exsp E6 m4 and# E9 m1 jphl EA m5 jppe EB m1 exde EE m4 xor# F2
m5 jpp F3 m1 di  F6 m4 or# F9 m1 ldsp FA m5 jpm FB m1 ei FE m4
cp# 00 m6 rlc 08 m6 rrc 10 m6 rl 18 m6 rr 20 m6 sla  28 m6 sra
38 m6 srl  40 m7 bit 80 m7 res C0 m7 set B0ED m8 ldir B8ED m8
lddr 44ED m8 neg 57ED m8 ldai 47ED m8 ldia 56ED m8 im1 5EED m8
im2 B1ED m8 cpir 6FED m8 rld -->

( z80-asm -- opcodes)

: 0outbc  ( -- )  ED c, 71 c,  ;
: jpix  ( -- )  ix-op c, jphl  ;
: ldp#  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#  ( 8b r -- )  8* 06 + c, c,  ;
: ld  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp  ( a rp -- )  ED c, 8* 4B + c, ,  ;

: addix  ( rp -- )  ix-op c, addp  ;
: addiy  ( rp -- )  iy-op c, addp  ;

  \ Macros

: clr  ( rp -- )  0 swap ldp#  ;
: ldp  ( rp1 rp2 -- )  2dup ld 1+ swap 1+ swap ld  ;

  \ ZX Spectrum specific

CF m4 hook       \ rst 0x08
D7 m1 prt  -->   \ rst 0x16

( z80-asm -- index register opcodes)

86 ma addx 8E ma adcx 96 ma subx 9E ma sbcx A6 ma andx
AE ma xorx B6 ma orx  BE ma cpx  34 ma incx 35 ma decx
06 mb rlcx 0E mb rrcx 16 mb rlx  1E mb rrx  26 mb slax
2E mb srax 3E mb srlx 46 mc bitx 86 mc resx C6 mc setx

: ftx   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx  ( disp rpi rp -- )  3dup 1+ ftx rot 1+ -rot ftx  ;
: stpx  ( disp rpi rp -- )  3dup 1+ stx rot 1+ -rot stx  ;

-->

( z80-asm -- conditional ret and call)

  \ Condition codes for relative jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z if` compiles a `jr nz`, so `z` is the code for
  \ `jr nz`.

20 constant z  28 constant nz  30 constant cy  38 constant nc

  \ Condition codes for absolute jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z' if` compiles a `jp nz`, so `z'` is the code for
  \ `jp nz`.

C2 constant z'  CA constant nz' D2 constant cy' DA constant nc'
E2 constant pe' EA constant po' F2 constant m'  FA constant p'

  \ Conditional ret

: ?ret  ( op -- )  8 xor 2- c,  ;

: retc  ( -- )  cy' ?ret ;    : retnc  ( -- )  nc' ?ret  ;
: retz  ( -- )  z' ?ret ;     : retnz  ( -- )  nz' ?ret  ;
: retm  ( -- )  m' ?ret ;     : retp  ( -- )  p' ?ret  ;
: retpe  ( -- )  pe' ?ret ;   : retpo  ( -- )  po' ?ret  ;

  \ Conditional call

: ?call  ( a op -- )  8 xor 2+ c, ,  ;

: callc  ( -- )  cy' ?call ;    : callnc  ( -- )  nc' ?call  ;
: callz  ( -- )  z' ?call ;     : callnz  ( -- )  nz' ?call  ;
: callm  ( -- )  m' ?call ;     : callp  ( -- )  p' ?call  ;
: callpe  ( -- )  pe' ?call ;   : callpo ( -- )  po' ?call  ;

-->

( z80-asm -- control structures with relative jumps)

  \ XXX TODO document

: >relmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.

: relresolve  ( orig dest -- )  1- over - ?page swap c!  ;
  \ Resolve a relative branch.

: >relresolve  ( orig -- )  here relresolve  ;
  \ Resolve a forward relative branch.

: <relresolve  ( dest -- )  here 1- swap relresolve  ;
  \ Resolve a backward relative branch.

: ahead  ( -- orig  )  18 , >relmark  ;
  \ Create a relative branch forward.
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.
  \ Note: 0x18 is the Z80 opcode for `jr`.

: if  ( op -- orig cs-id )  , >relmark 0A  ;

: then  ( orig cs-id -- )  0A ?pairs >relresolve  ;

: else  ( orig cs-id -- cs-id ) \ XXX TODO document
  0A ?pairs 18 if rot swap then 0A  ;
  \ Note 0x18 is the opcode of `jr`.

: begin  (  -- dest cs-id )  <mark 0B  ;

: while  (  op -- orig cs-id )  if 2+  ;

: until  (  dest cs-id op -- )  , 0B ?pairs <relresolve  ;
  \ compile a relative conditional jump

: again  (  dest cs-id -- )  18 until  ;
  \ compile `jr`

: repeat  (  dest cs-id1 orig cs-id2 )  2swap again 2- then  ;

: step    ( dest cs-id -- )  10 until  ;  -->
  \ compile `djnz`

( z80-asm -- control structures with absolute jumps)

  \ XXX TODO document

: if'  (  op -- orig cs-id )  c, >mark 08  ;

: then'  (  orig cs-id -- )  08 ?pairs >resolve  ;

: else'  (  cs-id -- cs-id )
  08 ?pairs C3 if' rot swap then' 08  ;
  \ C3 = opcode of `jp`

: begin'  (  -- dest cs-id )  <mark 09  ;

: while'  (  op -- orig cs-id )  if' 2+  ;

: until'  (  cs-id op -- )  c, 09 ?pairs <resolve  ;

: again'  (  cs-id -- )  C3 until'  ;

: repeat'  (  dest cs-id1 orig cs-id2 )
  2swap again' 2- then'  ;

: |mark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: |resolve  ( a -- )  |mark swap !  ;
  \ Resolve an absolute forward reference.

-->

( z80-asm -- last opcodes and macros)

  \ `and`, `or` and `xor` are defined at the end, in order to
  \ avoid name clashes with the Forth words that have the same
  \ name:

A0 m2 and  B0 m2 or  A8 m2 xor

  \ Macro, 16-bit subtract:
: subp  ( rp -- )  a and sbcp  ;

  \ Macro to test 16-bit register for zero:
: tstp  ( rp -- )  dup a ld 1+ or  ;

  \ ; jpnext ( -- )  jpix  ; \ XXX OLD

-->

( z80-asm -- unresolved macro endm )

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the stack check at the end of
  \ the definition.

only forth definitions also assembler

: macro  ( "name" -- )  : asm  ;
: endm  ( -- )  end-asm postpone ;  ;  immediate

decimal only forth

( calc end-calc )

need z80-asm

  \ current @  also assembler definitions
  \ XXX OLD
  \ XXX TODO

macro calc  ( -- )  exx EF c,  endm
  \ 0xEF = `rst 0x28`, call the ROM calculator

macro end-calc  ( -- )  38 c, exx  next ix ldp  endm
  \ 0x38 = ROM calculator `end-calc` command
  \
  \ XXX TODO It seems IX is not used by the calculator,
  \ so this code will work:
  \ macro end-calc  ( -- )  38 c, exx  endm

  \ current !  previous
  \ XXX OLD
  \ XXX TODO

( << >> )

  \ For dumping assembled code to screen.

  \ Credit:
  \
  \ Code adapted from Pygmy Forth.

  \ XXX TODO finish adapt

need @c+  need for

: <<  ( -- a depth )  here depth  ;
: >>  ( a depth -- )
  depth 1- - #-258 ?throw cr base @ >r hex
  dup 4 u.r space  here over - for  c@+ 3 u.r  step drop
  r> base !  space   ;

( execute-hl call-xt )

  \ Assembler macros to call any Forth word from code words.

  \ Credit:
  \
  \ Code inspired by Spectrum Forth-83, where similar code is
  \ embedded in `KEY` and `PAUSE` to call an xt hold in a
  \ variable.  The code was factored to two assembler macros in
  \ order to make it reusable.

macro execute-hl  ( -- )
  here 6 + bc ldp#  \ point IP to phony_compiled_word
  jphl          \ execute the xt in HL
  \ phony_compiled_word:
  here cell+ ,      \ point to the phony xt following
  endm
  \ Compile an `execute` with the xt hold in HL.

macro call-xt  ( xt -- )
  hl ldp#  execute-hl
  endm
  \ Compile a call to _xt_.
  \ This is the low-level equivalent of `execute`.

  \ vim: filetype=soloforth
  \ benchmarking.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Generic benchmarking tools.
  \
  \ Specific benchmarks written during the development of Solo
  \ Forth, in order to choose between different implementation
  \ options, are in the file <development_benchmarks.fsb>.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( bench{ }bench }bench. bench. benched )

  \ Credit:
  \
  \ Code adapted from Forth Dimensions (volume 17, number 4
  \ page 11, 1995-11).

  \ System-dependent timing routines.

need reset-frames  need frames@

: bench{  ( -- )  reset-frames  ;
  \ start timing

: }bench  ( -- d )  frames@ ;
  \ stop timing

: bench.  ( d -- )
  2dup d. ." frames (" 50 m/ nip . ." s) "  ;
  \ print the result _d_

: }bench.  ( -- )  frames@ bench.  ;
  \ stop timing and print the result

: benched  ( xt n -- d )
  bench{ 0 do  dup execute  loop  }bench rot drop  ;

: benched.  ( xt n -- )
  bench{ 0 do  dup execute  loop  }bench. drop  ;

( all-benchmarks )

  \ Credit:
  \
  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

need byte-magazine-benchmark
need interface-age-benchmark
need vector-loop-benchmark

: all-benchmarks  ( n1 n2 -- )
  byte-magazine-benchmark
  interface-age-benchmark
  vector-loop-benchmark  ;

  \  <------------------------------>
  .( To run all benchmarks type:) cr
  .(   n1 n2 all-benchmarks) cr

  \ vim: filetype=soloforth
  \ blocks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to disk blocks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( ?--> )

: ?-->  ( f -- )  if  postpone -->  then  ; immediate

  \ doc{
  \
  \ ?-->  ( f -- )
  \
  \ If _f_ is not false, continue interpretation on the next
  \ sequential block.  parse area. This word is used for
  \ conditional compilation.
  \
  \ }doc


  \ XXX TMP -- `?\` is still in the kernel

  \ : ?\  ( f "ccc<eol>" -- )  if  postpone \  then  ; immediate

  \ doc{
  \
  \ ?\  ( f "ccc" -- )
  \
  \ If _f_ is not false, parse and discard the rest of the
  \ parse area. This word is used for conditional compilation.
  \
  \ }doc

( update flush thru )

[unneeded] update
?\ : update  ( -- )  disk-buffer @ $8000 or disk-buffer !  ;

  \ doc{
  \
  \ update  ( -- )
  \
  \ Mark the current block buffer as modified.  The block will
  \ subsequently be transferred automatically to disk should
  \ its buffer be required for storage of a different block, or
  \ upon execution of `flush` or `save-buffers`.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (BLOCK),
  \ Forth-2012 (BLOCK).
  \
  \ }doc

[unneeded] flush
?\ : flush  ( -- )  save-buffers empty-buffers  ;

  \ doc{
  \
  \ flush  ( -- )
  \
  \ Perform the function of `save-buffers`, then unassign all
  \ block buffers.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (BLOCK),
  \ Forth-2012 (BLOCK).
  \
  \ }doc

[unneeded] thru
?\ : thru  ( block1 block2 -- )  1+ swap ?do  i load  loop  ;
  \ XXX FIXME -- when block1>block2

  \ doc{
  \
  \ thru ( block1 block2 -- )
  \
  \ Load consecutively the blocks from _block1_ through
  \ _block2_.
  \
  \ Origin: Forth-79 (Reference Word Set), Forth-83
  \ (Controlled Reference Words), Forth-94 (BLOCK EXT),
  \ Forth-2012 (BLOCK EXT).
  \
  \ }doc

( continued ?load reload loads +load +thru loader )

[unneeded] continued
?\ : continued  ( u -- )  ?loading (load)  ;

  \ doc{
  \
  \ continued  ( u -- )
  \
  \ Continue interpretation at block _u_.
  \
  \ Origin: Forth-79 (Reference Word Set), Forth-83 (Appendix
  \ B. Uncontrolled Reference Words).
  \
  \ }doc

[unneeded] ?load
?\ : ?load  ( block f -- )  if  dup load  then  drop  ;

  \ Credit:
  \
  \ Code from Pygmy Forth.
  \
  \ doc{
  \
  \ ?load  ( block f -- )
  \
  \ Load block _block_ if flag _f_ is true, else do nothing.
  \
  \ }doc

[unneeded] reload
?\ : reload  ( -- )  empty-buffers  scr @ load  ;

  \ doc{
  \
  \ reload  ( -- )
  \
  \ Load the most recently loader or listed block.
  \
  \ }doc

[unneeded] loads
?\ : loads  ( block n -- )  bounds ?do  i load  loop  ;

  \ Credit:
  \
  \ Word from MMSFORTH.

  \ doc{
  \
  \ loads  ( block n -- )
  \
  \ Load _n_ blocks starting from block _block_.
  \
  \ }doc

[unneeded] +load  [unneeded] +thru  and
?\ : +load  ( n -- )  blk @ + load  ;

[unneeded] +thru
?\ : +thru  ( n1 n2 -- )  1+ swap do  i +load  loop  ;


[unneeded] loader ?exit

: loader  ( block "name" -- )
  create ,  does>  ( pfa )  @ load  ;

  \ doc{
  \
  \ loader  ( block "name" -- )
  \
  \ Define a word "name" which, when executed, will  load block
  \ _block_.
  \
  \ Origin: `loads`, found on Forth-79 (Reference Word Set) and
  \ Forth-83 (Appendix B. Uncontrolled Reference Words).
  \
  \ }doc

( .line )

: .line  ( n1 n2 -- )  line>string -trailing type  ;

  \ doc{
  \
  \ .line  ( n1 n2 -- )
  \
  \ Print line _n1_ from block _n2_, without trailing spaces.
  \
  \ Origin: fig-Forth.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ compilation.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to compilation.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( [false] [true] )

         0 constant [false] immediate
[false] 0= constant [true]  immediate

( [if] [else] [then] )

need s=

: [else]  ( "..." -- )

  \ 1 begin   parse-name 2dup swap c@ and \ XXX OLD
  1 begin   parse-name dup
    while   2dup s" [if]" s=
            if    2drop 1+
            else  2dup s" [else]" s=
                  if    2drop 1- dup if  1+  then
                  else  s" [then]" s= if  1-  then
                  then
            then  ?dup 0= if  exit  then
  repeat  2drop drop  ; immediate

: [if]  ( "..." -- )  0= if postpone [else] then  ; immediate

: [then]  ( -- )  ; immediate

( body>name name>body link>name name>link >>link name<name )

[unneeded] body>name
?\ : body>name  ( pfa -- nt ) body> >name  ;

[unneeded] name>body
?\ : name>body  ( nt -- pfa ) name> >body  ;

[unneeded] link>name dup  ?\ need alias
?\ ' cell+ alias link>name  ( nt -- pfa )

[unneeded] name>link dup  ?\ need alias
?\ ' cell- alias name>link  ( nt -- pfa )

[unneeded] >>link dup  ?\ need alias
?\ ' cell+ alias >>link  ( xtp -- lfa )

[unneeded] name<name dup  ?\ need name>link
?\ : name<name  ( nt1 -- nt2 )  name>link @s  ;
  \ Get the previous _nt2_ from _nt1_.

( name>interpret name>compile )

  \ XXX UNDER DEVELOPMENT

: name>interpret  ( nt -- xt | 0 )
  ;

  \ doc{
  \
  \ name>interpret  ( nt -- xt | 0 )
  \
  \ Return a _xt_ that represents the interpretation semantics
  \ of the word _nt_. If _nt_ has no interpretation
  \ semantics, return zero.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

: name>compile  ( nt -- x xt )
  ;

  \ doc{
  \
  \ name>compile  ( nt -- x xt )
  \
  \ Return _x xt_ that represents the compilation semantics
  \ of the word _nt_. The  returned _xt_ has the stack
  \ effect ( i*x  x -- j*x  ).  Executing _xt_ consumes
  \ _x_ and performs the compilation semantics of the word
  \ represented by _nt_.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

( smudge smudged )

need c!toggle-bits

: smudged  ( nt -- )
  smudge-mask swap system-bank c!toggle-bits default-bank  ;

  \ doc{
  \
  \ smudged  ( nt -- )
  \
  \ Toggle the "smudge bit" of the given _nt_.
  \
  \ This word is obsolete. `hided` and `revealed` are used
  \ instead.
  \
  \ }doc

 : smudge  ( -- )  latest smudged  ;

  \ doc{
  \
  \ smudge  ( -- )
  \
  \ Toggle the "smudge bit" of the latest definition's name
  \ field.  This prevents an uncompleted definition from being
  \ found during dictionary searches, until compiling is
  \ completed without error.
  \
  \ This word is obsolete. `hide` and `reveal` are used
  \ instead.
  \
  \ Origin: fig-Forth.
  \
  \ }doc

( ?pairs )

: ?pairs  ( x1 x2 -- )  <> #-22 ?throw  ;
  \ If _x1_ not equals _x2_ throw an error -22 (control
  \ structure mismatch).

( save-here restore-here )

variable here-backup
: save-here  ( -- )  here here-backup !  ;
: restore-here  ( -- )  here-backup there  ;


  \ vim: filetype=soloforth
  \ flow.case.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Several implementations of the standard
  \ `case` and some variants of `of`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( case )

  \ Credit:
  \
  \ Code adapted and modified from eForth.

  \ This version uses 48 bytes.

0 constant case  immediate compile-only

: of
  \ Compilation: ( -- orig )
  \ Run-time: ( x1 x2 -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate compile-only

: endof  ( orig1 -- orig2 )
  postpone else  ; immediate compile-only

: endcase
  ( Compilation: 0 orig1..orign -- )
  ( Run-time: x -- )
  postpone drop  begin  ?dup  while  [compile] then  repeat
  ; immediate compile-only

( case )  \ eforth-case )

  \ Credit:
  \
  \ Code adapted and modified from eForth.

  \ This version uses 54 bytes.

0 constant case  immediate compile-only

: of
  \ Compilation: ( -- orig )
  \ Run-time: ( x1 x2 -- )
  postpone over postpone = postpone if  postpone drop
  ; immediate compile-only

: endof  ( orig1 -- orig2 )
  postpone else  ; immediate compile-only

: (endcase) ( 0 orig1..orign -- )
  begin  ?dup  while  [compile] then  repeat  ;

: endcase
  ( Compilation: 0 orig1..orign -- )
  ( Run-time: x -- )
  postpone drop (endcase)  ; immediate compile-only

( case )  \ 94-doc-case )

  \ Credit:
  \
  \ Code copied from the example provided in the Forth-94
  \ documentation.

  \ This version uses 54 bytes.

0 constant case  immediate compile-only
  \ init count of ofs

: of
  \ Compilation: ( #of -- orig #of+1 )
  \ Run-time: ( x1 x2 -- )
  1+ >r
  postpone over  postpone =   \ copy and test case value
  postpone if                 \ add orig to control flow stack
  postpone drop               \ discards case value if =
  r>  ; immediate compile-only

: endof
  \ Compilation: ( orig1 #of -- orig2 #of )
  \ Run-time: ( -- )
  >r  postpone else  r>  ; immediate compile-only

: endcase
  \ Compilation:  ( orig1..orign #of -- )
  \ Run-time: ( x -- )
  postpone drop  \ discard case value
  0 ?do  postpone then  loop  ; immediate compile-only

( case )  \ abersoft-case )

  \ Credit:
  \
  \ This is the `case` provided by Abersoft Forth,
  \ translated from the Z80 disassembly, modified (compiler
  \ security has been removed) and commented.

  \ This version uses 64 bytes.

: case
  \ Compilation: ( -- a )
  \ Runtime: ( x -- )
  csp @ !csp  ; immediate compile-only

: of
  \ Compilation: ( -- )
  \ Run-time: ( x -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate compile-only

: endof
  \ Compilation: ( -- )
  \ Run-time: ( -- )
  postpone else  ; immediate compile-only

: endcase
  \ Compilation: ( a orig1..orign -- )
  \ Run-time: ( x -- )
  postpone drop
  begin  sp@ csp @ <>  while  postpone then  repeat
  csp !  ;  immediate

( between-of )

  \ Credit:
  \
  \ Code from Galope.

need between

: (between-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup 2r> between 0= if  invert  then  ;

: between-of  ( Compilation: -- of-sys )
              ( Run-time: x1 x2 x3 -- | x1 )
  postpone (between-of) postpone of  ;  immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 5 between-of  ." between two and five"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( less-of )

  \ Credit:
  \
  \ Code from Galope.

[defined] nup ?\ : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;

: (less-of)  ( x1 x2 -- x1 x1 | x1 x1' )
  nup nup >= if  invert  then  ;

: less-of  ( Compilation: -- of-sys )
           ( Run-time: x1 x2 -- | x1 )
  postpone (less-of) postpone of  ;  immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     10 of  ." ten!"  endof
  \     15 less-of  ." less than 15"  endof
  \     ." greater than 14"
  \   endcase  ;

( greater-of )

  \ Credit:
  \
  \ Code from Galope.

[defined] nup ?\ : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;

: (greater-of)  ( x1 x2 -- x1 x1 | x1 x1' )
  nup nup <= if  invert  then  ;

: greater-of  ( Compilation: -- of-sys )
              ( Run-time: x1 x2 -- | x1 )
  postpone (greater-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     10 of  ." ten!"  endof
  \     15 greater-of  ." greater than 15"  endof
  \     ." less than 10 or 11..15"
  \   endcase  ;

( within-of )

  \ Credit:
  \
  \ Code from Galope.

need within

: (within-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup 2r> within 0= if  invert  then  ;

: within-of  ( Compilation: -- of-sys )
             ( Run-time: x1 x2 x3 -- | x1 )
  postpone (within-of) postpone of  ; immediate compile-only

  \ XXX TODO confirm the ranges in the example:

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 5 within-of  ." within two and five"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( any-of )

need any?

: (any-of)  ( x0 x1..xn n -- x0 x0 | x0 0 )
  dup 1+ pick >r any? r> tuck and  ;

: any-of  ( Compilation: -- of-sys )
          ( Run-time: x0 x1..xn n -- | x0 )
  postpone (any-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( n -- )
  \   case
  \     1 of  ." one"  endof
  \     2 7 10 3 any-of  ." two, seven or ten"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( default-of )

  \ Credit:
  \
  \ Code from Galope.  Originally based on code by Mark Willis
  \ posted to <lang.comp.forth>:
  \ Message-ID:
  \ <64b90787-344c-4ee0-a0e4-4e2c12b3dec3@googlegroups.com>
  \ Date: Fri, 24 Jan 2014 02:08:22 -0800 (PST)

: default-of  ( -- )
  postpone dup postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 of  ." two"  endof
  \     default-of  ." other"  endof
  \   endcase  ;

( or-of )

  \ Credit:
  \
  \ Code from Galope.

: (or-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup dup r> = swap r> = or 0= if  invert  then  ;

: or-of  ( Compilation: -- of-sys )
         ( Run-time: x1 x2 x3 -- | x1 )
  postpone (or-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 3 or-of  ." two or three"  endof
  \     4 of  ." four"  endof
  \   endcase  ;

  \ vim: filetype=soloforth
  \ data_stack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that manipulate the data stack.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( 2nip )  \ ==datastack==

  \ Credit:
  \
  \ Code from Afera; original code from DZX-Forth.

code 2nip  ( x1 x2 x3 x4 -- x3 x4 )

  E1 c,            \ pop hl
  D1 c,            \ pop de
  F1 c,            \ pop af
  F1 c,            \ pop af
  C3 c, pushhlde , \ jp pushhlde

  end-code

  \ doc{
  \
  \ 2nip  ( x1 x2 x3 x4 -- x3 x4 )
  \
  \ }doc

( roll )

  \ doc{
  \
  \ roll  ( xu xn .. x0 u -- xn .. x0 xu )
  \
  \ }doc

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

need z80-asm

code roll  ( xu xn .. x0 u -- xn .. x0 xu )

  hl pop  hl addp  hl de ldp  sp addp
    \ pop hl
    \ add hl,hl
    \ ld e,l
    \ ld d,h
    \ add hl,sp

  bc push  m c ld  hl incp  m b ld
    \ push bc
    \ ld c,(hl)
    \ inc hl
    \ ld b,(hl)

  bc push  de bc ldp  hl de ldp
    \ push bc
    \ ld b,d
    \ ld c,e
    \ ld d,h
    \ ld e,l

  bc tstp
    \ ld a,b
    \ or c

  0000 jpz |mark 0 unresolved !
    \ jp z,roll.end

  hl decp  hl decp  lddr
    \ dec hl
    \ dec hl
    \ lddr

    \ roll.end:
  0 unresolved @ >resolve
  hl pop  bc pop  exsp
    \ pop hl
    \ pop bc
    \ ex (sp),hl

  jpnext

  end-code

( 3drop 4drop )

code 3drop  ( x1 x2 x3 -- )
  E1 c,  E1 c,  E1 c,
    \ pop hl
    \ pop hl
    \ pop hl
  jpnext  end-code

  \ doc{
  \
  \ 3drop  ( x1 x2 x3 -- )
  \
  \ }doc

code 4drop  ( x1 x2 x3 x4 -- )
  E1 c,  E1 c,  E1 c,  E1 c,
    \ pop hl
    \ pop hl
    \ pop hl
    \ pop hl
  jpnext  end-code

  \ doc{
  \
  \ 4drop  ( x1 x2 x3 x4 -- )
  \
  \ }doc

( 3dup )

code 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )
  D9 c,
    \ exx
  C1 c,  D1 c,  E1 c,
    \ pop bc
    \ pop de
    \ pop hl
  E5 c,  D5 c,  C5 c,
    \ push hl
    \ push de
    \ push bc
  E5 c,  D5 c,  C5 c,
    \ push hl
    \ push de
    \ push bc
  D9 c,
    \ exx
  jpnext  end-code

  \ doc{
  \
  \ 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )
  \
  \ }doc

exit  \ slower and smaller version:

: 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )  dup 2over rot  ;

( 2rot )

need roll

: 2rot  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
  5 roll 5 roll  ;

  \ doc{
  \
  \ 2rot  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
  \
  \ }doc

( swapped )

  \ Credit:
  \
  \ Adapted from code written by Sam Suan Chen, published
  \ on Forth Dimensions (volume 6, number 6, page 9, 1985-03).

: swapped  ( i*x n1 n2 -- j*x )
  >r 1+ cells sp@ +     ( i*x a1 ) ( R: n2 )
  r> 2+ cells sp@ +     ( i*x a1 a2 )
  over @ over @         ( i*x a1 a2 x1 x2 )
  >r swap !  r> swap !  ;

  \ Usage example:
  \
  \   ( 1 2 3 4 5 )  1 4 swapped  ( 4 2 3 1 5 )

  \ Original code by Sam Suan Chen,
  \ with an equivalent usage example:

  \ : xyswap  ( i*x n -- j*x )
  \   16 /mod >r dup + sp@ + sp@ r> dup + +
  \   over @ over @
  \   >r swap !  r> swap !  ;
  \
  \   ( 1 2 3 4 5 )  $25 xyswap  ( 4 2 3 1 5 )

( nup drup dip )

code nup  ( x1 x2 -- x1 x1 x2 )
  E1 c,  D1 c,  D5 c,  C3 c, pushhlde ,
    \ pop hl
    \ pop de
    \ push de
    \ jp pushhlde
  end-code
  \ Also called `under`.

  \ doc{
  \
  \ nup  ( x1 x2 -- x1 x1 x2 )
  \
  \ }doc

code drup  ( x1 x2 -- x1 x1 )
  D1 c,  E1 c,  E5 c,  E5 c,  jpnext
    \ pop de
    \ pop hl
    \ push hl
    \ push hl
    \ jp next
  end-code

  \ doc{
  \
  \ drup  ( x1 x2 -- x1 x1 )
  \
  \ }doc

code dip  ( x1 x2 -- x2 x2 )
  E1 c, D1 c, E5 c, E5 c,  jpnext
    \ pop hl
    \ pop de
    \ push hl
    \ push hl
    \ jp next
  end-code

  \ doc{
  \
  \ dip  ( x1 x2 -- x2 x2 )
  \
  \ }doc

( 0dup -dup )

code 0dup  ( x -- x | 0 0 )
  E1 c,  78 04 + c,  B0 05 + c,
    \ pop hl
    \ ld a,h
    \ or l
  C2 c, pushhl ,  E5 c,  jppushhl
    \ jp z,push_hl
    \ push hl
    \ jp push_hl
  end-code

  \ doc{
  \
  \ 0dup  ( x -- x | 0 0 )
  \
  \ Duplicate _x_ if it's zero.
  \
  \ }doc

code -dup  ( x -- x | 0 0 )
  E1 c,  CB c, 7C c,
    \ pop hl
    \ bit 7,h ; negative?
  C2 c, pushhl ,  E5 c,  jppushhl
    \ jp z,push_hl
    \ push hl
    \ jp push_hl
  end-code

  \ doc{
  \
  \ -dup  ( x -- x x | x )
  \
  \ Duplicate _x_ if it's negative.
  \
  \ }doc

( ndrop )

need z80-asm

code ndrop  ( x1..xn n -- )

  hl pop  hl addp  exde  \ DE = n cells
    \ pop hl
    \ add hl,hl
    \ ex de,hl
  0 hl ldp#  sp addp  \ HL = stack pointer
    \ ld hl,0
    \ add hl,sp
  de addp  ldsp  \ update SP
    \ add hl,de
    \ ld sp,hl
  jpnext
  end-code

  \ doc{
  \
  \ ndrop  ( x1..xn n -- )
  \
  \ Drop _n_ cell items from the stack.
  \
  \ }doc

( 2ndrop )

need z80-asm

code 2ndrop  ( dx1..dxn n -- )

  hl pop  hl addp  hl addp  exde  \ DE = n cells
    \ pop hl
    \ add hl,hl
    \ add hl,hl
    \ ex de,hl
  0 hl ldp#  sp addp  \ HL = stack pointer
    \ ld hl,0
    \ add hl,sp
  de addp  ldsp  \ update SP
    \ add hl,de
    \ ld sp,hl
  jpnext
  end-code

  \ doc{
  \
  \ ndrop  ( dx1..dxn n -- )
  \
  \ Drop _n_ double cell items from the stack.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ data_structures.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Misc words related to data structures.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( buffer: cvariable enum )

[unneeded] buffer:
?\ : buffer:  ( u "name" -- )  create allot  ;

[unneeded] cvariable
?\ : cvariable  ( "name"  -- )  create 1 allot  ;

[unneeded] enum
?\ : enum  (  n "name" -- n+1 )  dup constant 1+  ;

( set )

: set  ( x a "name" -- )
  create  swap , ,
  does>   ( pfa )  dup @ swap cell+ @ !  ;

  \ doc{
  \
  \ set  ( x a "name" -- )
  \
  \ Define a word "name" which, when executed, will  cause  the
  \ value _x_  to be stored at _a_.
  \
  \ Origin: Forth-79 (Reference Word Set); Forth-83 (Appendix
  \ B.  Uncontrolled Reference Words).
  \
  \ }doc

( link@ link, )

  \ 2015-11-15

  \ Credit:
  \
  \ Code written after the description by Rick VanNorman,
  \ published on Forth Dimensions (volume 20, number 3, pages
  \ 19-22, 1998-09).

defer link@  ( node1 -- node2 )
  ' @ ' link@ defer!
  \ Fetch the linked list node _node_ is pointing to.

: link,  ( node -- )  here over @ , swap !  ;
  \ Create a new linked list node, pointing to _node_.

  \ vim: filetype=soloforth
  \ debugging.tilde-tilde.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The `~~` debugging tool.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( ~~ )

  \ 2016-02-18: First version.

need :noname  need defer  need is

variable ~~?    ~~? on      \ active?
variable ~~x    ~~x off     \ x coordinate
variable ~~y    ~~y off     \ y coordinate
variable ~~key  ~~key off   \ quit key, or zero if no pause

: ~~show  ( nt line block -- )
  ~~x @ ~~y @ at-xy ." Block " . ." Line " . .name .s   ;
  \ Show the debugging info.

: ~~control  ( -- )
  ~~key @ ?dup 0= ?exit  key = if  quit  then  ;
  \ If `~~key` is non-zero, wait for a key and quit if it
  \ equals the contents of `~~key`.

2variable ~~backup-xy

defer ~~save  ( -- )  defer ~~restore  ( -- )

:noname  ( -- )  xy ~~backup-xy 2!        ; is ~~save
:noname  ( -- )     ~~backup-xy 2@ at-xy  ; is ~~restore
  \ Save and restore the current coordinates.

-->


( ~~ )

: (~~)  ( nt line block -- )
  ~~? @
  if    ~~save ~~show ~~control ~~restore
  else  2drop drop  then  ;
  \ Execute the debugging code, if debugging is active.

: ~~  ( -- )
  latest      postpone literal
  >in @ c/l / postpone literal
  blk @       postpone literal
  postpone (~~)  ; immediate compile-only
  \ Compile debugging code.
  \ This word was inspired by Gforth's `~~`.

  \ deferred.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to deferred words.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( defers action-of )

  \ Credit:
  \
  \ Code adapted from the Afera library.

: defers  ( "name" -- )  ' defer@ compile,  ; immediate
  \ Compile the present contents of the deferred word "name"
  \ into the current definition. I.e. this produces static
  \ binding as if "name" was not deferred.
  \
  \ Origin: Gforth.

: action-of  ( Interpretation: "name" -- xt )
             ( Compilation:    "name" -- )
             ( Runtime:        -- xt )
  ' compiling? if    postpone literal postpone defer@
               else  defer@  then  ; immediate
  \ Return the code field address of a deferred word.
  \
  \ Origin: Forth-2012 (CORE EXT).

( <is> [is] is  )

  \ Credit:
  \
  \ Code adapted from the Afera library.

: <is>  ( xt "name" -- )  ' defer!  ;

: [is]  ( xt "name" -- )
  postpone ['] postpone defer!  ; immediate compile-only

: is  ( xt "name" -- )
  compiling? if  postpone [is]  else  <is>  then  ; immediate

( deferred? )

  \ XXX REMARK -- This word can not distinguish deferred words
  \ and aliases, which are created also by `defer`.

: deferred?  ( xt -- wf )  c@ $C3 =  ;
  \ Is _xt_ a deferred word?
  \ The code of a deferred word starts with a Z80 jump ($C3)
  \ to the word it's associated to.

  \ vim: filetype=soloforth
  \ exceptions.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The management of exceptions.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( abort" )

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

  \ XXX TODO use `error`, by modifying `throw`

[defined] abort-message ?\ 2variable abort-message

: (abort")  ( n -- )
  r> count rot if  abort-message 2! -2 throw  then + >r  ;

: abort"  ( Compilation: "ccc<quote>" -- )
  postpone (abort") ,"  ; immediate compile-only

( error>ordinal error>line )

: error>ordinal  ( -n1 -- +n2 )
  \ Convert an error code to its ordinal position in the
  \ library.
  \ -n1 =  -90..-1        \ Standard error codes
  \        -285..-256     \ Solo Forth error codes
  \        -1024..-1000   \ G+DOS error codes
  \ +n2 =  1..146

  \ XXX TODO  add OS codes

  abs
  dup 256 < ?exit
  dup 1000 < if  [ 255 091 - ] literal - exit  then
  [ 1000 286 - 255 091 - + ] literal -   ;

: error>line  ( n1 -- n2 )
  error>ordinal dup >r
  begin
    dup dup 16 / - r@ <>  while  1+
  repeat  rdrop  ;

\ msg-scr (.throw) \

need error>line  need .line

variable msg-scr
s" Standard error codes" locate msg-scr !
  \ XXX TODO rename!

  \ doc{
  \
  \ msg-scr  ( -- a )
  \
  \ Variable that holds the block that holds the error
  \ messages.
  \
  \ }doc

: (.throw)  ( n -- )
  msg-scr @
  if  error>line msg-scr @ .line space  else  .throw#  then  ;

' (.throw) ' .throw defer!

  \ doc{
  \
  \ (.throw)  ( n -- )
  \
  \ Extended behaviour of the deferred word `.throw`:
  \ Print the text of throw error _n_.  The variable `msg-scr`
  \ contains the number of the first block where messages are
  \ hold. If it contains zero, only the error number is printer.
  \
  \ }doc

( ?compiling ?executing )

[unneeded] ?compiling
?\ : ?compiling  ( -- )  compiling? 0= -14 ?throw  ;

  \ doc{
  \
  \ ?compiling  ( -- )
  \
  \ Issue an error if not compiling.
  \
  \ }doc

[unneeded] ?executing
?\ : ?executing  ( -- )  compiling? -263 ?throw  ;

  \ doc{
  \
  \ ?executing  ( -- )
  \
  \ Issue an error if not executing.
  \
  \ }doc

  \ vim: filetype=soloforth

  \ graphics.lines.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words to draw lines.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( rdraw )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83's `DRAW`.

need z80-asm

code rdraw  ( xc yc -- )

  \ Draw a line relative to the current coordinates.
  \
  \ xc yc = relative coordinates from the current ones

  \ XXX FIXME -- use the whole screen

  hl pop  de pop  bc push
  de bc ldp

  \ hl = y
  \ bc = x
  1 e ld#
  b 7 bit  \ negative x?
  nz if  c a ld  neg  -1 e ld#  a c ld  then  \ negative x

  l b ld   \ y
  1 d ld#
  h 7 bit  \ negative y?
  nz if  b a ld  neg  -1 d ld#  a b ld  then  \ negative y

  24BA call \ alternative entry to the DRAW-LINE ROM routine

  bc pop

  jpnext end-code

\ (rdraw) \

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- finish adapting the DRAW-LINE ROM routine

need z80-asm

create (rdraw)
asm


  \  ld      a,c
  \  cp      b
  \  jr      nc,dl_x_ge_y
  \
  \  ld      l,c
  \  push    de
  \  xor     a
  \  ld      e,a
  \  jr      dl_larger
  \
  \ dl_x_ge_y:
  \  or      c
  \  ret     z
  \
  \  ld      l,b
  \  ld      b,c
  \  push    de
  \  ld      d,$00
  \
  \ dl_larger:
  \  ld      h,b
  \  ld      a,b
  \  rra
  \
  \ d_l_loop:
  \  add     a,l
  \  jr      c,d_l_diag
  \
  \  cp      h
  \  jr      c,d_l_hr_vt
  \
  \ d_l_diag:
  \  sub     h
  \  ld      c,a
  \  exx
  \  pop     bc
  \  push    bc
  \  jr      d_l_step
  \
  \ d_l_hr_vt:
  \  ld      c,a
  \  push    de
  \  exx
  \  pop     bc
  \
  \ d_l_step:
  \  ld      hl,($5c7d) ; coords
  \  ld      a,b
  \  add     a,h
  \  ld      b,a
  \  ld      a,c
  \  inc     a
  \  add     a,l
  \  jr      c,d_l_range
  \  jr      z,report_bc ; XXX TODO -- adapt, integer out of range
  \
  \ d_l_plot:
  \  dec     a
  \  ld      c,a
  \  call    l22e5      ; routine plot-sub \ XXX TODO
  \ XXX TODO -- replace `call PLOT-SUB` with `call PLOT-SUB+7`
  \  exx
  \  ld      a,c
  \  djnz    d_l_loop
  \
  \  pop     de
  \  ret
  \
  \ d_l_range:
  \  jr      z,d_l_plot

end-asm

( adraw ) \ from Abersoft Forth

  \ Credit:
  \
  \ Code adapted from Abersoft Forth's `DRAW`.

need plot

2variable x1  2variable incx  2variable y1  2variable incy

  \ System variables used:
  \   23677 = COORDX
  \   23678 = COORDY

: adraw  ( xc yc -- )

  \ Draw a line from the current coordinates to the given
  \ absolute coordinates.

  23678 c@ ( y0 ) dup 0 swap y1 2! - dup abs rot
  \ ( +-ydiff ydiff x )
  23677 c@ ( x0 ) dup 0 swap x1 2! - dup abs rot
  \ ( +-ydiff +-xdiff xdiff ydiff )
  max >r dup 0<  \ negative xdiff?
  if    abs 0 swap r@ ud/mod dnegate
  else  0 swap r@ ud/mod  then
  incx 2! drop dup 0<  \ negative ydiff?
  if    abs 0 swap r@ ud/mod dnegate
  else  0 swap r@ ud/mod  then
  incy 2! drop r> 1+ 0
  do  x1 @ y1 @ plot
      x1 2@ incx 2@ d+ x1 2!
      y1 2@ incy 2@ d+ y1 2!  loop  ;

  \ vim: filetype=soloforth
  \ graphics.ocr.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that recognize characters on the
  \ screen.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( ocr )

  \ Credit:
  \
  \ Adapted from anonymous code published on Todospectrum,
  \ issue 19 (1986-03), page 65.
  \ http://microhobby.speccy.cz/zxsf/revistas-ts.htm

need z80-asm  need ocr-chars

code ocr  ( col line -- n )

  \ Try to recognize the char printed at the given cursor
  \ coordinates, using the charset whose first printable char
  \ is pointed by the variable `ocr-charset`. The variable
  \ `ocr-chars` holds the number of chars in the charset,
  \ and `ocr-first` holds the code of the first char in the
  \ charset.  If succesful, return the char number _n_
  \ according to the said variables.  If no char is recognized,
  \ return 0. Inverse characters are not recognized.

  de pop  hl pop  bc push
    \ get row, get col, save the Forth IP
  l b ld  e c ld  ocr-charset fthl
    \ b=colum, c=row, hl=udg

  c a ld  rrca  rrca  rrca  E0 and#  b xor  a e ld
  c a ld  18 and#  40 xor#  a d ld
    \ de = screen address
  0 de stp |mark 0 unresolved !
    \ modify the code to get the screen address later

  ocr-chars fta  a b ld
    \ number of chars in the charset
  begin
    \ b=remaining chars
    \ hl = address of scan 0 of the current char
    bc push  hl push
    0 de ldp#  \ restore the screen address
    |mark 0 unresolved @ !
      \ compilation: resolve the address of the screen address
    \ de = screen address

-->

( ocr )

    08 b ld# \ scans
    begin
      de ftap  m xor  \ scan match?
      here jrnz >relmark 1 unresolved !
        \ if not, goto next_char
      d inc  hl incp  \ update the pointers
    step  \ next scan

    \ all eight scans match: udg found

    bc pop  bc pop
      \ discard the saved pointer
      \ b = chars left
    ocr-chars fta  b sub  a b ld
    ocr-first fta  b add  a b ld
      \ b = char number
    here jr >relmark 2 unresolved !
      \ go to end

    \ next_char:
    1 unresolved @ >relresolve
    hl pop  0008 de ldp#  de addp  bc pop
  step
  \ b = 0 (no char matches)

  \ end:
  2 unresolved @ >relresolve  0 h ld#  b l ld
  bc pop  jppushhl  end-code

( ocr-charset ocr-first ocr-chars ascii-ocr udg-ocr )

variable ocr-charset

  \ doc{
  \
  \ ocr-charset  ( -- a )
  \
  \ Variable that holds the address of the first printable char
  \ in the charset used by `ocr`. By default it contains
  \ 0x3D00, the address of the space char in the ROM charset.
  \
  \ }doc

variable ocr-first

  \ doc{
  \
  \ ocr-first  ( -- a )
  \
  \ Variable that holds the code of the first printable char in
  \ the charset used by `ocr`. By default it contais 0x80, the
  \ first UDG.
  \
  \ }doc

variable ocr-chars

  \ doc{
  \
  \ ocr-chars  ( -- a )
  \
  \ Variable that holds the number of chars used by `ocr`, from
  \ the address pointed by `ocr-charset`. By default it contais
  \ 0x5F, the number of printable ASCII chars in the ROM
  \ charset.
  \
  \ }doc

need os-chars  need os-udg

: ascii-ocr  ( -- )
  \ Set `ocr` to work with the ASCII charset pointed by the
  \ system variable CHARS.
  os-chars @ 256 + ocr-charset !
  32 ocr-first !
  95 ocr-chars !  ;

: udg-ocr  ( n -- )
  \ Set `ocr` to work with the first _n_ chars of the UDG
  \ set pointed by the system variable UDG.
  os-udg @ ocr-charset !
  128 ocr-first !
  ocr-chars !  ;

19 udg-ocr  \ default

  \ vim: filetype=soloforth
  \ graphics.pixels.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that manipulate pixels.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( pixel-addr )

need (pixel-addr)

  \ XXX TODO use z80-asm

code pixel-addr  ( xc yc -- n a )
  \ Address of a pixel in the screen.
  \ x = 0..255
  \ y = 0..191
  \ n = position of the pixel (0..7) in its screen address
  \ a = address of the pixel byte in the screen bitmap
  E1 c,  D1 c,            \ pop hl / pop de
  C5 c,                   \ push bc
  40 05 + c,              \ ld b,l ; b=y
  48 03 + c,              \ ld c,e ; c=x
  CD c, (pixel-addr) ,       \ call (pixel-addr)
  C1 c,                   \ pop bc
  16 c, 0 c,  58 07 + c,  \ ld d,0 / ld e,a
  C3 c, pushhlde ,        \ jp pushhlde
  end-code

\ (pixel-addr) \

create (pixel-addr)  ( -- a )

  \ This Z80 routine is an alternative entry point to the
  \ "pixel-add" ROM routine (0x22AA), to let the range of the y
  \ coordinate to be 0..191 instead of 0..175.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm
  3E c, BF c,   \ ld a,191 ; max Y coordinate
  90 00 + c,    \ sub b
  C3 c, 22B0 ,  \ jp 0x22B0 ; and return
  end-asm

\ (pixel-addr) \

need z80-asm

create (pixel-addr)  ( -- a )

  \ This Z80 routine is a modified copy of the "pixel-add" ROM
  \ routine (0x22AA), to let the range of the y coordinate to
  \ be 0..191 instead of 0..175. Calling this code is a bit
  \ faster than calling the version that uses the ROM, because
  \ the necessary jump is saved and a useless `and a` has been
  \ removed.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm

  BF a ld#  b sub
    \ b= adjusted Y coordinate (0..191)

  a b ld  rra  scf  rra  a and  rra
    \ the line number from top of screen to B
    \                     0xxxxxxx
    \ set carry flag
    \                     10xxxxxx
    \ clear carry flag
    \                     010xxxxx

  b xor  F8 and#  b xor  a h ld
    \
    \ keep the top 5 bits 11111000
    \                     010xxbbb
    \ transfer high byte to H

  c a ld
    \ the x value 0..255

  rlca rlca rlca  b xor  C7 and#
    \ the y value
    \ apply mask             11000111

  b xor  rlca  rlca
    \ restore unmasked bits  xxyyyxxx
    \ rotate to              xyyyxxxx
    \ required position      yyyxxxxx

  a l ld
    \ low byte to L

  c a ld  07 and#
    \ form the pixel position in A

  ret

  end-asm

( plot )

need (pixel-addr)

code plot  ( xc yc -- )

  D9 c,               \ exx ; save Forth IP
  E1 c,               \ pop hl
  C1 c,               \ pop bc
  40 05 + c,          \ ld b,l
  \ b = y coordinate
  \ c = x coordinate
  ED c, 43 c, 5C7D ,  \ ld (0x5C7D),bc ; update COORDS
  CD c, (pixel-addr) ,   \ call (pixel-addr)
  \ hl = screen address
  \ a = pixel position in hl (0..7)
  CD c, 22EC ,        \ call 0x22EB ; ROM PLOT-SUB + 7
  D9 c,               \ exx ; restore Forth IP
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  jpnext              \ jp (ix)

  end-code

( set-pixel )

  \ Set a pixel without changing the color attributes.

  \ Credit:
  \
  \ Author of the original code: Jos Manuel Lazo.
  \ Published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code set-pixel  ( xc yc -- )

  \ XXX FIXME system halt?

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m or  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( reset-pixel )

  \ Reset a pixel without changing the color attributes.

  \ Credit:
  \
  \ Based on code written by Jos Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code reset-pixel  ( xc yc -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  cpl  m and  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( toggle-pixel )

  \ Toggle a pixel without changing the color attributes.

  \ Credit:
  \
  \ Based on code written by Jos Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code toggle-pixel  ( xc yc -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m xor  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( test-pixel )

need (pixel-addr)  need z80-asm

code test-pixel  ( xc yc -- f )
  hl pop  de pop  bc push
  \ l = y coordinate
  \ e = x coordinate
  l b ld  e c ld
  \ b = y coordinate
  \ c = x coordinate
  (pixel-addr) call
  \ hl = screen address
  \ a = pixel position in hl
  a b ld  b inc  m a ld
  begin  rlca  step \ rotate to bit 0
  bc pop  \ restore the Forth IP
  1 and#  \ pixel?
  ' true jpnz
  ' false jp
  end-code

( pixels )

  \ Credit:
  \
  \ Original code written by Juan Antonio Paz,
  \ published on Microhobby, issue 170 (1988-05), page 21:
  \ http://microhobby.org/numero170.htm
  \ http://microhobby.speccy.cz/mhf/170/MH170_21.jpg

need z80-asm

code pixels  ( -- u )

  \ Return the number of pixels set on the screen.

  exx
  4000 hl ldp#  l b ld  l c ld
  begin  \ byte
    08 d ld#
    begin  \ bit
      m rrc  cy if  bc incp  then  d dec
    z until
    hl incp  h a ld  58 cp#
  z until
  bc push
  exx
  jpnext
  end-code

  \ Original code:
  \
  \ ld hl,16384
  \ ld b,l
  \ ld c,l
  \   byte:
  \ ld d,8
  \   bit:
  \ rrc (hl)
  \ jr nc,next_bit
  \ inc bc
  \   next_bit:
  \ dec d
  \ jr nz,bit
  \ inc hl
  \ ld a,h
  \ cp 88
  \ jr nz,byte
  \ ret


  \ vim: filetype=soloforth
  \ keyboard.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to the keyboard.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ }}} =======================================================
  \ Keyboard {{{

( at-accept clear-accept set-accept )

  \ XXX UNDER DEVELOPMENT
  \ Common code for several versions of `accept`
  \
  \ 2016-03-13: copied from the kernel, in
  \ order to make it optional in the future.

2variable accept-xy       \ coordinates of the edited string
  \ doc{
  \
  \ accept-xy  ( -- a )
  \
  \ A double variable that holds the cursor position at the
  \ start of the most recent `accept`.
  \
  \ }doc

variable accept-buffer    \ address of the edited string
  \ doc{
  \
  \ accept-buffer  ( -- a )
  \
  \ A variable that holds the buffer address used by
  \ the latest execution of `accept`.
  \
  \ }doc

variable /accept          \ max length of the edited string
  \ doc{
  \
  \ /accept  ( -- a )
  \
  \ A variable that holds the buffer max length used by
  \ the latest execution of `accept`.
  \
  \ }doc

variable >accept          \ offset to the cursor position
  \ doc{
  \
  \ >accept  ( -- a )
  \
  \ A variable that holds the offset of the cursor in the
  \ string being edited by `accept`.
  \
  \ }doc

: at-accept  ( -- )  accept-xy 2@ at-xy  ;
  \ doc{
  \
  \ at-accept  ( -- )
  \
  \ Set the cursor position at the start of the most recent
  \ `accept`.
  \
  \ }doc

: clear-accept  ( -- )
  at-accept span @ spaces at-accept  span off  ;
  \ doc{
  \
  \ clear-accept ( -- )
  \
  \ Clear the string currently edited by `accept`.
  \
  \ }doc

: set-accept  ( ca1 len1 -- ca1' )
  clear-accept /accept @ min  ( ca1 len1' )
  dup span ! 2dup system-bank type default-bank
  dup >r
  accept-buffer @  ( ca1 len1' ca2 )
  smove accept-buffer @  ( ca2 )
  r> +  ( ca1' )  ;
  \ doc{
  \
  \ set-accept  ( ca1 len1 -- ca1' )
  \
  \ Set string _ca len_ as the string being edited by `accept`.
  \ Return the address _ca1'_ after its last character.
  \
  \ }doc

( acceptx )

  \ XXX UNDER DEVELOPMENT
  \
  \ Alternative version of `accept` with more editing features
  \
  \ 2016-03-13: copied from the kernel, in
  \ order to make it optional in the future.

need at-accept  need set-accept

: .acceptx  ( -- )

  accept-buffer @ >accept @ at-accept type
    \ Print the start of the string, before the cursor.

  1 inverse  >accept @ span @ <
  if accept-buffer @ >accept @ + c@ emit  else  space  then
  0 inverse
    \ Print the cursor.

  accept-buffer @ span @ >accept @ 1+ min /string type
    \ Print the end of the string, after the cursor.
  ;

-->

( acceptx )

need toggle-capslock

: accept-edit  ( -- )  clear-accept init-accept  ;
: accept-left  ( -- )  ;
: accept-right  ( -- )  ;
: accept-up  ( -- )  ;
: accept-down  ( -- )  ;
: accept-delete  ( -- )  ;

create accept-commands ] noop noop noop noop noop noop
toogle-capslock accept-edit accept-left accept-right
accept-down accept-up accept-delete noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop [

: >accept-command  ( c -- a )  cells accept-commands +  ;
: accept-command  ( c -- )  >accept-command perform  ;

-->

( acceptx )

: init-acceptx  ( ca len -- )
  /accept !  accept-buffer !  >accept off  xy accept-xy 2!  ;

: (acceptx) ( ca len -- len' )  2dup init-accept

  over + over ( bot eot cur )
  begin  key dup 13 <> \ not carriage return?
  while
    dup 12 =  \ delete?
    if    drop  >r over r@ < dup  \ any chars?
          if  8 dup emit  bl emit  emit  then  r> +
    else  \ printable
          >r  2dup <>  \ more?
          if r@ over c!  char+  r@ emit
          then r> drop
    then
  repeat  drop nip swap -  ;  -->

( acceptx )

: acceptx ( ca len -- len' )
  span off  ?dup 0= if  drop 0  else  (acceptx)  then  ;

  \ XXX TMP -- for debugging

: ax  ( -- )  ['] acceptx ['] accept defer!  ;
: a0  ( -- )  ['] default-accept ['] accept defer!  ;

( nuf? )

  \ Credit:
  \
  \ Code adapted from lpForth and Forth Dimensions (volume 10,
  \ number 1, page 29, 1988-05).

need aborted?

[defined] 'cr' ?\ 13 constant 'cr' \ code of carriage return

: nuf?  ( -- f )  'cr' aborted?  ;

  \ XXX OLD -- Classic definition:
  \
  \ : nuf?  ( -- f )  key? dup if  key 2drop key 'cr' = then  ;

  \ doc{
  \
  \ nuf?  ( -- f )
  \
  \ If no key is pressed return _false_.  If a key is pressed,
  \ discard it and wait for a second key. Then return _true_ if
  \ it's a carriage return, else return _false_.

  \ Usage example:
  \
  \ : listing  ( -- )
  \   begin  ." bla " nuf?  until  ." Aborted"  ;
  \
  \ }doc

( aborted? )

: aborted?  ( c -- f )
  key? dup  if    key 2drop key =
            else  nip  then  ;

  \ doc{
  \
  \ aborted?  ( c -- f )
  \
  \ If no key is pressed return _false_.  If a key is pressed,
  \ discard it and wait for a second key. Then return _true_ if
  \ it's _c_, else return _false_.

  \ Usage example:
  \
  \ : listing  ( -- )
  \   begin  ." bla "  bl aborted?  until  ." Aborted"  ;
  \
  \ }doc


( break? )

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO try

: break?  ( -- f )
  key? dup if  key 2drop break-key?  then  ;

( Keyboard rows ports)

  \ Adapted from Afera.
  \ XXX UNDER DEVELOPMENT

  \ -----------------------------------------------------------
  \ Description

  \ Some tools to manage key presses. An improved and detailed
  \ implementation can be found in the Tron 0xF game
  \ (http://programandala.net/en.program.tron_0xf.html).
  \
  \ "kk" stands for "keyboard key". This notation was chosen
  \ first in order to prevent future name clashes with standard
  \ words which uses the "k-" prefix, and second because these
  \ words manage only physical keys of the keyboard, not key
  \ combinations.
  \
  \ -----------------------------------------------------------

( kk-ports kk, kk@ )

  \ There are two versions of `kk,` and `kk@`. They depend on the
  \ value of `/kk`, a constant that holds the bytes ocuppied by
  \ every key in `kk-ports`, 3 or 4.
  \
  \ The application must define `/kk` before loading this
  \ block.

  \ ............................................
  \ Method 1: smaller but slower

  \ Every key identifier occupies 3 bytes in the table (total
  \ size is 120 bytes)

/kk 3 <> dup

?\ : kk,  ( bitmask port -- ) , c,  ;
  \ Store a key definition into the keys table.

?\ : kk@  ( a -- bitmask port ) dup c@ swap 1+ @ ;
  \ Fech a key definition from an element of the keys table.

  \ XXX TODO wrote `kk@` in Z80.

  \ ............................................
  \ Method 2: bigger but faster

  \ Every key identifier occupies 4 bytes in the table (total
  \ size is 160 bytes)

/kk 4 <> dup

?\ : kk,  ( d -- )  2,  ;
  \ Store a key definition into the keys table.

?\ : kk@  ( a -- bitmask port )  2@  ;
  \ Fech a key definition from an element of the keys table.

-->

( kk-ports )

  \ Key constants are defined with double constants this way:
  \ high part = bitmask
  \ low part = port of the keyboard row

$01 $F7FE 2constant kk-1  $02 $F7FE 2constant kk-2
$04 $F7FE 2constant kk-3  $08 $F7FE 2constant kk-4
$10 $F7FE 2constant kk-5

$01 $FBFE 2constant kk-q  $02 $FBFE 2constant kk-w
$04 $FBFE 2constant kk-e  $08 $FBFE 2constant kk-r
$10 $FBFE 2constant kk-t

$01 $FDFE 2constant kk-a  $02 $FDFE 2constant kk-s
$04 $FDFE 2constant kk-d  $08 $FDFE 2constant kk-f
$10 $FDFE 2constant kk-g

$01 $FDFE 2constant kk-cs  $02 $FDFE 2constant kk-z
$04 $FDFE 2constant kk-x   $08 $FDFE 2constant kk-c
$10 $FDFE 2constant kk-v

-->

( kk-ports )

$01 $EFFE 2constant kk-0  $02 $EFFE 2constant kk-9
$04 $EFFE 2constant kk-8  $08 $EFFE 2constant kk-7
$10 $EFFE 2constant kk-6

$01 $DFFE 2constant kk-p  $02 $DFFE 2constant kk-o
$04 $DFFE 2constant kk-i  $08 $DFFE 2constant kk-u
$10 $DFFE 2constant kk-y

$01 $BFFE 2constant kk-en  $02 $BFFE 2constant kk-l
$04 $BFFE 2constant kk-k   $08 $BFFE 2constant kk-j
$10 $BFFE 2constant kk-h

$01 $7FFE 2constant kk-sp $02 $7FFE 2constant kk-ss
$04 $7FFE 2constant kk-m  $08 $7FFE 2constant kk-n
$10 $7FFE 2constant kk-b

-->

( kk-ports )

  \ This table contains the key double constants (port and
  \ bitmak) of all keys.

  \ This table contains 40 items, one per physical key, and
  \ it's organized by keyboard rows.

need kk,

40 constant keys

create kk-ports

kk-1  kk,  kk-2  kk,  kk-3 kk,  kk-4 kk,  kk-5 kk,
kk-q  kk,  kk-w  kk,  kk-e kk,  kk-r kk,  kk-t kk,
kk-a  kk,  kk-s  kk,  kk-d kk,  kk-f kk,  kk-g kk,
kk-cs kk,  kk-z  kk,  kk-x kk,  kk-c kk,  kk-v kk,
kk-0  kk,  kk-9  kk,  kk-8 kk,  kk-7 kk,  kk-6 kk,
kk-p  kk,  kk-o  kk,  kk-i kk,  kk-u kk,  kk-y kk,
kk-en kk,  kk-l  kk,  kk-k kk,  kk-j kk,  kk-h kk,
kk-sp kk,  kk-ss kk,  kk-m kk,  kk-n kk,  kk-b kk,

( kk-1# )

  \ Key number constants, to be used as indexes of the key
  \ tables.

need enum

0
enum kk-1#  enum kk-2#  enum kk-3# enum kk-4# enum kk-5#
enum kk-q#  enum kk-w#  enum kk-e# enum kk-r# enum kk-t#
enum kk-a#  enum kk-s#  enum kk-d# enum kk-f# enum kk-g#
enum kk-cs# enum kk-z#  enum kk-x# enum kk-c# enum kk-v#
enum kk-0#  enum kk-9#  enum kk-8# enum kk-7# enum kk-6#
enum kk-p#  enum kk-o#  enum kk-i# enum kk-u# enum kk-y#
enum kk-en# enum kk-l#  enum kk-k# enum kk-j# enum kk-h#
enum kk-sp# enum kk-ss# enum kk-m# enum kk-n# enum kk-b#
drop

( kk-chars )

  \ This table contains the chars used as names of the keys.

  \ This table contains 40 items, one per physical key, and
  \ it's organized by keyboard rows.

  \ By default, the first 4 UDG are used for keys whose names
  \ are not a printable char:
  \
  \ 128 = Caps Shift
  \ 129 = Enter
  \ 130 = Space
  \ 131 = Symbol Shift

create kk-chars

char 1 c,  char 2 c,  char 3 c,  char 4 c,  char 5 c,
char q c,  char w c,  char e c,  char r c,  char t c,
char a c,  char s c,  char d c,  char f c,  char g c,
128    c,  char z c,  char x c,  char c c,  char v c,
char 0 c,  char 9 c,  char 8 c,  char 7 c,  char 6 c,
char p c,  char o c,  char i c,  char u c,  char y c,
129    c,  char l c,  char k c,  char j c,  char h c,
130    c,  131    c,  char m c,  char n c,  char b c,

( pressed pressed? )

need [if]

[needed] pressed? [needed] pressed or [if]

need @p

: pressed? ( n1 n2 -- f )  @p and 0=  ;
  \ Is a key pressed?
  \ n1 = key bitmask
  \ n2 = keyboard row port

[then]

[needed] pressed [if]

need pressed?  need kk-ports

: pressed  ( -- false | n1 n2 true )
  0 \ false by default
  [ kk-ports keys /kk * bounds swap ] literal literal
  do  i kk@ pressed? if  drop i kk@ 1 leave  then  /kk +loop  ;
  \ Return the key identifier of the first key
  \ from the keys table that happens to be pressed.
  \ n1 = key bitmask
  \ n2 = keyboard row port

[then]

( only-one-pressed )

  \ XXX UNDER DEVELOPMENT

  \ The application must define the `/k` constant.

need kk-ports

0. 2variable kk-pressed

: only-one-pressed  ( -- false | n1 n2 true )

  \ XXX TODO finish

  0. kk-pressed 2! \ none by default
  [ kk-ports keys /kk * bounds swap ] literal literal
  do  i kk@ pressed?
  if  kk-pressed 2@ + if
  then
  /kk +loop
  kk-pressed 2@ 2dup + if  1  else  2drop 0  then  ;

  \ Return the key identifier of the key pressed,
  \ if there's only one key pressed.
  \ n1 = key bitmask
  \ n2 = keyboard row port

  \ vim: filetype=soloforth
  \ keyboard.inkey.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `inkey`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( inkey )

need z80-asm

code inkey  ( -- c | 0 )

  \ Leave the value of the key being pressed. If no key being
  \ pressed, leave 0.
  \
  \ This word works only when an interrupts routine reads the
  \ keyboard and updates the related system variables.

  \ XXX FIXME -- Some times this word returns zero when the key
  \ is pressed; the version on the previous block works fine.
  \ Anyway this version is smaller and can be useful.

  a xor
  01 iy 5 bitx  \ a new key pressed?
  nz if
    5C08 hl ldp#  \ LAST-K system variable
    m a ld
    \ 0 m ld# \ XXX OLD
    01 iy 5 resx
  then
  pusha jp

  end-code

  \ vim: filetype=soloforth
  \ operators.1-cell.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Single-cell operators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( under+ )  \ ==operators==

code under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  D9 c,           \ exx
  D1 c,           \ pop de
  C1 c,           \ pop bc
  E1 c,           \ pop hl
  19 c,           \ add hl,de
  E5 c,           \ push hl
  C5 c,           \ push bc
  D9 c,           \ exx
  jpnext  end-code

  \ doc{
  \
  \ under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  \
  \ Add _n2|u2_ to _n1|u2_, giving the sum _n3|u3_.
  \
  \ Origin: Comus.
  \
  \ ----
  \ : under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  \   rot + swap  ;
  \ ----
  \
  \ }doc

( +under )

code +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  D9 c,           \ exx
  C1 c,           \ pop bc
  D1 c,           \ pop de
  E1 c,           \ pop hl
  19 c,           \ add hl,de
  E5 c,           \ push hl
  C5 c,           \ push bc
  D9 c,           \ exx
  jpnext  end-code

  \ doc{
  \
  \ +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  \
  \ Add _n2|u2_ to _n1|u2_, giving the sum _n3|u3_.
  \
  \ Origin: Comus.
  \
  \ ----
  \ : +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  \   >r + r>  ;
  \ ----
  \
  \ }doc

  \ XXX TODO -- variant after PFE's `(under+)`:
  \ : +under  ( n1 n2 -- n1+n2 n2 )  tuck + swap  ;

( within between )

  \ Credit:
  \
  \ Code from DZX-Forth.

[unneeded] within
?\ : within  ( n1|u1 n2|u2 n3|u3 -- f )  over - >r - r> u<  ;

  \ doc{
  \
  \ within  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Perform a comparison of a test value n1|u1 with a lower
  \ limit _n2|u2_ and an upper limit _n3|u3_, returning _true_
  \ if either (n2|u2 < n3|u3 and (n2|u2 <= n1|u1 and n1|u1 <
  \ n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 <= n1|u1 or n1|u1 <
  \ n3|u3)) is true, returning _false_ otherwise. An ambiguous
  \ condition exists if _n1|u1_, _n2|u2_, and _n3|u3_ are not
  \ all the same type.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

[unneeded] between ?exit

: between  ( n1|u1 n2|u2 n3|u3 -- f )  over - -rot - u< 0=  ;

  \ doc{
  \
  \ between  ( n1|u1 n2|u2 n3|u3 -- f )

  \ Perform a comparison of a test value _n1|u1_ with a lower
  \ limit _n2|u2_ and an upper limit _n3|u3_, returning _true_
  \ if either (n2|u2 <= n3|u3 and (n2|u2 <= n1|u1 and n1|u1 <=
  \ n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 < n1|u1 or n1|u1 <
  \ n3|u3)) is true, returning _false_ otherwise. An ambiguous
  \ condition exists if _n1|u1_, _n2|u2_, and _n3|u3_ are not
  \ all the same type.

  \ name  ( -- )
  \
  \ }doc

  \ Credit:
  \
  \ http://dxforth.netbay.com.au/between.html

( polarity )

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

code polarity  ( n -- -1 | 0 | 1 )
  D1 c, 78 02 + c,  B0 03 + c,  CA c, ' false ,
    \ pop de
    \ ld a,d
    \ or e
    \ jp z,false_code

  CB c, 10 03 + c,  ED c, 62 c,
    \ rl d ; set carry if DE -ve
    \ sbc hl,hl ; HL=0 if DE +ve, or -1 if DE -ve

  78 05 + c,  F6 c, 01 c,  68 07 + c,  jppushhl
    \ ld a,l
    \ or 1
    \ ld l,a ; HL=1 or -1
    \ jp push_hl
  end-code

( u<= u>= <= >= 0>= 0<= )

[unneeded] u<=  ?\ : u<=  ( u1 u2 -- f )  u> 0=  ;  exit
[unneeded] u>=  ?\ : u>=  ( u1 u2 -- f )  u< 0=  ;  exit
[unneeded] <=   ?\ : <=   ( n1 n2 -- f )  > 0=   ;  exit
[unneeded] >=   ?\ : >=   ( n1 n2 -- f )  < 0=   ;  exit
[unneeded] 0>=  ?\ : 0>=  ( n1 n2 -- f )  0< 0=  ;  exit
[unneeded] 0<=  ?\ : 0<=  ( n1 n2 -- f )  0> 0=  ;

( lshift )

need z80-asm

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

  \ 16 bytes used

code lshift  ( x1 u -- x2 )

  exx
  bc pop  \ C = loop counter
  c b ld
  hl pop  \ hi 8 bits ignored!
  b inc  ahead 0 unresolved !
  begin  hl addp  0 unresolved @ >relresolve  step
  hl push
  exx
  jpnext

  end-code

( lshift )

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

  \ This version is smaller (13 bytes used) but slower (169%
  \ the execution time of version adapted from Z88 CamelForth).

code lshift  ( x1 u -- x2 )

  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  29 c,           \ add hl,hl
  C3 c, ,         \ jp begin

  end-code

( rshift )

need z80-asm

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

  \ 19 bytes used

code rshift  ( x1 u -- x2 )

  exx
  bc pop  \ C = loop counter
  c b ld
  hl pop  \ hi 8 bits ignored!

  b inc  ahead 0 unresolved !

  begin  h srl  l rr  0 unresolved @ >relresolve  step
  hl push
  exx
  jpnext

  end-code

( rshift )

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

  \ This version is smaller (16 bytes used) but slower (133%
  \ the execution time of the version adapted from Z88 CamelForth).

code rshift  ( x1 u -- x2 )
  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  CB c, 3C c,     \ srl h
  CB c, 1D c,     \ rr l
  C3 c, ,         \ jp begin
  end-code

( 2/ )

  \ Credit:
  \
  \ Code from Spectrum Forth-83.
  \ Documentation partly based on lina.

code 2/  ( x1 -- x2 )
  E1 c,           \ pop hl
  CB c, 2C c,     \ sra h
  CB c, 1D c,     \ rr l
  jppushhl        \ jp pushhl
  end-code

  \ doc{
  \
  \ 2/  ( x1 -- x2 )
  \
  \ _x2_ is the result of shifting _x1_ one bit toward the
  \ least-significant bit, leaving the most-significant bit
  \ unchanged.
  \
  \ This is the same as `s>d 2 fm/mod swap drop`. It is not the
  \ same as `2 /`, nor is it the same as `1 rshift`.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
  \ Forth-2012 (CORE).
  \
  \ }doc

( sqrt )

  \ Credit:
  \
  \ Original code by Wil Baden, published on Forth Dimensions
  \ (volume 18, number 5, page 27, 1997-01).

need d2*  need 2/

[defined] cell-bits ?\ 16 constant cell-bits

: (sqrt)  ( radicand -- remainder root )
  0 0                           ( radicand remainder root )
  [ cell-bits 2/ ] literal 0 do
    >r d2* d2* r>               \ shift remainder left 2 bits
    2*                          \ shift root left 1 bit
    2dup 2* u> if               \ check for next bit of root
      >r r@ 2* - 1- r>          \ reduce remainder
      1+                        \ add a bit to root
    then
  loop  cr .s rot drop  ;

: sqrt  ( radicand -- root )  (sqrt) nip  ;

( sqrt )

  \ Integer square root by Newton's method

  \ Credit:
  \
  \ Adapted from Sinclair QL's Computer One Forth.

: sqrt  ( n1 -- n2 )
  dup 0< -24 ?throw  \ invalid numeric argument
  dup
  if  dup 2/  20 0
      do      2dup / + 2/
      loop    swap drop
  then  ;

( sm/rem )

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: sm/rem  ( d1 n1 -- n2 n3 )
  \ symmetric signed division
  2dup xor >r  \  sign of quotient
  over >r      \  sign of remainder
  abs >r dabs r> um/mod
  swap r> ?negate
  swap r> ?negate  ;

  \ doc{
  \
  \ sm/rem  ( d1 n1 -- n2 n3 )

  \ Divide d1 by n1, giving the symmetric quotient n3 and the
  \ remainder n2. Input and output stack arguments are signed.
  \ An ambiguous condition exists if n1 is zero or if the
  \ quotient lies outside the range of a single-cell signed
  \ integer.

  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).

  \ [caption="Symmetric Division Example"]
  \
  \ |===
  \ | Dividend  | Divisor | Remainder | Quotient

  \ >|       10  >|      7  >|        3  >|        1
  \ >|      -10  >|      7  >|       -3  >|       -1
  \ >|       10  >|     -7  >|        3  >|       -1
  \ >|      -10  >|     -7  >|       -3  >|        1
  \ |===

  \ }doc

( /-rem /- -rem */-rem */- )

  \ Symmetric-division operators

  \ Credit:
  \
  \ Forth-94 documentation.

: /-rem  ( n1 n2 -- n3 n4 )  >r  s>d  r> sm/rem  ;

: /-  (  n1 n2 -- n3 )  /-rem nip  ;

: -rem  ( n1 n2 -- n3 )  /-rem drop  ;

: */-rem  (  n1 n2 n3 -- n4 n5 )  >r  m*  r> sm/rem  ;

: */-  ( n1 n2 n3 -- n4 )  */-rem nip  ;

( fm/mod )

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: fm/mod  ( d1 n1 -- n2 n3 )
  \ floored signed division
  dup >r                \ save divisor
  sm/rem
  over 0<> over 0< and  \ quotient<0 and remainder<>0?
  if
    swap r> +           \ add divisor to remainder
    swap 1-             \ decrement quotient
  else r> drop then  ;

  \ doc{
  \
  \ fm/mod  ( d1 n1 -- n2 n3 )
  \
  \ Floored division:
  \
  \ ----
  \   d1 = n3*n1+n2
  \   n1>n2>=0 or 0>=n2>n1
  \ ----
  \
  \ Divide _d1_ by _n1_, giving the floored quotient _n3_ and
  \ the remainder _n2_. Input and output stack arguments are
  \ signed.
  \
  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).

  \ [caption="Floored Division Example"]
  \
  \ |===
  \ | Dividend  | Divisor | Remainder | Quotient

  \ >|       10  >|      7  >|        3  >|        1
  \ >|      -10  >|      7  >|        4  >|       -2
  \ >|       10  >|     -7  >|       -4  >|       -2
  \ >|      -10  >|     -7  >|       -3  >|        1
  \ |===
  \
  \ }doc

( /_mod /_ _mod */_mod */_ )

  \ Floored-division operators

need fm/mod

  \ Credit:
  \
  \ Forth-94 documentation.

: /_mod  ( n1 n2 -- n3 n4 )  >r s>d r> fm/mod  ;

: /_  ( n1 n2 -- n3 )  /_mod nip  ;

: _mod  ( n1 n2 -- n3 )  /_mod drop  ;

: */_mod  ( n1 n2 n3 -- n4 n5 )  >r m* r> fm/mod  ;

: */_  ( n1 n2 n3 -- n4 )   */_mod nip  ;

( any? )

  \ Credit:
  \
  \ Code from F83.

need roll

variable (any?)

: any?  ( x0 x1..xn n -- f )
  dup 1+ roll (any?) !
  0 swap 0 do  swap (any?) @ = or  loop  ;
  \ Is any _x1..xn_ equal to _x0_?

( % u% )

: %  ( n1 n2 -- n3 )  100 swap */  ;
  \ _n1_ is percentage _n3_ of _n2_

: u%  ( u1 u2 -- u3 )  >r 100 um* r> um/mod nip  ;
  \ _u1_ is percentage _u3_ of _u2_

  \ vim: filetype=soloforth
  \ parsing.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to parsing.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( parse-line )

  \ XXX OLD -- 2015-09-13: moved to kernel
  \ : source  ( -- a len )  \ Forth-94
  \   blk @ ?dup if  block b/buf  else  tib #tib @  then  ;

: parse-line  ( "ccc<eol>" -- ca len )
  source span @ min c/l min  >in @ span @ min /string
  dup >in +! save-string  ;

  \ doc{
  \
  \ parse-line  ( "ccc<eol>" -- ca len )
  \
  \ Get the text string until the end of line.  Note: this is a
  \ factor of the editor's `text`.
  \
  \ }doc

( evaluate )

  \ XXX UNDER DEVELOPMENT

  \ XXX Gforth:
: execute-parsing  ( ca len xt -- )
  >in @ >r >in off
  source >r >r ;

: evaluate  ( ca len -- )  ['] interpret execute-parsing  ;

( parse-char )

: parse-char  ( "c"  -- c )  stream drop c@ 1 parsed  ;
  \ Parse the next char in the input stream and return its
  \ code.

( word )

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: word  ( c "<chars>ccc<char>" -- ca )
  dup  stream                 ( c c ca len )
  dup >r   rot skip           ( c ca' len' )
  over >r  rot scan           ( ca" len" )
  dup if  char-  then         \ skip trailing delimiter
  r> r> rot -   >in +!        \ update `>in`
  tuck -                      ( ca' len )
  here place  here            ( ca )
  bl over count + c!  ;       \ append trailing blank

  \  doc{
  \
  \  word  ( c "<chars>ccc<char>" -- ca )
  \
  \  c = delimiter char
  \
  \  Skip leading _c_ delimiters from the input stream.  Parse
  \  the next text characters from the input stream, until a
  \  delimiter _c_ is found, storing the packed character
  \  string beginning at _ca_, as a counted string (the
  \  character count in the first byte), and with one blank at
  \  the end.  byte), and with one blank at the end (not
  \  included in the count).
  \
  \  Origin: Forth-94 (CORE), Forth-2012 (CORE).
  \
  \  }doc

( defined? )

: defined?  ( ca len -- wf )  undefined? 0=  ;

( save-input restore-input )

  \ XXX UNDER DEVELOPMENT
  \
  \ 2016-01-01: Code copied from m3Forth:
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/core-ext.f

: save-input ( -- xn ... x1 n )
  source-id 0>
  if tib #tib @ 2dup c/l 2 + allocate throw dup >r swap cmove
     r> to tib  >in @
     source-id file-position throw
     5
  else blk @ >in @ 2 then
  ;

-->
( save-input restore-input )

: restore-input ( xn ... x1 n -- f )
  source-id 0>
  if dup 5 <> if 0 ?do drop loop -1 exit then
     drop source-id reposition-file ?dup
     if >r 2drop drop r> exit then
     >in ! #tib ! to tib false
  else dup 2 <> if 0 ?do drop loop -1 exit then
     drop >in ! blk ! false
  then
  ;

  \ vim: filetype=soloforth
  \ memory.ports.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words for ports input and output.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( @p )

code @p  ( a -- b )

  \ Input byte _b_ from port _a_.

  E1 c,           \ pop hl
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  ED c, 68 c,     \ in l,(c)
  C1 c,           \ pop bc
  26 c, 00 c,     \ ld h,0x00
  jppushhl        \ jp pushhl
  end-code

( !p )

code !p  ( b a -- )

  \ Output byte _b_ to port _a_.

  E1 c,           \ pop hl
  D1 c,           \ pop de ; char in e
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  ED c, 59 c,     \ out (c),e
  C1 c,           \ pop bc
  jpnext          \ jp (ix)

  end-code

  \ vim: filetype=soloforth
  \ printing.control.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160325

  \ -----------------------------------------------------------
  \ Description

  \ Words related printing control characters.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( tabulate tab-stop )

need column

  \ 2015-12-14
  \ XXX FIXME

variable tab-stop  8 tab-stop !

: tabulate  ( -- )  column 1+ tab-stop @ tuck mod - spaces  ;

( 'cr' 'tab' 'bs' crs tab tabs backspace backspaces )

 6 constant 'tab'
 8 constant 'bs'
13 constant 'cr'

: tab          ( -- )  'tab' emit  ;
: backspace    ( -- )  'bs'  emit  ;

: crs           ( n -- )  'cr'  emits  ;
: tabs          ( n -- )  'tab' emits  ;
: backspaces    ( n -- )  'bs'  emits  ;

  \ vim: filetype=soloforth
  \ printing.cursor.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160325

  \ -----------------------------------------------------------
  \ Description

  \ Words related to the cursor position.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( column last-column row last-row at-x at-y )

: column  ( -- col )  xy drop  ;
  \ Current column (x coordinate).

: last-column  ( -- row  )  column 1-  ;
  \ Last column (x coordinate).

: row  ( -- row )  xy nip  ;
  \ Current row (y coordinate).

: last-row  ( -- row  )  row 1-  ;
  \ Last row (y coordinate).

: at-x  ( col -- )  row at-xy  ;
  \ Set the cursor
  \ at the given column (x coordinate)
  \ and the current row (y coordinate).

: at-y  ( row -- )  column swap at-xy  ;
  \ Set the cursor
  \ at the current column (x coordinate)
  \ and the given row (y coordinate).

  \ vim: filetype=soloforth
  \ random.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Random number generators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( randomize randomize0 )

need os-seed

[needed] randomize0 ?\ : randomize  ( n -- )  os-seed !  ;
  \ Set the seed of the random number generator.

need os-frames

: randomize0  ( n -- )
  ?dup 0=  if  os-frames @  then  os-seed !  ;
  \ Set the seed of the random number generator;
  \ if _n_ is zero use the system frames counter instead.

( rnd random )  \ ==rng==

  \ Credit:
  \
  \ Code adapted from Leo Brodie's _Starting Forth_.

need os-seed

: rnd  ( -- n )  os-seed @ 31421 * 6927 + dup os-seed !  ;

: random  ( n -- 0..n-1 )  rnd um* nip  ;

( random-range )

need random

: random-range ( n1 n2 -- n3 ) over - 1+ random +  ;
  \ Return a random number from _n1_ (min) to _n2_ (max).

( rng-benchmark )

  \ Random number generator benchmark

need set-pixel  need bench{  need pixels  need u%  need 3dup

256 192 * constant #pixels
  \ number of pixels of the screen

defer rng  ( n -- 0..n-1 )

: pixels%.  ( u -- )  #pixels u% 0.r ." %"  ;
  \ Print _u_ pixels as a percentage of the maximum
  \ number of pixels.

: .pixels  ( u -- )  dup u. ." pixels (" pixels%. ." )"  ;
  \ Print _u_ as the number of pixels.

: .title  ( ca len -- )  ." Code: " type  ;

variable cycles

defer .cycles  ( -- )

: (.cycles)  ( -- )
  cycles ?  s" cycles" cycles @ 1 = + type  ;
  \ Print the number of cycles.

: .time  ( d -- )  bench. ." per cycle" cr  ;

: .result  ( ca len d -- )
  2>r pixels >r  .title cr  r> .pixels cr
  2r> .time .cycles   ;
  \ Calculate and print the result of the benchmark.
  \ _d_ is the time in frames; _ca len_ is the title.

-->

( rng-benchmark )

defer random-coords  ( -- xc yc )
  \ Random graphic coordinates. Configurable depending on the
  \ type of `random` to benchmark.

: (random-coords)  ( -- xc yc )  256 rng 193 rng  ;
  \ Default behaviour of `random-coords`.

: fill-screen  ( -- )
  #pixels 0 do  random-coords set-pixel  loop  ;
  \ Fill the screen with random pixels.

: signal  ( -- )  cycles @ %111 and border  ;
  \ Change the border color according to the current count
  \ of cycles, just to show that the benchmark is running.

: (rng-benchmark)  ( -- d )
  1 cycles +!  signal  bench{ fill-screen }bench  ;
  \ Do the RNG benchmark of ony cycle and return its result.

: wait  ( -- )  key drop  ;

: finish  ( ca len d -- )  0 border  .result  wait  ;
  \ Finish the benchmark.
  \ _d_ is the time in frames; _ca len_ is the title.

: init  ( xt1 xt2 x3 -- )
  ['] random-coords defer!  ['] .cycles defer!  ['] rng defer!
  page  -1 cycles !  ;

defer finish?  ( i*x -- j*x f )
  \ Finish the benchmark?

: new-pixels?  ( n1 -- n2 f )  pixels tuck =  ;
  \ Are there new pixels on the screen, comparing the previous
  \ count _n1_ with the new count _n2_?

' new-pixels? ' finish? defer!  -->

( rng-benchmark )

defer rng-benchmark  ( ca len xt -- )
  \ Do a RNG benchmark for the `random` word _xt_ with title
  \ _ca len_.

: (rng-benchmark2)  ( ca len -- )
  0 begin   (rng-benchmark) 2>r
            finish? dup 0= if  2rdrop  then
  until     drop 2r> finish  ;
  \ Do a double RNG benchmark with title _ca len_: The time
  \ required to complete one cycle (49152 random pixels), plus
  \ the number of cycles required until the number of pixels
  \ doesn't change.

: rng-benchmark2  ( ca len xt -- )
  ['] (.cycles) ['] (random-coords) init  (rng-benchmark2)  ;
  \ Do a double RNG benchmark for the `random` word _xt_ with
  \ title _ca len_: The time required to complete one cycle
  \ (49152 random pixels), plus the number of cycles required
  \ until the number of pixels doesn't change.

  \ The best `random` words need several cycles. In such cases
  \ it's useful a simpler test to show only the pixels set at
  \ the end of the first cycle:

' rng-benchmark2 ' rng-benchmark defer!  \ default benchmark

: (.cycle)  ( -- )  ." First cycle only"  ;

: (rng-benchmark1)  ( ca len -- )
  (rng-benchmark) .result wait  ;
  \ Do a one-cycle RNG benchmark with title _ca len_: Only the
  \ time required to complete one cycle (49152 random pixels).

: rng-benchmark1  ( ca len xt -- )
  ['] (.cycle) ['] (random-coords) init  (rng-benchmark1)  ;
  \ Do a one-cycle RNG benchmark for `random` word _xt_ with
  \ title _ca len_: Only the time required to complete one
  \ cycle (49152 random pixels).

-->

( rng-benchmark )

  \ Versions for 8-bit `rnd`.

: crnd-coords  ( -- xc yc )  rng rng 192 min  ;
  \ Random graphic coordinates for 8-bit `rnd`.

: rng8-benchmark2  ( ca len xt -- )
  ['] (.cycles) ['] crnd-coords init  (rng-benchmark2)  ;
  \ Do a one-cycle RNG benchmark for 8-bit `rnd` word _xt_ with
  \ title _ca len_: Only the time required to complete one
  \ cycle (49152 random pixels).

: rng8-benchmark1  ( ca len xt -- )
  ['] (.cycle) ['] crnd-coords init  (rng-benchmark1)  ;
  \ Do a one-cycle RNG benchmark for 8-bit `rnd` word _xt_ with
  \ title _ca len_: Only the time required to complete one
  \ cycle (49152 random pixels).

( all-rng-benchmarks )

  \ Execute all 16-bit RNG benchmarks

need rng-benchmark  need +thru  1 13 +thru

ace-rng-benchmark   dx-rng-benchmark
gf-rng-benchmark    jer-rng-benchmark
jml-rng-benchmark   lb-rng-benchmark
lina-rng-benchmark  mb-rng-benchmark
sf83-rng-benchmark  tt-rng-benchmark
vf-rng-benchmark    z88-rng-benchmark
zh-rng-benchmark

  \ Execute single-cycle benchmarks of RNG that need more than
  \ one cycle to finish:

' rng-benchmark1 ' rng-benchmark defer!

dx-rng-benchmark  vf-rng-benchmark

( ace-random )

  \ Credit:
  \
  \ Adapted from ACE Forth, after the Jupiter ACE manual.
  \ Also used by Abersoft Forth in its bundled game
  \ "Bertie".

need os-seed

: ace-rnd  ( -- n )
  os-seed @ 75 um* 75. d+ 2dup u< - - 1- dup os-seed !  ;

: ace-random  ( n1 -- n2 )  ace-rnd um* nip  ;

need rng-benchmark

: ace-rng-benchmark  ( -- )
  s" Jupiter ACE manual" ['] ace-random rng-benchmark  ;

( dx-random )

  \ Credit:
  \
  \ Code from DX-Forth 4.13.

2variable dx-seed  1. dx-seed 2!

need d*

: dx-rnd ( -- u )
  dx-seed 2@ $15A4E35. d* 1. d+ tuck dx-seed 2!  ;
  \ Get random number

: dx-random ( u -- 0..u-1 )  dx-rnd um* nip  ;
  \ Get random number between 0 and u-1

need rng-benchmark

: dx-rng-benchmark  ( -- )
  s" DX-Forth" ['] dx-random rng-benchmark  ;

( gf-random )

  \ Credit:
  \
  \ Adapted from Gforth.

need os-seed  need ud*

: gf-rnd  ( -- n )
  272958469. os-seed @ ud* d>s 1+ dup os-seed !  ;

: gf-random  ( n1 -- n2 )  gf-rnd um* nip  ;

need rng-benchmark

: gf-rng-benchmark  ( -- )
  s" Gforth" ['] gf-random rng-benchmark  ;

( jer-random )

  \ Credit:
  \
  \ Random number generator by J. E. Rickenbacker, published on
  \ Forth Dimensions (volume 2, number 2, page 34, 1980-07).

need os-seed

: jer-rnd  ( -- n )
  os-seed @ 259 * 3 + 32767 and dup os-seed !  ;

: jer-random ( n1 -- n2 )
  jer-rnd 32767 */  ;
  \ Return a random number _n2_ (0 <= n2 < n1).

  \ XXX Note: patterns

need rng-benchmark

: jer-rng-benchmark  ( -- )
  s" J. E. Rickenbacker" ['] jer-random rng-benchmark  ;

( jml-random )

  \ Credit:
  \
  \ Adapted from code written by Jos Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need z80-asm  need os-seed

code jml-rnd  ( -- u )

  os-seed fthl  hl push
  hl addp  hl addp  hl addp  hl addp  hl addp  hl addp
  de pop  de addp  0029 de ldp#  de addp
  os-seed sthl
  jppushhl
  end-code

: jml-random  ( n -- 0..n-1 )  jml-rnd um* nip  ;

need rng-benchmark

: jml-rng-benchmark  ( -- )
  s" J.M. Lazo" ['] jml-random rng-benchmark  ;

( lb-random )

  \ Credit:
  \
  \ Code adapted from Leo Brodie's _Starting Forth_.

need os-seed

: lb-rnd  ( -- n )  os-seed @ 31421 * 6927 + dup os-seed !  ;

: lb-random  ( n -- 0..n-1 )  lb-rnd um* nip  ;

need rng-benchmark

: lb-rng-benchmark  ( -- )
  s" Leo Brodie" ['] lb-random rng-benchmark  ;

( lina-random )

need os-seed

: lina-rnd  ( -- n )
  os-seed @ 107465 * 234567 + dup os-seed !  ;

: lina-random  ( n1 -- n2 )  lina-rnd um* nip ;

need rng-benchmark

: lina-rng-benchmark  ( -- )
  s" lina" ['] lina-random rng-benchmark  ;

( mb-random )

  \ Credit:
  \
  \ Adapted from code published by Milos Bazelides:
  \ http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#4

need z80-asm  need os-seed

code mb-rnd  ( -- n )
  os-seed de ftp
  d a ld  e h ld  #253 l ld#
  a or  de sbcp
  0 sbc#  de sbcp
  0 d ld#  d sbc  a e ld
  de sbcp
  cy if  hl incp  then
  os-seed sthl
  jppushhl   end-code

: mb-random  ( n1 -- n2 )  mb-rnd um* nip  ;

  \ Original code:

  \ ----
  \ ; Input: none
  \ ; Output: HL = pseudo-random number, period 65536

  \ Rand16:
  \  ld  de,Seed    ; Seed is usually 0
  \  ld  a,d
  \  ld  h,e
  \  ld  l,253
  \  or  a
  \  sbc  hl,de
  \  sbc  a,0
  \  sbc  hl,de
  \  ld  d,0
  \  sbc  a,d
  \  ld  e,a
  \  sbc  hl,de
  \  jr  nc,Rand
  \  inc  hl
  \ Rand:
  \  ld  (Rand16+1),hl
  \  ret
  \ ----

need rng-benchmark

: mb-rng-benchmark  ( -- )
  s" Milos Bazelides" ['] mb-random rng-benchmark  ;

( sf83-random )

  \ Credit:
  \
  \ Code from Spectrum Forth-83.

need os-seed  3 os-seed !

: sf83-random  ( n -- 0..n-1 )
  os-seed @ 743 * 43 + dup os-seed ! um* swap drop  ;

need rng-benchmark

: sf83-rng-benchmark  ( -- )
  s" Spectrum Forth-83" ['] sf83-random rng-benchmark  ;

( tt-random )

  \ Credit:
  \
  \ Code from tt.pfe, Tetris for terminals, redone in
  \ ANSI-Forth.  Written 1994-04-05 by Dirk Uwe Zoller.

need os-seed

: tt-random   ( n -- 0..n-1 )
    os-seed @ 13 * $7FFF and
    dup os-seed !  swap mod ;

need rng-benchmark

: tt-rng-benchmark  ( -- )
  s" Tetris for terminals" ['] tt-random rng-benchmark  ;

( vf-random )

  \ Credit:
  \
  \ Code from vForth.

need os-frames

: vf-random  ( n1 -- n2 )
  1+ 8195 os-frames @ um* 1. d+
  16383 um/mod drop
  \ dup os-seed !
  swap mod  ;

need rng-benchmark

: vf-rng-benchmark  ( -- )
  s" vForth" ['] vf-random rng-benchmark  ;

( z88-random )

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

need ud*  need os-seed

: z88-random  ( u1 -- u2 )
  1103515245. \ 20077 16838
  os-seed @ ud* 12345. d+ over os-seed !
  rot ud/mod 2drop  ;

need rng-benchmark

: z88-rng-benchmark  ( -- )
  s" Z88 CamelForth" ['] z88-random rng-benchmark  ;

( zh-random )

  \ Credit:
  \
  \ Code adapted from:
  \ http://z80-heaven.wikidot.com/math#toc40

need z80-asm  need os-seed

code zh-rnd  ( -- n )

  os-seed fthl
    \ ld hl,(seed)
  hl de ldp
    \ ld c,l
    \ ld b,h
  hl addp  de addp  hl addp  de addp  hl addp
  de addp  hl addp  hl addp  hl addp  hl addp  de addp
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,hl
    \ add hl,hl
    \ add hl,hl
    \ add hl,de
  h inc  hl incp
    \ inc h
    \ inc hl
  os-seed sthl
    \ ld (seed),hl
  jppushhl   end-code

: zh-random  ( n1 -- n2 )  zh-rnd um* nip  ;

  \ Original code:

  \ ----
  \ PseudoRandWord:
  \
  \ ; this generates a sequence of pseudo-random values
  \ ; that has a cycle of 65536 (so it will hit every
  \ ; single number):
  \
  \ ;f(n+1)=241f(n)+257   ;65536
  \ ;181 cycles, add 17 if called
  \
  \ ;Outputs:
  \ ;     BC was the previous pseudorandom value
  \ ;     HL is the next pseudorandom value
  \ ;Notes:
  \ ;     You can also use B,C,H,L as pseudorandom 8-bit values
  \ ;     this will generate all 8-bit values
  \      .db 21h    ;start of ld hl,**
  \ randSeed:
  \      .dw 0
  \      ld c,l
  \      ld b,h
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,hl
  \      add hl,hl
  \      add hl,hl
  \      add hl,bc
  \      inc h
  \      inc hl
  \      ld (randSeed),hl
  \      ret
  \ ----

need rng-benchmark

: zh-rng-benchmark  ( -- )
  s" Z80 Heaven" ['] zh-random rng-benchmark  ;

( random-byte )

code random-byte  ( -- b )
  ED c, 5F c,     \ ld a,r
  C3 c, pusha ,   \ jp pusha
  end-code

need bench{

: random-byte-test  ( -- )
  ['] random-byte ['] rng defer!  cls  bench{ pixels
  do  rng rng 192 min set-pixel  loop  }bench.
  ." Z80 R register" cr key drop ;

( lcm-random )

  \ XXX UNDER DEVELOPMENT

  \ Credit:
  \
  \ Adapted from code written by Everett F. Carter, published
  \ on Forth Dimensions (volume 16, number 2, page 17,
  \ 1994-08).

need d*  need du/mod  need 2nip

2variable 2seed

2147483647. 2constant max32

  \ Linear Congruential Method, the "minimal standard
  \ generator", Park & Miller, 1988, Comm of the ACM, 31(10),
  \ pp. 1192-1201
: lcm-rnd  ( -- d )
  \ XXX FIXME -- it always returns 0
  2seed 2@ 16807. d*
  max32 du/mod  2nip
  2dup 2seed 2!  ;

  \ \ Original code:
  \ : lcm-rnd  ( -- d )
  \   2seed 2@ 16807. umd*
  \   max32 umd/mod
  \   2drop 2seed 2!  ;

: lcm-random  ( n1 -- n2 )  lcm-rnd d>s um* nip  ;

need rng-benchmark

: lcm-rng-benchmark  ( -- )
  s" LCM" ['] lcm-random rng-benchmark  ;

( all-rng-benchmarks )

  \ Execute all 8-bit RNG benchmarks

need rng-benchmark  need +thru  1 4 +thru

' rng8-benchmark2 ' rng-benchmark defer!

jw-rng-benchmark
mb1-rng-benchmark
mb2-rng-benchmark
zh-rng-benchmark

  \ Execute single-cycle benchmarks of RNG that need more than
  \ one cycle to finish:

' rng8-benchmark1 ' rng-benchmark defer!

jw-rng-benchmark

( jw-crnd )

  \ 2015-12-25

  \ Credit:
  \
  \ http://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random
  \ Joe Wingbermuehle

need os-seed

code jw-crnd  ( -- b )

  os-seed fthl
    \ ld      hl,(randData)
  ED c, 5F c,  a d ld  m e ld
    \ ld      a,r
    \ ld      d,a
    \ ld      e,(hl)
  de addp  l add  h xor
    \ add     hl,de
    \ add     a,l
    \ xor     h
  os-seed sthl
    \ ld      (randData),hl
  pusha jp
    \ jp push_a
  end-code

need rng-benchmark

: jw-rng-benchmark  ( -- )
  s" Joe Wingbermuehle" ['] jw-crnd rng-benchmark  ;

  \ Original code:

  \ ----
  \ ; ouput a=answer 0<=a<=255
  \ ; all registers are preserved except: af
  \ random:
  \         push    hl
  \         push    de
  \         ld      hl,(randData)
  \         ld      a,r
  \         ld      d,a
  \         ld      e,(hl)
  \         add     hl,de
  \         add     a,l
  \         xor     h
  \         ld      (randData),hl
  \         pop     de
  \         pop     hl
  \         ret
  \ ----

( mb1-crandom )

  \ XXX UNDER DEVELOPMENT

  \ 2015-12-25

  \ Credit:
  \ http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#4

   \ This is a very simple linear congruential generator. The
   \ formula is x[i + 1] = (5 * x[i] + 1) mod 256. Its only
   \ advantage is small size and simplicity. Due to nature of
   \ such generators only a couple of higher bits should be
   \ considered random.

  \ Input: none
  \ Output: A = pseudo-random number, period 256

need z80-asm  need os-seed

code mb1-crnd  ( -- b )

  os-seed fta
    \ ld  a,(seed) ; Seed is usually 0
  a d ld  a add  a add  d add
    \  ld  d,a
    \  add  a,a
    \  add  a,a
    \  add  a,d
  a inc  os-seed sta
    \  inc  a    ; another possibility is ADD A,7
    \  ld  (seed),a
  pusha jp
  end-code

: mb1-crandom  ( n1 -- n2 )  mb1-crnd um* nip  ;
  \ XXX FIXME -- it always return zero

need rng-benchmark

  \ : mb1-rng-benchmark  ( -- )
  \   s" Milos Bazelides 1" ['] mb1-crandom rng-benchmark  ;

: mb1-rng-benchmark  ( -- )
  s" Milos Bazelides 1" ['] mb1-crnd rng-benchmark  ;

( mb2-crandom )

  \ XXX UNDER DEVELOPMENT

  \ 2015-12-25

  \ Credit:
  \ http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#4

   \ This is a very simple linear congruential generator. The
   \ formula is x[i + 1] = (5 * x[i] + 1) mod 256. Its only
   \ advantage is small size and simplicity. Due to nature of
   \ such generators only a couple of higher bits should be
   \ considered random.

  \ Input: none
  \ Output: A = pseudo-random number, period 256

need z80-asm  need os-seed

code mb2-crnd  ( -- b )

  os-seed fta
    \ ld  a,(seed) ; Seed is usually 0
  a d ld  a add  a add  d add
    \  ld  d,a
    \  add  a,a
    \  add  a,a
    \  add  a,d
  07 add#  os-seed sta
    \  add a,7
    \  ld  (seed),a
  pusha jp  end-code

: mb2-crandom  ( n1 -- n2 )  mb2-crnd um* nip  ;
  \ XXX FIXME -- it always return zero

need rng-benchmark

  \ : mb2-rng-benchmark  ( -- )
  \   s" Milos Bazelides 2" ['] mb2-crandom rng-benchmark  ;

: mb2-rng-benchmark  ( -- )
  s" Milos Bazelides 2" ['] mb2-crnd rng-benchmark  ;

( zh-crnd )

  \ 2015-12-25

  \ Credit:
  \
  \ Code adapted from:
  \ http://z80-heaven.wikidot.com/math#toc40

code zh-crnd  ( -- b )

  os-seed fta  a e ld
  a add  e add  a add  a add  e add  #83 add#
  os-seed sta
  pusha jp

  end-code

need rng-benchmark

: zh-rng-benchmark  ( -- )
  s" Z80 Heaven (8 bit)" ['] zh-crnd rng-benchmark  ;

  \ This is one of many variations of PRNGs. This routine is
  \ not particularly useful for many games, but is fairly
  \ useful for shuffling a deck of cards. It uses SMC, but that
  \ can be fixed by defining randSeed elsewhere and using ld
  \ a,(randSeed) at the beginning.

  \ PseudoRandByte:
  \ ;f(n+1)=13f(n)+83
  \ ;97 cycles
  \      .db 3Eh     ;start of ld a,*
  \ randSeed:
  \      .db 0
  \      ld c,a
  \      add a,a
  \      add a,c
  \      add a,a
  \      add a,a
  \      add a,c
  \      add a,83
  \      ld (randSeed),a
  \      ret

  \ vim: filetype=soloforth
  \ screen_mode.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that are common to all screen
  \ modes.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( columns rows )

need value

32 value columns  24 value rows

( set-banked-mode-output )

need set-mode-output

0 constant (output-routine)

code (banked-mode-output)  ( -- )
  C5 c,                 \ push bc ; save Forth IP
  CD c, 0 ,             \ call output_routine ; to be patched

  here cell- ' (output-routine) >body !
    \ Store the address where the address of the output routine
    \ must be stored, into the constant `(output-routine)`.

  C1 c,                 \ pop bc ; restore Forth IP
  DD c, 21 c, next ,    \ ld ix,next ; restore IX, just in case
  jpnext  end-code

: set-banked-mode-output  ( a -- )
  (output-routine) !  \ patch `(banked-mode-output)`
  ['] (banked-mode-output) set-mode-output  ;
  \ Associate the output routine at _a_ (which is in the code
  \ bank) to the system channels "K", "S" and "P", using and
  \ intermediate routine to page the code bank in and out.

( set-mode-output set-font )

need os-chars  need os-chans

: set-mode-output  ( a -- )
  os-chans @ 2dup ! 2dup 5 + ! 15 + !  ;

  \ doc{
  \
  \ set-mode-output  ( a -- )
  \
  \ Associate the output routine at _a_ to the system channels
  \ "K", "S" and "P".
  \
  \ }doc
  \ XXX TODO -- why also "P"?

: set-font  ( a -- )  os-chars !  ;

  \ doc{
  \
  \ set-font  ( a -- )
  \
  \ Set the system font to _a_.  This is used by all modes:
  \ `mode32`, `mode42` and `mode64`. The value of _a_ depends
  \ on the mode: In `mode32` and `mode42`, _a_ is the address
  \ of char 0, i.e. 256 bytes below the space char; In `mode64`
  \ _a_ is the address of space char.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ sound.48.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to 48k sound.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( bleep )  \ ==sound48==

  \ Credit:
  \
  \ Code modified from Abersoft Forth.

code bleep  ( duration pitch -- )
  E1 c, D1 c, C5 c,   \ pop hl / pop de / push bc
  CD c, 03B5 ,        \ call rom_beeper
  C1 c,               \ pop bc
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  jpnext              \ jp (ix)
  end-code
  \ Produce a tone in the noise maker.

( beep>bleep )

  \ Credit:
  \
  \ Code from v.Forth.

  \ XXX TODO test

: beep>bleep  ( frequency duration1 -- duration2 pitch )
  over 1000 */ swap
  4375 100 rot */ 30 -  ;
  \ Convert the parameters of the original ZX Spectrum's `beep`
  \ command _frequency duration_ to those required by Solo
  \ Forth's `bleep`.

( laser-gun )

  \ Laser gun sound for ZX Spectrum 48K.

  \ Credit:
  \
  \ Author of the original code: lvaro Corredor Lanas.
  \ Published on Microhobby, issue 126 (1987), page 7:
  \ http://microhobby.org/numero126.htm
  \ http://microhobby.speccy.cz/mhf/126/MH126_07.jpg

need z80-asm

code laser-gun  ( -- )
  bc push
  5 b ld#
  0500 hl ldp#
  begin   0001 de ldp#
          hl push  03B5 call  hl pop  \ ROM beeper
          0010 de ldp#  de subp
          jrnz
  bc pop  next ix ldp#  jpnext
  end-code

( white-noise )

  \ White noise for ZX Spectrum 48K.

  \ Credit:
  \
  \ Author of the original code: Ricardo Serral Wigge.
  \ Published on Microhobby, issue 125 (1987), page 26:
  \ http://microhobby.org/numero125.htm
  \ http://microhobby.speccy.cz/mhf/125/MH125_26.jpg

  \ The original code was called "explosion" and had a fixed
  \ duration of 768 sample bytes, thus equivalent to `768
  \ white-noise`.

need z80-asm

code white-noise  ( u -- )

  \ u = duration in number of sample bytes

  de pop
  bc push  \ save the Forth IP
  de bc ldp  0000 hl ldp#  \ bc=duration, hl=start of ROM

  5C48 fta  a sra  a sra  a sra  07 and#  a d ld
    \ d = border color (in bits 0-2)

  begin   m e ld  hl incp  bc decp  bc push
          08 b ld#  \ bit counter
          begin   e a ld  10 and#  e rl  d or  FE out  \ beep
                  step
          bc pop  bc tstp
          jrnz

  bc pop  jpnext \ restore the Forth IP and go next

  end-code

( ambulance )

  \ Ambulance sound for ZX Spectrum 48K.

  \ Credit:
  \
  \ Author of the original code: Lder Software.
  \ Published on Microhobby, issue 142 (1987-09), page 7:
  \ http://microhobby.org/numero142.htm
  \ http://microhobby.speccy.cz/mhf/142/MH142_07.jpg

need z80-asm

code ambulance  ( n -- )

  \ n = times

  de pop  bc push  e b ld

  begin   bc push  0320 hl ldp#  000A de ldp#
          <mark   hl push
                  03B5 call  \ ROM beeper
                  hl pop  hl decp
                  hl tstp
                  jrnz
          bc pop
          step

  bc pop  next ix ldp#  jpnext

  end-code

  \ vim: filetype=soloforth
  \ strings.escaped.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to escaped strings.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( parse-escaped-string )

only forth definitions
need wid-of  need parse-char
vocabulary escaped-voc
wid-of escaped-voc constant escaped-wordlist
also escaped-voc definitions

  \ The `escaped-voc` vocabulary contains the words whose names
  \ are characters that must be escaped after a backslash.
  \ Their execution returns the new character(s) on the stack
  \ (the first one at the top) and the count.
  \
  \ Most of the escaped chars are translated to one char, so
  \ they are defined as double constants.

7 1 2constant a  8 1 2constant b  27 1 2constant e
  \ \a = backspace
  \ \b = alert
  \ \e = escape
12 1 2constant f  10 1 2constant l  13 1 2constant n
  \ \f = form feed
  \ \l = line feed
  \ \n = new line (implementation dependent)
char " 1 2constant q  13 1 2constant r  9 1 2constant t
  \ \q = double quote
  \ \r = carriage return
  \ \t = horizontal tab
11 1 2constant v  0 1 2constant z
  \ \v = vertical tab
  \ \z = null character
char " 1 2constant "  char \ 1 2constant \
  \ \" = double quote
  \ \\ = backslash

: m  ( -- c1 c2 2 )  10 13 2  ;
  \ \m = carriage return and line feed

: (x)  ( "c" -- n )
  parse-char upper 16 digit? 0= #-260 ?throw  ;
  \ Parse an hex digit and convert it to a number.

: x  ( "cc" -- c 1 )  (x) 16 * (x) + 1  ;
  \ \x = hex character code
  \ Parse the 8-bit hex number of a character code.

-->

( parse-escaped-string )

only forth definitions  need char>string   need search-wordlist
                        need chars>string  need s+

: unescape-char  ( c -- c1..cn n )
  dup char>string escaped-wordlist search-wordlist
  if  nip execute  else  [char] \ 2  then  ;
  \ Translate a escaped char to a number of chars and their
  \ count.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

: parse-escaped-string  ( "ccc<quote>"  -- ca len )
  0 0  \ dummy empty string to start with
  begin  parse-char dup [char] " <>  while  \ not finished?
    dup [char] \ =  \ possibly escaped char?
    if    drop parse-char unescape-char
    else  1  then  chars>string s+
  repeat  drop  ;
  \ Parse a text string delimited by a double quote, using the
  \ translation rules described by Forth-2012's `s\"`, and
  \ returning the string _ca len_ in the circular string
  \ buffer.

( s\" )

need parse-escaped-string

: s\"  ( Interpretation: "ccc<quote>" -- ca len )
       ( Compilation: "ccc<quote>" -- )
       ( Run-time: -- ca len )
  parse-escaped-string compiling? if  postpone sliteral  then
  ; immediate

  \ XXX TODO documentation
  \ doc{
  \
  \ s\"  ( "ccc<quote>"  - ca len )
  \
  \ }doc

( .\" )

need parse-escaped-string

: .\"  ( Compilation: "ccc<quote>" -- )
       ( Run-time: -- ca len )
  compile (.")  parse-escaped-string s,
  ; immediate compile-only

  \ vim: filetype=soloforth
  \ strings.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ String words and tools.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( s= )

: s=  ( ca1 len1 ca2 len2 -- f )  compare 0=  ;

( sconstant )

: sconstant  ( ca len "name" -- )
  here >r s, r> count 2constant  ;

( char>string chars>string )

: char>string  ( c -- ca len )  1 allocate-string tuck c! 1  ;
  \ Convert the char _c_ to a string _ca len_ in the circular
  \ string buffer.

: chars>string  ( c1..cn n -- ca len )
  dup if
    dup allocate-string swap 2dup 2>r  ( c1..cn ca n )
    bounds do  i c!  loop  2r>
  else  pad swap  then  ;
  \ Convert _n_ chars to a string _ca len_ in the circular
  \ string buffer.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

( +place )

  \ Credit:
  \
  \ Code from Afera.

: +place  ( ca1 len1 ca2 )
  2dup c@ + over c!  dup c@ 1+ + smove  ;
  \ Add the string _ca1 len1_ to the end of the counted string
  \ _ca2_.

( s+ )

  \ Credit:
  \
  \ Code adapted from Afera.

[defined] lengths
?\ : lengths   2over nip over  ;
   ( ca1 len1 ca2 len2 -- ca1 len1 ca2 len2 len1 len2 )

: s+  ( ca1 len1 ca2 len2 -- ca3 len3 )
  lengths + >r           ( ca1 len2 ca2 len2 ) ( r: len3 )
  r@ allocate-string >r  ( r: len3 ca3 )
  2 pick r@ +            ( ca1 len1 ca2 len2 len1+ca3 )
  smove                  ( ca1 len1 )  \ 2nd string to buffer
  r@ smove               \  1st string to buffer
  r> r>  ;
  \ Append the string _ca2 len2_ to the end of string _ca1
  \ len1_ returning the string _ca3 len3_ in the circular
  \ string buffer.

( hunt )

  \ Credit:
  \
  \ Code from Wil Baden's Charscan library (2003-02-17),
  \ public domain.

: hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )
  search 0= if  chars + 0  then  ;

  \ doc{
  \
  \ hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )

  \ Search a string _ca1 len1_ for a substring _ca2 len2_.
  \ Return the part of _ca1 len1_ that starts with the first
  \ occurence of _ca2 len2_.
  \
  \ ca1 len1 = string
  \ ca2 len2 = substring
  \ ca3 len3 = ca1+i len1-i
  \
  \ }doc

( #spaces )

need under+

: #spaces  ( ca len -- +n )
  0 rot rot  0 do  count bl = under+  loop  drop abs  ;
  \ Count spaces in a string.

  \ Credit:
  \
  \ Code improved from:
  \ http://forth.sourceforge.net/mirror/comus/index.html

( #chars )

  \ XXX UNDER DEVELOPMENT

: #chars  ( ca len c -- +n )
  0 2swap 0 do
    ( c count ca ) count over = under+  loop  2drop abs  ;
  \ Count spaces in a string.

( /name first-name trim last-name )

  \ Credit:
  \
  \ Code from Galope.

: /name  ( ca1 len1 -- ca2 len2 ca3 len3 )
  \ ca1 len1 = Text.
  \ ca2 len2 = Same text, from the start of its first name.
  \ ca3 len3 = Same text, from the char after its first name.
  bl skip 2dup bl scan  ;

: first-name  ( ca1 len1 -- ca2 len2 )  /name nip -  ;
  \ Get the first name from a string.
  \ A name is a substring separated by spaces.

: trim ( ca1 len1 -- ca2 len2 )  -leading -trailing  ;
  \ Remove leading and trailing spaces from a string.

: last-name  ( ca1 len1 -- ca2 len2 )
  trim
  begin  2dup bl scan bl skip dup
  while  2nip  repeat  2drop  ;
  \ Get the last name from a string.
  \ A name is a substring separated by spaces.

( prefix? suffix? )

need s=  need [if]

  \ Credit:
  \
  \ Code adapted from Galope (module
  \ string-prefix-question.fs).

[needed] prefix? [if]
: prefix?  ( ca1 len1 ca2 len2 -- f ) tuck 2>r min 2r> s=  ;
[then]

  \ Credit:
  \
  \ Code from Galope (module string-suffix-question.fs).

[needed] suffix? [if]
: suffix? ( ca1 len1 ca2 len2 -- wf )
  \ Is string _ca2 len2_ the end of string _ca1 len1_?
  2swap dup 3 pick - /string s=  ;
[then]

( -prefix )

  \ Credit:
  \
  \ Code from Galope (module minus-prefix.fs).

need string-prefix?

: -prefix  ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a prefix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap string-prefix?
  if  swap r@ + swap r> -  else  rdrop  then  ;

( -suffix )

  \ Credit:
  \
  \ Code from Galope (module minus-suffix.fs).

need suffix?

: -suffix ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a suffix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap suffix?
  if  r> -  else  rdrop  then  ;

( ud>str d>str chop )

  \ Credit:
  \
  \ Code from Galope (module ud-to-str.fs).

: ud>str  ( ud -- ca len )  <# #s #>  ;

  \ Credit:
  \
  \ Code from Galope (module d-to-str.fs).

: d>str  ( ud -- ca len )  tuck dabs <# #s rot sign #>  ;

  \ Credit:
  \
  \ Code from Galope (module chop.fs).

: chop  ( ca len -- ca' len' )  1- swap char+ swap  ;
  \ Remove the last character from string _ca len_.

( save-counted-string )

: save-counted-string  ( ca1 len1 -- ca2 )
  dup 1+ allocate-string dup >r place r>  ;

  \ doc{

  \ save-counted-string  ( ca1 len1 -- ca2 )

  \ Save the string _ca1 len1_ in the circular string buffer as
  \ a counted string and return its new address _ca2_.

  \ }doc

  \ system_variables.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Constants for the system variables.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( os-chars os-chans os-flags2 os-seed os-frames os-udg )

[unneeded] os-chars    ?\ 23606 constant os-chars
  \ 1 cell:
  \ address of character 0 of the font (actual characters 32..127)

[unneeded] os-chans    ?\ 23631 constant os-chans
  \ 1 cell:
  \ address of the channels

[unneeded] os-flags2   ?\ 23658 constant os-flags2
  \ 1 byte:
  \ several flags

[unneeded] os-seed     ?\ 23670 constant os-seed
  \ 1 cell:
  \ seed of the random number generator

[unneeded] os-frames   ?\ 23672 constant os-frames
  \ 3 bytes:
  \ 24-bit counter of frames (1 frame = 20 ms)

[unneeded] os-udg      ?\ 23675 constant os-udg
  \ 1 cell:
  \ address of the User Defined Graphics (characters 128..255)

  \ vim: filetype=soloforth
  \ time.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to time.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( ms )  \ ==time==

need os-frames

: ms  ( u -- )
  \ Wait _u_ ms (miliseconds), with 20 ms precision.
  20 / os-frames @ +
  begin  dup os-frames @ u<  until drop  ;

  \ doc{
  \
  \ ms  ( u -- )
  \
  \ Origin: Forth-94 (FACILITY EXT), Forth-202 (FACILITY
  \ EXT).
  \
  \ }doc

  \ XXX TODO
  \ Adapt this better version from v.Forth:
  \
  \ code ms
  \  pop de
  \  begin,
  \   ld a,171
  \   begin,
  \    nop
  \    dec a
  \   -until,
  \   dec de
  \   ld a,d
  \  ora e
  \  -until,
  \  jp (ix)

  \ Version from Spectrum Forth-83:
  \ : ms  ( u -- )  20 /mod pause 0 ?do 10 0
  \   do loop loop  ;

  \ Version from DZX-Forth (for 8080):
  \ code ms  ( u -- )  hex
  \   d1 c,         \ pop de
  \   here          \ ms1:
  \   78 03 + c,  B0 02 + c,
  \                 \ ld a,e
  \                 \ or d
  \   ca c, next ,  \ jp z,next
  \   21 c, 0004 ,  \ ld hl,4 ; mhz
  \   29 c,  29 c,  29 c,
  \                 \ add hl,hl
  \                 \ add hl,hl
  \                 \ add hl,hl
  \   here          \ ms2:
  \   e3 c,  e3 c,  e3 c,  e3 c,
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \   e5 c,  e1 c,  2B c,
  \                 \ push hl           ; 11t
  \                 \ pop hl            ; 10t
  \                 \ dec hl            ;  6t
  \   3E c, 00 c,  78 05 + c,  B0 04 + c,
  \                 \ ld a,0            ;  7t
  \                 \ ld a,l            ;  4t
  \                 \ or h              ;  4t
  \   c2 c, ,       \ jp nz,ms2         ; 10t
  \   1B c,         \ dec de
  \   c3 c, ,       \ jp ms1
  \ end-code

( ms88 )

  \ XXX TODO
  \ XXX version of `ms` adapted from Z88 CamelForth
  \ XXX UNDER DEVELOPMENT

  \ Original:
  \
    \ defw PAUSE  ; allow other tasks to run
  \ .stMS:
    \ defw stMS+2
    \ ld l,10    ; only run other tasks every 10ms
  \ .reMS:
    \ ld a,b
    \ or c
    \ jr z,endMS
    \ push bc
    \ ld bc,133
  \ .reMS2:
    \ dec bc
    \ ld a,b
    \ or c
    \ jr nz,reMS2
    \ pop bc
    \ dec bc
    \ dec l
    \ jr nz,reMS
    \ ld de,stMS
    \ jp PAUSE  ; allow other tasks to run
  \ .endMS  pop bc          ; get new TOS
    \ jp EXIT

need z80-asm
code ms88  ( u -- )
  de pop
    \ ld l,10    ; only run other tasks every 10ms
  begin \ .reMS:

  d a ld
  e or nz if

    de push \ push bc
    #133 de ldp#
    begin  \ .reMS2:
      dec decp  d a ld  e or
    z until \ jr nz,reMS2
    de pop \ pop bc
    de decp  l dec
 z until \ jr nz,reMS
    \ ld de,stMS
    \ jp PAUSE  ; allow other tasks to run
  \ .endMS
  then  jpnext  end-code

( frames@ frames! reset-frames )

need os-frames

: frames@  ( -- d )
  os-frames @ [ os-frames 2+ ] literal c@  ;
  \ System frames counter (incremented every 20 ms).

: frames!  ( d -- )
  [ os-frames 2+ ] literal c! os-frames !  ;
  \ Set the system frames counter.

: reset-frames  ( -- )  0. frames!  ;
  \ Reset the system frames counter.

( pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a user variable, and it's executed
  \ to get its current adress.

need z80-asm  need call-xt  need execute-hl

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    \ XXX FIXME -- crash -- why this does not work?:
    ' (wait) call-xt  hl pop  execute-hl
      \ execute the xt hold in the user variable `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a deferred word.

need z80-asm  need call-xt

defer (wait)  ' noop ' (wait) defer!

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    ' (wait) call-xt
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a user variable, but its current
  \ address is compiled, what is wrong.

need z80-asm  need execute-hl

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    (wait) fthl  execute-hl
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ XXX OLD

  \ Variant: `(wait)` is a variable.

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

need z80-asm  need execute-hl

variable (wait)  ' noop (wait) !

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    ' (wait) >body fthl  execute-hl
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ XXX OLD

  \ Variant: `(wait)` is a variable and the calling is not
  \ factored.

need z80-asm  need execute-hl

variable (wait)  ' noop (wait) !

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push

    \ Call the xt hold in `(wait)`:

    ' (wait) >body fthl execute-hl

    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

  \ XXX NOTE -- adapt `pause` to DTC, needed?

( just-pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

need z80-asm

code just-pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( leapy-year? )

  \ 2015-11-15

  \ Credit:
  \
  \ Code written by Wil Baden, published on Forth Dimensions
  \ (volume 8, number 5, page 31, 1987-01).

: leapy-year?  ( n -- f )
  dup 400 mod 0= if  drop true   exit  then
  dup 100 mod 0= if  drop false  exit  then
        4 mod 0= if       false  exit  then
  false  ;

exit

  \ Alternative.

need baden-case

: leapy-year?  ( n -- f )
  case 400 mod 0= of  true   endof
  case 100 mod 0= of  false  endof
  case   4 mod 0= of  true   endof
  othercase false  ;

( set-date get-date )

create (date)  1 c,  1 c,  2016 ,
  \ day, month, year

: get-date  ( -- day month year )
  (date) c@
  [ (date) 1+ ] literal c@
  [ (date) 2+ ] literal @  ;

  \ doc{
  \
  \ get-date  ( -- day month year )
  \
  \ Get the current date. The default date is 2016-01-01. It
  \ can be changed with `set-date`. The date is not updated by
  \ the system.
  \
  \ }doc

: set-date  ( day month year -- )
  [ (date) 2+ ] literal !
  [ (date) 1+ ] literal c!
  (date) !  ;

  \ doc{
  \
  \ set-date  ( day month year -- )
  \
  \ Set the current date. The default date is 2016-01-01. It
  \ can be fetch with `get-date`. The date is not updated by
  \ the system.
  \
  \ }doc

( set-time get-time reset-time )

need frames@  need frames!  need m+  need alias  need ud*

: get-time  ( -- second minute hour )
  frames@ 50 um/mod nip s>d   ( sec . )
          60 um/mod s>d       ( sec min . )
          60 um/mod           ( sec min hour )  ;

  \ doc{
  \
  \ get-time  ( -- second minute hour )
  \
  \ Return the current time.
  \
  \ The system doesn't have an actual clock. The system frames
  \ counter is used instead. It is increased by the interrupts
  \ routine every 20th ms. The counter is a 24-bit value, so
  \ its maximum is $FFF ticks of 20 ms (5592 minutes, 93
  \ hours), then it starts again from zero.
  \
  \ }doc

: set-time  ( second minute hour -- )
  3600 um*  rot 60 * m+  rot m+  ( seconds )
  50. ud* frames!  ;

  \ doc{
  \
  \ set-time  ( second minute hour -- )
  \
  \ Set the current time. See `get-time`.
  \
  \ }doc

' reset-frames alias reset-time  ( -- )

  \ doc{
  \
  \ reset-time  ( -- )
  \
  \ Reset the current time to 00:00:00. See `get-time`.
  \
  \ }doc

( .time .system-time .date .system-date .time&date time&date )

  \ XXX TODO document

need get-time  need get-date

: .00  ( n -- )  s>d <# # # #> type  ;
: .0000  ( n -- )  s>d <# # # # # #> type  ;

: .time  ( second minute hour -- )
  .00 ':' emit .00 ':' emit .00  ;

: .system-time  ( -- )  get-time .time  ;

: .date  ( day month year -- )
  .0000 '-' emit .00 '-' emit .00  ;

: .system-date  ( -- )  get-date  .date  ;

: .time&date  ( second minute hour day month year -- )
  .date 'T' emit .time  ;

: time&date  ( -- second minute hour day month year )
  get-time get-date  ;

  \ doc{
  \
  \ time&date  ( -- second minute hour day month year )
  \
  \ Return the current time and date: second (0..59), minute
  \ (0..59), hour (0..23), day (1..31), month (1..12) and year
  \ (e.g., 2016).
  \
  \ See: `get-time`, `get-date`, `set-time`, `set-date`.
  \
  \ Origin: Forth-94 (FACILITY EXT), Forth-201 (FACILITY
  \ EXT).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ tools.listing.blocks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words to list blocks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( list )

need .line  need nuf?

: list  ( n -- )

  \ List block number _n_.

  dup scr !
  cr ." Scr # " .
  l/scr 0 do
    cr i 2 .r space i scr @ .line
    nuf? ?leave
  loop cr  ;

( index .index )

need .line  need nuf?

: .index  ( n -- )  cr dup 3 .r space 0 swap .line  ;
  \ Print the first line of the block _n_.

: index  ( n1 n2 -- )

  \ doc{
  \
  \ index  ( n1 n2 -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_.
  \
  \ }doc

  1+ swap do
    cr i 3 .r space 0 i .line  nuf? ?leave
  loop  ;

( index-like )

need .index  need nuf?

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-like  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-like  ( n1 n2 "name" -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-sensitive.
  \
  \ }doc

  parse-name 2swap
  1+ swap do
    0 i line>string 2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;

( index-ilike )

need .index

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-ilike  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-ilike  ( n1 n2 "name" -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-insensitive.
  \
  \ }doc

  parse-name save-string 2dup uppers
  2swap 1+ swap do
    save-string  0 i line>string save-string 2dup uppers
    2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;

  \ Note: The parsed string is re-saved to the circular string
  \ buffer in every iteration in order to prevent it from being
  \ overwritten by the strings of the index lines, because the
  \ circular string buffer is small.

  \ vim: filetype=soloforth
  \ value.double.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `2to` for a non-standard version of
  \ `2value`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( 2value 2to )

  \ Implementation of `2value` (from Forth-2012) but with
  \ the non-standard word `2to`

: 2value  ( d "name"  -- )  2constant  ;

: 2to  ( Interpretation: d "name" -- )
       ( Compilation: "name" -- )
  ' >body compiling? if    postpone literal postpone 2!
                     else  2!  then  ; immediate

  \ vim: filetype=soloforth
  \ value.forth-94.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The Forth-94 version of `value`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( value to )

  \ Origin: Forth-94.

: value  ( n "name"  -- )  constant  ;

: to  ( Interpretation: n "name" -- )
      ( Compilation: "name" -- )
  ' >body compiling? if    postpone literal postpone !
                     else  !  then  ; immediate

  \ vim: filetype=soloforth
  \ word_lists.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201603252323

  \ -----------------------------------------------------------
  \ Description

  \ Words related to word lists.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( wid>link wid>name named-wid wid>vocabulary )

  \ XXX TODO -- test

need alias

' cell+ alias wid>link  ( wid -- a )

: (wid>name)  ( wid -- a )  [ 2 cells ] literal +  ;

  \ doc{
  \
  \ (wid>name)  ( wid -- a )
  \
  \ Return the address _a_ which holds the _nt_ of _wid_ (or
  \ zero if the word list has no associated name).
  \
  \ }doc

: wid>name  ( wid -- nt|0 )  (wid>name) @  ;

  \ doc{
  \
  \ wid>name  ( wid -- nt|0 )
  \
  \ Return the _nt_ of _wid_ (or zero if the word list has no
  \ associated name).
  \
  \ }doc

: named-wid ( wid -- )  (wid>name) latest swap !  ;

  \ doc{
  \
  \ named-wid ( wid -- )
  \
  \ Associate the latest name to _wid_.
  \
  \ }doc

: wid>vocabulary  ( wid "name" -- )
  create dup , named-wid
  does>  ( -- )  ( pfa )  @ context !  ;

  \ doc{
  \
  \ wid>vocabulary  ( wid "name" -- )
  \
  \ Create a vocabulary "name" for the _wid_ word list.
  \
  \ }doc

( get-order order@ )

  \ Credit: Code from eForth.

: order@  ( a -- u*wid u )
  dup @ dup if    >r cell+  recurse  r> swap 1+ exit
            then  nip  ;
  \ XXX TODO use the actual number of vocs in context,
  \ not a trailing zero

: get-order  ( -- u*wid u )  context order@ ;

( wid-of )

  \ Credit:
  \
  \ Adapted from eForth's `widof`.

: wid-of  ( "name" -- wid )  ' >body  ;
  \ Return the _wid_ of vocabulary "name".

( swap-current trail )

[unneeded] trail
?\ : trail  ( -- nt )  context @ @  ;

  \ doc{
  \
  \ trail ( -- nt )
  \
  \ Leave the _nt_ of the topmost word in the
  \ `context` vocabulary.
  \
  \ }doc

[unneeded] swap-current ?\ exit
: swap-current  ( wid1 -- wid2 )
  get-current swap set-current  ;

  \ Credit:
  \
  \ Idea from lpForth.

( find-name-in find )

: find-name-in  ( ca len wid -- nt | 0 )  @ find-name-from  ;

  \ doc{
  \
  \ find-name-in  ( ca len wid -- nt | 0 )
  \
  \ Find the definition named in the string at _ca len_, in
  \ word list _wid_. If the definition is found, return its
  \ _nt_, else return zero.
  \
  \ The search is case-sensitive.
  \
  \ }doc

: find  ( ca -- ca 0 | xt 1 | xt -1 )
  dup count find-name dup
  if  nip name>immediate? 1 or negate  then  ;

  \ doc{
  \
  \ find  ( ca -- ca 0 | xt 1 | xt -1 )
  \
  \ Find the definition named in the counted  string at _ca_.
  \ If the definition is  not found, return _ca_ and zero. If
  \ the definition is found, return its execution token _xt_.
  \ If the definition  is immediate,  also  return one  (1),
  \ otherwise  also  return minus-one (-1).
  \
  \ Origin: Forth-83 (Required word set), Forth-94 (CORE,
  \ SEARCH), Forth-2012 (CORE, SEARCH).
  \
  \ }doc

( nuclear-invaders )

  \ XXX UNDER DEVELOPMENT

\ Version 0.0.0+201603260017

\ Description

\ This game is a ZX Spectrum port (for Solo Forth:
\ http://programandala.net/en.program.solo_forth.html) of a
\ game written by Dancresp in 2013 for Jupiter ACE
\ (http://www.zonadepruebas.com/viewtopic.php?t=4231).

  \ This version:
\ Copyright (C) 2016 Marcos Cruz (programandala.net)

  \ Original version:
\ Copyright (C) 2013 Scainet Soft

\ License

\ You may do whatever you want with this work, so long as you
\ retain the copyright/authorship/acknowledgment/credit
\ notice(s) and this license in all redistributed copies and
\ derived works.  There is no warranty.

  \ History: see at the end of the file.

-->

( Requirements)

only forth definitions

  \ From the library of Solo Forth

need roll      need inkey   need bleep        need beep>bleep
need os-chars  need os-udg  need 2/           need abort"
need value     need case    need random       need columns
need rows      need ocr     need ms           need s+
need 2value    need row     need char>string  need s\"
need alias     need plot    need adraw

4 constant /kk
need kk-ports  need kk-1#   need pressed?     need kk-chars

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

need defer
need :noname  need benched    need ~~   13 ~~key !
  \ XXX TMP -- during the development

-->

( Debug tools)

defer (debug-point)  ' noop ' (debug-point) defer!

: debug-point  ( -- )
  (debug-point)
  \ latest .name
  depth abort" Stack is not empty"
  \ ." blk " blk @ .
  \ key drop
  ;
  \ Abort if the stack is not empty.
  \ XXX TMP -- for debugging

-->

( Screen) debug-point

16384 constant sys-screen  6912 constant /sys-screen
                           6144 constant /sys-screen-bitmap
  \ Address and size of the screen.
  \ XXX TODO -- not used yet

22528 constant attributes  768 constant /attributes
  \ Address and size of the screen attributes.
  \ XXX TODO -- not used yet


     2 constant arena-top-y
    21 constant tank-y
tank-y constant arena-bottom-y
    23 constant status-bar-y
  \ XXX TMP --
  \ XXX TODO --

-->

( Colors) debug-point

0 constant black    1 constant blue   2 constant red
3 constant magenta  4 constant green  5 constant cyan
6 constant yellow   7 constant white

: papery   ( color -- paper-attribute )           8 *  ;
: brighty  ( attribute -- brighty-attribute )   64 or  ;
: flashy   ( attribute -- flashy-attribute )   128 or  ;

-->

( Colors) debug-point

  \ XXX TODO -- move to the library of Solo Forth.

: set-color  ( b -- )  23695 c!  ;
  \ Set the attribute _b_ as the current color, by modifying
  \ the system variable ATTR T (temporary attributes).

: color  ( b "name" -- )
  create c,  does> ( -- )  ( pfa ) c@ set-color  ;
  \ Create a word "name" that will set attribute _b_ as the
  \ current color.

-->

( Colors) debug-point

              white color text-color
              black color arena-color
 white papery red + color brick-color
       blue brighty color tank-color
               blue color life-color
              green color invader-color
     yellow brighty color container-color
             yellow color projectile-color
            magenta color ufo-color

: init-colors  ( -- )
  0 paper 7 ink 0 flash 0 bright 0 inverse 1 border  ;
  \ XXX TMP --

-->

( Variables) debug-point

variable tank-x        \ column
variable projectile-x  \ column
variable projectile-y  \ row, 0 if no shoot
variable ufo-x         \ column
variable lifes         \ counter (0..3)
variable level         \ counter (1..5)
variable score         \ counter
variable record        \ max score
variable invaders      \ counter (all units of every type)
variable invader-type  \ element of table  (0..9)
variable catastrophe   \ flag (game end condition)

record off

-->

( Keyboard) debug-point

13 constant enter-key

0 value kk-left#    0 value kk-right#    0 value kk-fire#
0. 2value kk-left   0. 2value kk-right   0. 2value kk-fire

: wait  ( -- )  begin  inkey  until  ;
  \ Wait until any key is pressed.

: enter-key?  ( -- f )  inkey enter-key =  ;
  \ Is the Enter key pressed?

: wait-for-enter  ( -- )  begin  enter-key?  until  ;
  \ Wait until the Enter key is pressed.

-->

( kk#>c kk#>string )

: kk#>c  ( n -- c )  kk-chars + c@  ;
  \ Convert key number _n_ to its char _c_.

  \ : .kk#  ( n -- )
  \   case  kk-en# of  ." Enter"         endof
  \         kk-sp# of  ." Space"         endof
  \   \      kk-cs# of  ." Caps Shift"    endof  \ XXX OLD
  \   \      kk-ss# of  ." Symbol Shift"  endof  \ XXX OLD
  \         dup kk#>c upper emit  \ default
  \   endcase  ;
  \ Print the name of key number _n_.
  \ XXX OLD

: kk#>string  ( n -- ca len )
  case  kk-en# of  s" Enter"         endof
        kk-sp# of  s" Space"         endof
  \      kk-cs# of  s" Caps Shift"    endof  \ XXX OLD
  \      kk-ss# of  s" Symbol Shift"  endof  \ XXX OLD
        dup kk#>c upper char>string rot  \ default
  endcase  ;

-->

( controls )

3 constant /controls
  \ Bytes per item in the `controls` table.

create controls  here
  \ left      right     fire
    kk-5# c,  kk-8# c,  kk-en# c,   \ cursor with Enter
    kk-r# c,  kk-t# c,  kk-en# c,   \ Spanish Dvorak keyboard
    kk-z# c,  kk-x# c,  kk-en# c,   \ from the original game
    kk-5# c,  kk-8# c,  kk-0#  c,   \ cursor joystick
    kk-5# c,  kk-8# c,  kk-sp# c,   \ cursor with Space
    kk-1# c,  kk-2# c,  kk-5#  c,   \ Sinclair joystick 1
    kk-6# c,  kk-7# c,  kk-0#  c,   \ Sinclair joystick 2
    kk-o# c,  kk-p# c,  kk-q#  c,   \ QWERTY
    kk-n# c,  kk-m# c,  kk-q#  c,   \ QWERTY
    kk-q# c,  kk-w# c,  kk-p#  c,   \ QWERTY
    kk-z# c,  kk-x# c,  kk-p#  c,   \ QWERTY

here swap - /controls / constant max-controls
  \ Number of controls stored in `controls`.

max-controls 1- constant last-control  -->

( next-controls )

: >controls  ( n -- a )  /controls * controls +  ;
  \ Convert controls number _n_ to their address _a_.

: #>kk  ( n -- d )  /kk * kk-ports + kk@  ;
  \ Convert keyboard key number _n_ to its data _d_ (bitmap and
  \ port).

: set-controls  ( n -- )
  >controls     dup c@  dup to kk-left#   #>kk 2to kk-left
             1+ dup c@  dup to kk-right#  #>kk 2to kk-right
             1+     c@  dup to kk-fire#   #>kk 2to kk-fire  ;
  \ Make controls number _n_ (item of the `controls` table) the
  \ current controls.

variable current-controls
  \ Index of the current controls in `controls` table.

current-controls off
current-controls @ set-controls
  \ Default controls.

: next-controls  ( -- )
  current-controls @ 1+  dup last-control > 0= abs *
  dup current-controls !  set-controls  ;
  \ Change the current controls.

-->

( beep ) debug-point

: beep  ( n1 n2 -- )  beep>bleep bleep  ;
  \ XXX TMP -- compatibility layer for the original code
  \ XXX TODO -- adapt the original beeps

-->

( udg-set udg>bitmap >scan scan! ) debug-point

        $80 constant first-udg  \ first UDG code in Solo Forth
        $FF constant last-udg   \ last UDG code in Solo Forth

        128 constant udgs       \ number of UDGs \ XXX TMP --
          8 constant /udg       \ bytes per UDG
udgs /udg * constant /udg-set   \ size of the UDG set in bytes

create udg-set /udg-set allot

udg-set os-udg !
  \ Point system UDG to the game UDG set.
  \ Solo Forth will use this set for chars 128..255.

: udg>bitmap  ( c -- a )  first-udg - /udg * udg-set +  ;
  \ Convert UDG char _c_ to the address _a_ of its bitmap.

: >scan  ( n c -- a )  udg>bitmap +  ;
  \ Convert scan number _n_ of UDG char _c_ to its address _a_.

: scan!  ( c b n -- c )  rot >scan c!  ;
  \ Store scan _b_ into scan number _n_ of char _c_,
  \ and return _c_ back for further processing.

variable used-udgs  used-udgs off
  \ Counter of UDGs defined.

: ?free-udg  ( n -- )
  used-udgs +!  used-udgs @ udgs > abort" Too many UDGs"  ;
  \ Abort if there is not free space for _n_ UDGs?
  \ This is a check done during the interpretation of the
  \ source file.

-->

( font! font@ rom-font ) debug-point

: font!  ( a -- )  os-chars !  ;
  \ Set the current charset to address _a_
  \ (the bitmap of char 0).
  \ XXX OLD

: font@  ( -- a )  os-chars @  ;
  \ Fetch the address _a_ of the current charset
  \ (the bitmap of char 0).
  \ XXX OLD

variable ocr-first-udg
variable ocr-last-udg
  \ Char codes of the first and last UDG to be examined
  \ by `ocr`.

: init-ocr  ( -- )
  ocr-first-udg @ udg>bitmap ocr-charset !
    \ Set address of the first char bitmap to be examined.
  ocr-first-udg @ ocr-first !
    \ Its char code in the UDG set.
  ocr-last-udg @ ocr-first-udg @ - 1+ ocr-chars !  ;  \ chars
  \ Set the UDGs `ocr` will examine te detect collisions.
  \ Set the address of the first char bitmap to be
  \ examined, its char code and the number of examined chars.
  \ XXX TODO -- range: only chars that may be detected: brick
  \ and invaders.

: rom-font  ( -- )  15360 font!  ;
  \ Set ROM font for chars 0..127
  \ (in Solo Forth chars 128..255 are UDG).
  \ XXX OLD

-->

( ~~ )

  \ Configure the debugging tool `~~`, in order to activate the
  \ ROM font before printing the debug information, and restore
  \ the previous font at the end.

warnings @  warnings off

variable ~~base

: ~~(  ( -- )  base @ ~~base ! decimal  ;

: ~~)  ( -- )  ~~base @ base !  ;

: ~~  ( -- )
  postpone ~~( postpone ~~  postpone ~~)  ; immediate

~~? off

warnings !

: XXX  ( -- )
  ~~? on
  base @ >r decimal latest .name .s r> base !
  key drop ;

-->

( .score .record update-score  ) debug-point

 1 constant score-y
14 constant record-x

variable players  1 players !  \ XXX TODO -- not used yet
variable player   1 player !   \ XXX TODO -- not used yet

: score-x  ( -- x )  3 player @ 1- 22 * +  ;
  \ Column of the score of the current player.

: (.score)  ( n x y -- )
  at-xy s>d <# # # # # #> text-color type  ;
  \ Print score _n_ at coordinates _x y_.

: score-xy  ( -- x y )  score-x score-y  ;
  \ Coordinates of the score.

: at-score  ( -- )  score-xy at-xy  ;
  \ Set the cursor position at the score.

: .score  ( -- )  score @ score-xy (.score)  ;
  \ Print the score.

: .record  ( -- )  record @ record-x score-y (.score)  ;
  \ Print the record.

: update-score  ( n -- )  score +! .score  ;

-->

( latest-sprite-width latest-sprite-height )

    variable >udg  first-udg >udg !  \ next free UDG

variable latest-sprite-width
variable latest-sprite-height
variable latest-sprite-udg

: ?udg  ( c -- )  last-udg > abort" Too many UDGs"  ;
  \ Abort if UDG _n_ is too high.
  \ XXX TMP -- during the development

: free-udg  ( n -- c )
  >udg @ dup latest-sprite-udg !
  tuck +  dup >udg !  1- ?udg  ;
  \ Free _n_ consecutive UDGs and return the first one _c_.

: latest-sprite-size!  ( width height -- )
  latest-sprite-height !  latest-sprite-width !  ;
  \ Update the size of the latest sprited defined.

-->

( sprite-string )

: ?sprite-height  ( -- )
  latest-sprite-height @ 1 >
  abort" Sprite height not supported for sprite strings"  ;

: sprite-string  ( "name" -- )
  ?sprite-height
  here latest-sprite-udg @  latest-sprite-width @ dup >r
  0 ?do  dup c, 1+  loop  drop  r> 2constant  ;
  \ Create a definition "name" that will return a string
  \ containing all UDGs of the lastest sprite defined.
  \ XXX TODO --

-->

( 1x1sprite! 1x1sprite )

: (1x1sprite!)  ( b0..b7 c -- )
  1 ?free-udg  1 1 latest-sprite-size!
  /udg 0 do
    dup /udg 1+ i - roll i scan!
  loop  drop  ;
  \ Store a 1x1 UDG sprite into UDG _c_.

: 1x1sprite!  ( b0..b7 -- )
  1 free-udg (1x1sprite!)  ;
  \ Store a 1x1 UDG sprite into the next available UDG.

: 1x1sprite  ( n0..n7 "name" -- )
  1 free-udg dup constant (1x1sprite!)  ;

 ' emit alias .1x1sprite   ( c -- )
' emits alias .1x1sprites  ( c n -- )

-->

( 2x1sprite! 2x1sprite )

: (2x1sprite!)  ( n0..n7 c -- )
  2 ?free-udg  2 1 latest-sprite-size!
  /udg 0 do
    dup /udg 1+ i - pick flip i scan! 1+  \ first UDG
    dup /udg 1+ i - roll      i scan! 1-  \ second UDG
  loop  drop  ;
  \ Store a 2x1 UDG sprite into chars _c_ and _c_+1.
  \ Scans _n0..n7_ are 16-bit: high part is char _c_,
  \ and low part is _c_+1.

: 2x1sprite!  ( n0..n7 -- )
  2 free-udg (2x1sprite!)  ;
  \ Store a 2x1 UDG sprite into the next two available UDGs.
  \ Scans _n0..n7_ are 16-bit: high part is char _c_, and low
  \ part is _c_+1.

: 2x1sprite  ( n0..n7 "name" -- )
  2 free-udg dup constant (2x1sprite!)  ;

: .2x1sprite  ( c -- )  dup emit 1+ emit  ;

-->

( invader-1 invader-1$ ) debug-point

2 constant udg/invader

>udg @ ocr-first-udg !
  \ The first UDG examined by `ocr` must be the first one of
  \ the next sprite.

binary

  \ invader 1, frame 1
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000011001100000
0000110110110000
0011000000001100

2x1sprite invader-1
sprite-string invader-1$  ( -- ca len )

decimal  -->

( invader-1 ) debug-point

binary

  \ invader 1, frame 2
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000111001110000
0001100110011000
0001100000011000

2x1sprite!

decimal  -->

( invader-1 ) debug-point

binary

  \ invader 1, frame 3
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000111001110000
0001100110011000
0000110000110000

2x1sprite!

decimal  -->

( invader-1 ) debug-point

binary

  \ invader 1, frame 4
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000111001110000
0001100110011000
0001100000011000

2x1sprite!

decimal  -->

( invader-2 invader-2$ ) debug-point

binary

  \ invader 2, frame 1
0000100000100000
0000010001000000
0000111111100000
0001101110110000
0011111111111000
0011111111111000
0010100000101000
0000011011000000

2x1sprite invader-2
sprite-string invader-2$  ( -- ca len )

decimal  -->

( invader-2 ) debug-point

binary

  \ invader 2 , frame 2
0000100000100000
0000010001000000
0000111111100000
1111101110111110
0011111111111000
0001111111110000
0000100000100000
0001000000010000

2x1sprite!

decimal  -->

( invader-2 ) debug-point

binary

  \ invader 2 , frame 3
0000100000100000
0010010001001000
0010111111101000
0011101110111000
0011111111111000
0001111111110000
0000100000100000
0001000000010000

2x1sprite!

decimal  -->

( invader-2 ) debug-point

binary

  \ invader 2 , frame 4
0000100000100000
0000010001000000
0000111111100000
1111101110111110
0011111111111000
0001111111110000
0000100000100000
0001000000010000

2x1sprite!

decimal  -->

( invader-3 invader-3$ ) debug-point

binary

  \ invader 3, frame 1
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000001001000000
0000010110100000
0000101001010000

2x1sprite invader-3
sprite-string invader-3$  ( -- ca len )

decimal  -->

( invader-3 ) debug-point

binary

  \ invader 3, frame 2
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000010110100000
0000100000010000
0000100000010000

2x1sprite!

decimal  -->

( invader-3 ) debug-point

binary

  \ invader 3, frame 3
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000010110100000
0000100000010000
0000010000100000

2x1sprite!

decimal  -->

( invader-3 ) debug-point

binary

  \ invader 3, frame 2
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000010110100000
0000100000010000
0000100000010000

2x1sprite!

decimal  -->

( ufo ufo$ ) debug-point

binary

  \ ufo, frame 1
0000000000000000
0000011111100000
0001111111111000
0011111111111100
0110110110110110
1111111111111111
0011100110011100
0001000000001000

2x1sprite ufo
sprite-string ufo$  ( -- ca len )

decimal  -->

( ufo ) debug-point

binary

  \ ufo, frame 2
0000000000000000
0000011111100000
0001111111111000
0011111111111100
0011011011011010
1111111111111111
0011100110011100
0001000000001000

2x1sprite!

decimal  -->

( ufo ) debug-point

binary

  \ ufo, frame 3
0000000000000000
0000011111100000
0001111111111000
0011111111111100
0101101101101100
1111111111111111
0011100110011100
0001000000001000

2x1sprite!

decimal  -->

( ufo ) debug-point

binary

  \ ufo, frame 4
0000000000000000
0000011111100000
0001111111111000
0011111111111100
0010110110110110
1111111111111111
0011100110011100
0001000000001000

2x1sprite!

decimal  -->

( brick ) debug-point

binary

11111011
11111011
11111011
00000000
11011111
11011111
11011111
00000000

1x1sprite brick

>udg @ 1- ocr-last-udg !
  \ The last UDG examined by `ocr` must be the last one
  \ of the latest sprite.

decimal  -->

( broken-top-brick ) debug-point

  \ This UDG is used with reversed colors, depending on

binary

11111111
11111111
11111000
11111100
11100100
10000000
00000000
00000000

1x1sprite broken-top-brick

decimal  -->

( broken-bottom-brick ) debug-point

binary

00000000
10000000
10100000
11100100
11111100
11111000
11111101
11111111

1x1sprite broken-bottom-brick

decimal  -->

( tank$ ) debug-point

2 constant udg/tank

binary

  \ XXX TODO -- second frame

0000000100000000
0000001110000000
0000001110000000
0111111111111100
1111111111111110
1111111111111110
1111111111111110
1111111111111110

2x1sprite!
sprite-string tank$  ( -- ca len )

decimal  -->

( invader-explosion$ ) debug-point

binary

0000010001000000
0010001010001000
0001000000010000
0000100000100000
0110000000001100
0000010000100000
0001001010010000
0010010001001000

2x1sprite!
sprite-string invader-explosion$  ( -- ca len )

decimal  -->

( projectile ) debug-point

binary

00000000
00000001
00000001
00000001
00000001
00000001
00000000
00000000

1x1sprite projectile

decimal  -->

( ufo-explosion$ ) debug-point

binary

0000000000000010
0010000001100100
0100011111110000
0000111111111010
0001111011011001
0100110011110000
1000011111000100
0010001100010010

2x1sprite!
sprite-string ufo-explosion$  ( -- ca len )

decimal  -->

( ruler ) debug-point

binary

  \ horizontal ruler
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000000

1x1sprite ruler

decimal  -->

( container-top ) debug-point

binary

0000001111100000
0001110000011100
0010001111100010
0010000000000010
0010000111000010
0010001111100010
0010000111000010
0010000010000010

2x1sprite container-top

decimal  -->

( broken-top-left-container ) debug-point

binary

00000000
00011100
00100010
00100010
00100010
00100001
00100001
00100001

1x1sprite broken-top-left-container

decimal  -->

( broken-top-right-container) debug-point

binary

00000000
00011100
00100010
00100010
01000010
01000010
01000010
10000010

1x1sprite broken-top-right-container

decimal  -->

( container-bottom ) debug-point

binary

0010010101010010
0010111101111010
0010111000111010
0010011000110010
0010000000000010
0001110000011100
0000001111100000
0000000000000000

2x1sprite container-bottom

decimal  -->

( broken-bottom-left-container) debug-point

binary

00000001
00000111
00011110
00100110
00100000
00011100
00000011
00000000

1x1sprite broken-bottom-left-container

decimal  -->

( broken-bottom-right-container) debug-point

binary

11000000
01110000
00111100
00110010
00000010
00011100
11100000
00000000

1x1sprite broken-bottom-right-container

decimal  -->

( graphic-bl graphic-space ) debug-point

-->  \ XXX OLD

binary

  \ blank
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

1x1sprite graphic-bl
: graphic-space  ( -- )  graphic-bl .1x1sprite  ;

decimal  -->

( sprites ) debug-point

  \ XXX OLD

binary
0000000000000000
0000000000001000
0000000000001100
0000111111111110
0000111111111111
0000111111111110
0000000000001100
0000000000001000

2x1sprite right-arrow
sprite-string right-arrow$  ( -- ca len )

decimal  -->

( sprites ) debug-point

  \ XXX OLD

binary
0000000000000000
0001000000000000
0011000000000000
0111111111110000
1111111111110000
0111111111110000
0011000000000000
0001000000000000

2x1sprite left-arrow
sprite-string left-arrow$  ( -- ca len )

decimal  -->

( sprites ) debug-point

  \ XXX OLD

binary
0000111111110000
0011000000001100
0011000000001100
0010111111110100
0010000000000100
0010000000000100
0010000000000100
1111111111111111

2x1sprite fire-button
sprite-string fire-button$  ( -- ca len )

decimal  -->

( centered center-type )  debug-point

: centered  ( len -- column )  columns swap - 2/  ;
  \ Convert a string length to the column required
  \ to print the string centered.

: centered-at  ( row len -- )  centered swap at-xy  ;
  \ Set the cursor position to print string _ca len_ centered
  \ on the given row.

: center-type  ( ca len row -- )  over centered-at type  ;
  \ Print string _ca len_ centered on the given row.

: type-blank  ( ca len -- )  nip spaces  ;

: center-type-blank  ( ca len row -- )
  over centered-at type-blank ;
  \ Overwrite string _ca len_ with blanks, centered on the given row.

17 constant message-y  \ row for game messages

: message  ( ca len -- )
  2dup message-y text-color center-type  1500 ms
       message-y center-type-blank  ;
  \ Print a game message _ca len_.

-->

( instructions ) debug-point

: title  ( -- )  s" NUCLEAR INVADERS" 0 center-type  ;

: (c)  ( -- )  127 emit  ;
  \ Print the copyright symbol.

: .copyright  ( -- )
  row
  1 over    at-xy (c) ."  2013 Scainet Soft"
  1 over 1+ at-xy (c) ."  2016 Marcos Cruz"
  8 swap 2+ at-xy           ." (programandala.net)"  ;
  \ Print the copyright notice at the current row.

-->

( instructions ) debug-point

  \ XXX OLD
  \ : .control  ( n -- )  ."  = " .kk# 4 spaces  ;
  \ : .controls  ( -- )
  \   row dup s" [Space] to change controls:" rot center-type
  \   9 over 2+  at-xy ." Left " kk-left#  .control
  \   9 over 3 + at-xy ." Right" kk-right# .control
  \   9 swap 4 + at-xy ." Fire " kk-fire#  .control  ;
  \   \ Print controls at the current row.

: left-key$   ( -- ca len )  kk-left# kk#>string  ;
: right-key$  ( -- ca len )  kk-right# kk#>string  ;
: fire-key$   ( -- ca len )  kk-fire# kk#>string  ;

: controls$  ( -- ca len )
  left-arrow$ left-key$ s+
  s"   " s+ fire-key$ s+ s"   " s+
  right-key$ s+ right-arrow$ s+  ;
  \ String containing the description of the current controls.
  \ XXX TMP --
  \ XXX TODO -- rewrite

: .controls  ( -- )
  s" [Space] to change controls:" row dup >r center-type
  fire-button$ r@ 2+ center-type
  0 r@ 3 + at-xy columns spaces
  controls$ r> 3 + center-type  ;
  \ Print controls at the current row.
  \ XXX TMP --
  \ XXX FIXME -- these UDG become corrupted after the game

-->

( instructions ) debug-point

: .score-table-item  ( ca1 len1 ca2 len2 -- )
  type text-color ."  = " type  ;
  \ Print an item of the score table, with sprite string _ca2
  \ len2_ and description _ca1 len1_
9 constant score-table-x

: .score-table  ( -- )
  score-table-x row
  2dup     at-xy s" 10 points"
           invader-color invader-1$ .score-table-item
  2dup 2+  at-xy s" 20 points"
           invader-color invader-2$ .score-table-item
  2dup 4 + at-xy s" 30 points"
           invader-color invader-3$ .score-table-item
       6 + at-xy s" bonus"
           ufo-color ufo$ .score-table-item  ;
   \ Print the score table at the current row.

-->

( instructions ) debug-point

: at-controls  ( -- )  0 12 at-xy  ;

: show-controls  ( -- )  at-controls .controls  ;

: menu  ( -- )
  begin
    break-key? if  quit  then  \ XXX TMP
    key
    dup enter-key = if  drop exit  then
               bl = if  next-controls show-controls  then
  again  ;

-->

( instructions ) debug-point

: instructions  ( -- )
  text-color  cls  title
  0 3 at-xy .score-table
  show-controls
  s" [Enter] to start" 18 center-type
  0 21 at-xy .copyright
  menu  ;

-->

( game-screen ) debug-point

arena-bottom-y arena-top-y - 1+ columns * constant /arena
  \ Number of characters and attributes of the arena.
arena-top-y columns * attributes + constant arena-top-attribute
  \ Address of the first attribute of the arena.

: black-arena  ( -- )  arena-top-attribute /arena erase  ;
  \ Make the arena black.

: wipe-arena  ( -- )  0 arena-top-y at-xy /arena spaces  ;
  \ Clear the arena (the whole screen except the status bars).
  \ XXX TODO -- wipe attributes first

: -arena  ( -- )  black-arena wipe-arena  ;
  \ XXX FIXME -- this deletes the bar

: score-bar$  ( -- ca len )
  text-color s"  SCORE<1>    RECORD    SCORE<2>"  ;

: score-bar  ( -- )
  home score-bar$ type .score .record  ;
  \ XXX TODO -- support player 2

: show-player  ( -- )
  10 0 do  at-score 4 spaces 64 ms  .score 64 ms  loop  ;
  \ Show the current player by making its score blink.

-->

( game-screen ) debug-point

: row>pixel  ( n1 -- n2 )  8 * 191 swap -  ;
  \ Convert a row (0..23) to a pixel y coordinate (0..191).

: bar-ruler  ( -- )
  text-color
  [ tank-y row>pixel 8 - ] literal
  0 over plot  255 swap adraw  ;
  \ Draw the ruler of the status bar.

: at-lifes  ( -- )  0 status-bar-y at-xy  ;

: .lifes  ( -- )
  at-lifes life-color
  lifes @ 0 ?do  tank$ type  loop  ."   "  ;
  \ Print one icon for each remaining life.

: status-bar  ( -- )  bar-ruler .lifes  ;

: game-screen  ( -- )  init-colors cls score-bar status-bar  ;

-->

( udg/invader invaders-min-x invaders-max-x ) debug-point

                    0 constant invaders-min-x
columns udg/invader - constant invaders-max-x

-->

( invaders-data ) debug-point

  \ Invaders data is stored in a table.
  \ which has the following structure:
  \
  \ +0 = units (0..3)
  \ +2 = active? (0..1)
  \ +4 = y row
  \ +6 = x coordinate (column)
  \ +8 = main graphic (character)

  \ The `invader` variable points to the data of the current
  \ invader in the table.

     10 constant invader-types
6 cells constant /invader-type

create default-invaders-data
  \ Default invaders data table.
  \ This is used to restore the actual data table
  \ before a new game.

here

  \ units   active? y    x                 sprite       x inc
    3 ,     0 ,      5 , invaders-min-x ,  invader-3 ,   1 ,
    3 ,     0 ,      7 , invaders-min-x ,  invader-2 ,   1 ,
    3 ,     0 ,      9 , invaders-min-x ,  invader-2 ,   1 ,
    3 ,     0 ,     11 , invaders-min-x ,  invader-1 ,   1 ,
    3 ,     0 ,     13 , invaders-min-x ,  invader-1 ,   1 ,
    3 ,     0 ,      5 , invaders-max-x ,  invader-3 ,  -1 ,
    3 ,     0 ,      7 , invaders-max-x ,  invader-2 ,  -1 ,
    3 ,     0 ,      9 , invaders-max-x ,  invader-2 ,  -1 ,
    3 ,     0 ,     11 , invaders-max-x ,  invader-1 ,  -1 ,
    3 ,     0 ,     13 , invaders-max-x ,  invader-1 ,  -1 ,

here swap - constant /invaders-data  -->
  \ Space occupied by the invaders data.

  \ XXX TODO -- convert tables to standard structures

( invaders-data ) debug-point

create invaders-data  /invaders-data allot
  \ Current invaders data.

: >invader   ( -- n )  invader-type @ /invader-type *  ;
  \ Pointer of current invader type in a data table.

: 'invader   ( -- a )  >invader invaders-data +  ;
  \ Data address _a_ of the current invader type.

: 'default-invader   ( -- a )
  >invader default-invaders-data +  ;
  \ Default data address _a_ of the current invader type.

: invader-units   ( -- a )  'invader            ;
: invader-active  ( -- a )  'invader cell+      ;
: invader-y       ( -- a )  'invader [ 2 cells ] literal +  ;
: invader-x       ( -- a )  'invader [ 3 cells ] literal +  ;

: invader-xy@    ( -- x y )  invader-y 2@  ;
: invader-char@  ( -- c )  'invader [ 4 cells ] literal + @  ;

: invader-x-inc@  ( -- n )  'invader [ 5 cells ] literal + @  ;

: invader-default-x@    ( -- x y )
  'default-invader [ 3 cells ] literal + @  ;

-->

( set-building-size ) debug-point

 4 constant building-top-y
15 constant building-bottom-y

variable building-width

variable building-left-x     variable building-right-x
variable containers-left-x   variable containers-right-x

: set-building-size  ( -- )
  level @ 2* 2+  building-width !
  [ columns 2/ 1- ] literal \ half of the screen
  level @ \ half width of all containers
  2dup 1- - containers-left-x !
  2dup    - building-left-x !
  2dup    + containers-right-x !
       1+ + building-right-x !  ;
  \ Set the size of the building after the current level.

-->

( increase-level update-level init-level ) debug-point

5 constant max-level

: increase-level  ( -- )  level @ 1+ max-level min level !  ;
  \ Increase the level number.

: update-level  ( -- )  increase-level set-building-size  ;

: init-level  ( -- )  level off  update-level  ;
  \ Init the level number and the related variables
  \ (the size of the bulding).

-->

( building ) debug-point

: floor  ( y -- )
  building-left-x @ swap at-xy
  brick-color brick building-width @ .1x1sprites  ;
  \ Draw a floor of the building at row _y_.

: building-top  ( -- )  building-top-y floor  ;
  \ Draw the top of the building.

: building-bottom  ( -- )  building-bottom-y  floor  ;
  \ Draw the bottom of the building.

  \ XXX OLD
  \ here 1+ s\" \x95\x97\x98\x97\x98\x97\x98\x97\x98\x97\x98" s,
  \ constant containers-top
  \ here 1+ s\" \x95\x99\x9A\x99\x9A\x99\x9A\x99\x9A\x99\x9A" s,
  \ constant containers-bottom
  \ Compile strings which hold a brick followed by nuclear
  \ containers (top and bottom parts) and save the addresses of
  \ their first char.

: containers-bottom  ( n -- )
  container-color
  0 ?do  container-bottom .2x1sprite  loop  ;
  \ Draw a row of _n_ bottom parts of containers.

: containers-top  ( n -- )
  container-color
  0 ?do  container-top .2x1sprite  loop  ;
  \ Draw a row of _n_ top parts of containers.

-->

( building ) debug-point

: .brick  ( -- )  brick-color brick .1x1sprite  ;
  \ Draw a brick.

: building  ( -- )
  building-bottom
  level @  building-left-x @
  building-top-y [ building-bottom-y 2- ] literal
  do
    2dup i 1+ at-xy .brick containers-bottom .brick
    2dup i    at-xy .brick containers-top    .brick
  -2 +loop  2drop  building-top  ;
  \ Draw the building and the nuclear containers.

-->

( drive ) debug-point

  \ XXX TODO -- try

                    1 constant tank-min-x
columns udg/tank - 1- constant tank-max-x
  \ Mininum and maximin columns of the tank.

: tank-range  ( column -- column' )
  tank-max-x min tank-min-x max  ;
  \ Adjust the given column to the limits of the tank.

: ?space   ( -- )  column if  text-color space  then  ;
  \ Print a space, if current column is not zero.

  \ : drive  ( -- )
  \   tank-x @ kk-left  pressed? +
  \            kk-right pressed? abs +
  \   tank-range dup tank-x !  tank-y
  \   at-xy tank-color ?space tank$ type ?space  ;
  \ Move the tank depending on the key pressed.
  \ XXX OLD
  \ XXX FIXME -- trails

  \ : drive-left  ( -- )
  \   tank-x @ if  -1 tank-@
  \   ;
  \ : drive-right  ( -- )  ;
  \   tank-range dup tank-x !  1- tank-y
  \   at-xy tank-color ?space tank$ type ?space

  \ : drive  ( -- )
  \   kk-left  pressed? if  drive-left  exit then
  \   kk-right pressed? if  drive-right      then  ;
  \   \ Move the tank depending on the key pressed.

: moving-tank?  ( -- -1|0|1 )
  kk-left pressed? kk-right pressed? abs +  ;
  \ Does the tank move? Return its x increment.

: .tank  ( -- )  tank-color tank$ type  ;
  \ Print the tank at the current cursor position.
  \ XXX FIXME -- spaces depend on the direction,
  \ thus this can't work in x range 0..31.

-->

( drive ) debug-point

  \ XXX TODO -- try

: at-tank  ( -- )  tank-x @ tank-y at-xy  ;
: tank-ready  ( -- )  at-tank .tank  ;
: -tank  ( -- )  at-tank text-color 2 spaces  ;

: move-tank  ( -1|1 -- )
  tank-x @ + tank-range dup tank-x ! tank-y at-xy  ;
  \ Set the cursor position to the coordinates of the tank,
  \ after incrementing its column with the given value.

: drive  ( -- )
  moving-tank? ?dup 0= ?exit  -tank move-tank .tank  ;
  \ XXX FIXME -- don't delete the whole tank

-->

( init ) debug-point

: init-game  ( -- )
  init-ocr  3 lifes !  init-level  score off  game-screen  ;

: init-invaders-data  ( -- )
  default-invaders-data invaders-data /invaders-data move  ;

: init-ufo  ( -- )  -200 ufo-x !  ;

: total-invaders  ( -- n )
  0   invader-types 0 do
        i invader-type ! invader-units @ +
      loop  ;
  \ Total number of invaders (sum of units of all invader
  \ types).

: init-invaders  ( -- )
  init-invaders-data  invader-type off
  total-invaders invaders !  ;

: init-tank  ( -- )
  columns udg/tank - 2/ tank-x !  \ middle of the screen
  projectile-y off  ;  -->

( init ) debug-point

: parade  ( -- )
  invader-color
  invader-1 dup invader-2 dup invader-3
  building-bottom-y [ building-top-y 1+ ] literal
  do
    invaders-min-x i at-xy dup .2x1sprite
    invaders-max-x i at-xy     .2x1sprite
  2 +loop  ;
  \ Show the invaders at their initial positions.

: init-arena  ( -- )   -arena building tank-ready parade  ;

: level-message  ( -- ca len )
  text-color s" LEVEL " level @ s>d <# # #> s+  ;

: show-level  ( -- ) level-message message  ;

: init-combat  ( -- )
  catastrophe off init-invaders init-ufo init-tank init-arena
  show-level show-player  ;  -->

( invasion ) debug-point

: at-invader  ( -- )  invader-xy@ at-xy  ;
  \ Set the cursor position at the coordinates of the invader.

4 constant frames/invader

: sprite>frame  ( c1 x -- c2 )
  frames/invader mod udg/invader * +  ;
  \ Frame _c2_ of sprite _c1_, calculated from its column _x_.

: invader-frame  ( -- c )
  invader-char@ invader-x @ sprite>frame  ;
  \ Frame of the invader, calculated from its column _x_.

: .invader  ( -- )  invader-color invader-frame .2x1sprite  ;
  \ Print the current invader.

-->

( invasion )

variable broken-wall-x
  \ Column of the wall broken by the current alien.

: flying-to-the-right?  ( -- f )  invader-x-inc@ 0>  ;
  \ Is the current invader flying to the right?

red papery c,  here  red c,  constant broken-brick-colors
  \ Address of the broken brick color used for the right
  \ side of the building; the address before contains
  \ the color used for the left side of the building.
  \ This is faster than pointing to a list of two colors,
  \ because a flag (0|-1) can be used as index.

: broken-wall-color  ( -- )
  broken-brick-colors flying-to-the-right? + c@ set-color  ;
  \ Set the color of the broken wall.  It depends on the side
  \ of the building, because the same two UDGs are used for
  \ both sides, with inverted colors.

: broken-bricks-coordinates  ( -- x1 y1 x2 y2 )
  broken-wall-x @ invader-y @ 1+  2dup 2-  ;
  \ Coordinates of the broken brick above the invader, _x2 y2_,
  \ and below it, _x1 y1_.

: broken-left-wall  ( -- )
  broken-bricks-coordinates
  at-xy broken-bottom-brick .1x1sprite
  at-xy broken-top-brick  .1x1sprite  ;

: broken-right-wall  ( -- )
  broken-bricks-coordinates
  at-xy broken-top-brick .1x1sprite
  at-xy broken-bottom-brick .1x1sprite  ;  -->

  \ XXX TODO -- detect if the wall is already broken, and
  \ change the graphic accordingly.

( invasion )

: broken-wall  ( -- )
  broken-wall-color flying-to-the-right?
  if  broken-left-wall  else  broken-right-wall  then  ;
  \ Show the broken wall of the building, hit by the current invader.

: broken-wall?  ( -- f )
  invader-x @ flying-to-the-right?
  if    1+ building-left-x
  else  building-right-x
  then  @ dup broken-wall-x ! =  ;
  \ Has the current invader broken the wall of the building?

-->

( invasion )

: broken-left-container  ( -- )
  invader-x @ 2+ invader-y @ at-xy
  broken-top-right-container .1x1sprite
  invader-x @ 1+ invader-y @ 1+ at-xy
  broken-bottom-left-container .1x1sprite  ;
  \ Broke the container on its left side.

: broken-right-container  ( -- )
  invader-x @ 1- invader-y @ at-xy
  broken-top-left-container .1x1sprite
  invader-x @ invader-y @ 1+ at-xy
  broken-bottom-right-container .1x1sprite  ;
  \ Broke the container on its right side.

-->

( invasion )

: broken-container  ( -- )
  container-color
  flying-to-the-right?  if    broken-left-container
                        else  broken-right-container  then  ;
  \ Broke the container.

: broken-container?  ( -- f )
  invader-x @ flying-to-the-right?
  if    1+ containers-left-x
  else     containers-right-x  then  @ =  ;
  \ Has the current invader broken a container?

-->

( invasion )

: damages  ( -- )
  broken-wall? if  broken-wall exit  then
  broken-container? dup if    broken-container
                        then  catastrophe !  ;
  \ Manage the possible damages caused by the current invader.
  \ XXX TODO -- change the graphic of the container

: flying-invader  ( -- )
  invader-x-inc@ dup 0>  \ flying to the right?
  if    at-invader text-color space .invader invader-x +!
  else  invader-x +! at-invader .invader ?space  then  ;
  \ Note: `text-color` is needed because the paper color
  \ may have changed.

-->

( invasion ) debug-point

: activate-invader  ( -- )
  32 random  26 invaders @ 5 < 16 * -  > invader-active !  ;
  \ Activate the current invader, depending on a random
  \ calculation: If there are less than 5 invaders left, the
  \ chances of activation are 22/32, else 6/32.
  \ XXX TODO -- Simpler and faster? Proportional to the
  \ number of invaders?

: last-invader-type?  ( -- f )
  invader-type @ [ invader-types 1- ] literal =  ;
  \ Is the current invader type the last one?

: next-invader  ( -- )
  last-invader-type?
  if  invader-type off  else  1 invader-type +!  then  ;
  \ Update the invader type to the next one.

variable delay  50 delay !  \ ms

: move-invader  ( -- )
  delay @ ms  \ XXX TMP --
  invader-active @
  if  flying-invader damages  else  activate-invader  then  ;
  \ Move the current invader if it's active, else
  \ just try to activate it.

: invasion  ( -- )
  invader-units @ if  move-invader  then  next-invader  ;
  \ Move the current invader, if there are units left of it,
  \ and then choose the next one.

-->

( ufo ) debug-point

 3 constant ufo-y       \ row
27 constant ufo-max-x   \ column

: ufo-invisible?  ( -- f )  ufo-x @ 0<  ;
  \ Is the UFO invisible?

: at-ufo  ( -- )  ufo-x @ ufo-y at-xy  ;
  \ Set the cursor position at the coordinates of the UFO.

: -ufo  ( -- )  at-ufo 3 spaces init-ufo  ;
  \ Delete and init the UFO.

: ufo-lost?  ( -- f )  ufo-x @ ufo-max-x >  ;
  \ Is the UFO lost?

: ufo-frame  ( -- c )  ufo ufo-x @ sprite>frame  ;

: flying-ufo  ( -- )
  1 ufo-x +! at-ufo ufo-color space ufo-frame .2x1sprite  ;
  \ Update the position of the UFO and show it.

: (move-ufo)  ( -- )
  ufo-lost?  if  -ufo  else  flying-ufo  then  ;
  \ Manage the UFO.

: move-ufo  ( -- )
  ufo-invisible? if  1 ufo-x +!  else  (move-ufo)  then  ;
  \ Manage the UFO, if it's visible.

-->

( ufo-impacted ) debug-point

: ufo-bang  ( -- )  18 12 do  i 15 beep  loop  ;
  \ XXX TODO -- explosion sound

: ufo-on-fire  ( -- )
  ufo-x @ 1+ ufo-y at-xy ufo-explosion$ type  ;

: ufo-explosion  ( -- )  ufo-on-fire ufo-bang  ;

: ufo-points  ( -- n )  32 random 12 / 1+ 50 *  ;
  \ Random points for impacting the UFO.

: ufo-bonus  ( -- )
  ufo-points dup ufo-x @ 1+ ufo-y at-xy .  update-score  ;
  \ Update the score with the UFO bonus.

: ufo-impacted  ( -- )  ufo-explosion ufo-bonus 200 ms -ufo  ;

-->

( invader-impacted ) debug-point

: invader-points  ( -- n )
  projectile-y @ 3 - 2/          \ depending on the row
  \ projectile-x @ 15 > abs 5 * +  \ add 5 when x>15  -- XXX why?
  projectile-y @
  dup 5 = if  drop 30
          else  10 > 10 * 20 +  then  ;
  \ Points for impacting an invader.
  \ XXX TODO -- simplify

: invader-bonus  ( -- )  invader-points  update-score  ;
  \ Update the score with the invader bonus.

: invader-bang  ( -- ca len )  10 100 beep  ;
  \ XXX TODO -- explosion sound

: invader-on-fire  ( -- )
  at-invader invader-explosion$ type  ;

: -invader  ( -- )  at-invader 2 spaces  ;
  \ Delete the current invader.

: invader-explosion  ( -- )
  invader-on-fire invader-bang -invader  ;

-->

( invader-impacted ) debug-point

: impacted-invader  ( -- n )
  projectile-y @ [ building-top-y 1+ ] literal - 2/
  projectile-x @ [ columns 2/ ] literal > abs 5 * +  ;
  \ Invader type impacted calculated from the projectile
  \ coordinates: Invader types 0 and 5 are at the top, one row
  \ below the top of the building, types 1 and 6 are two lines
  \ below and so on. Types 0..4 are at the left of the
  \ screen; types 5..9 are at the right.

: replace-invader  ( -- )
  invader-active off
  invader-default-x@ invader-x !  at-invader
  invader-color invader-char@ .2x1sprite  ;
  \ Replace the current invader with its next unit.
  \ Set it inactive at its start position.

: current-invader-impacted  ( -- )
  invader-bonus invader-explosion
  -1 invaders +!  -1 invader-units +!
  invader-units @ if  replace-invader  then  ;
  \ The current invader has been impacted by the projectile.

: invader-impacted  ( -- )
  invader-type @ >r  impacted-invader invader-type !
  current-invader-impacted  r> invader-type !  ;  -->
  \ A invader has been impacted by the projectile.
  \ Calculate its type, set it the current one and manage it.

( impact ) debug-point

: (impact)  ( -- )
  projectile-y @ ufo-y = if  ufo-impacted exit  then
  invader-impacted  ;
  \ Manage the impact.

: impact  ( -- )
  projectile-y @ building-bottom-y <
  if  (impact)  then  projectile-y off  ;
  \ Manage the impact, if the projectil is high enough.

: projectile-xy  ( -- x y )  projectile-x @ projectile-y @  ;
  \ Coordinates of the projectile.

: hit?  ( -- f )  projectile-xy ocr 0<>  ;
  \ Did the projectile hit the target?

: impact?  ( -- f )  hit? dup if  impact  then  ;
  \ Did the projectil impacted?
  \ If so, do manage the impact.

-->

( shoot ) debug-point

: at-projectile  ( -- )  projectile-xy at-xy  ;
  \ Set the cursor position at the coordinates of the
  \ projectile.

: .projectile  ( -- )
  projectile-color at-projectile projectile .1x1sprite  ;
  \ Show the projectile.

: fire-sound  ( -- )  ;
  \ XXX TODO --

: fire  ( -- )
  tank-x @ projectile-x !
  [ tank-y 1- ] literal projectile-y !  fire-sound  ;
  \ The tank fires.
  \ XXX TODO -- several projectiles at the same time;
  \ pixels instead of characters

: -projectile  ( -- )  at-projectile text-color space  ;
  \ Delete the projectile.

: projectile-lost?  ( -- f )
  projectile-y @ building-top-y <  ;
  \ Is the projectile lost?

-->

( shoot ) debug-point

: shooted  ( -- )
  -projectile  projectile-lost? if  projectile-y off exit  then
  -1 projectile-y +! impact? ?exit
  .projectile  ;
  \ Manage the projectile.

: shooted?  ( -- f )  projectile-y @ 0<>  ;
  \ Has the tank already shooted?

: fire?  ( -- f )  kk-fire pressed?  ;
  \ Is the fire key pressed?

: shoot  ( -- )
  shooted? if  shooted exit  then  fire? if  fire  then  ;
  \ Manage the shoot.

-->

( new-record? new-record check-record ) debug-point

: new-record?   ( -- f )  score @ record @ >  ;
  \ Is there a new record?

: new-record    ( -- f )  score @ record !  ;
  \ Set the new record.

: check-record  ( -- )  new-record? if  new-record  then  ;
  \ Check if there's a new record, and set it.

-->

( alive game-over next-level ) debug-point

: .game-over  ( -- )  s" GAME OVER" message  ;

: game-over  ( -- )  .game-over check-record  ;

: next-level  ( -- )  update-level show-level  ;

: dead  ( -- )  -1 lifes +!  .lifes  ;
  \ One life lost.

: defeat-tune  ( -- )  100 200 do  i 20 beep  -5 +loop  ;

: defeat  ( -- )  defeat-tune  300 ms  dead  ;

-->

( run ) debug-point

: victory?  ( -- f )  invaders @ 0=  ;

: (combat)  ( -- )
  begin   victory? if  next-level init-combat  then
          break-key? if  quit  then  \ XXX TMP
          drive shoot move-ufo invasion  catastrophe @
  until   defeat  ;

: combat  ( -- )  init-combat (combat)  ;

: defeat?  ( f )  lifes @ 0=  ;

: game  ( -- )
  init-game  begin  combat defeat?  until  game-over  ;

: run  ( -- )  begin  instructions game  again  ;

-->

( Debugging tools)

  \ Words for testing and debugging the game.

: .udgs  ( -- )  cr udgs 0 do  i 128 + emit  loop  ;
  \ Print all game UDGs.

: ni  ( -- )      next-invader  ;
: m   ( -- )      move-invader broken-container? home .  ;
: in  ( -- )      init-game init-combat  ;

-->

( Debugging tools)

: bc  ( -- )
  cls
  \ top:
  space broken-top-right-container .1x1sprite
  container-top .2x1sprite
  broken-top-left-container .1x1sprite space cr
  \ bottom:
  container-bottom .2x1sprite 8 emit 8 emit
  broken-bottom-left-container .1x1sprite
  xy swap 1+ swap at-xy
  container-bottom .2x1sprite
  container-bottom .2x1sprite 8 emit
  broken-bottom-right-container .1x1sprite cr  ;
  \ Show the graphics of the broken containers.

init-level

  \ ==========================================================
  \ History

  \ This is mainly a compilation of the git commit comments.

  \ 2016-02-14:
  \
  \ Started changing the layout of the original
  \ source code.
  \
  \ 2016-02-15:
  \
  \ - Convert the source to lowercase.
  \ - Rename Spanish words to English.
  \ - Rename variables using meaningful names.
  \ - Indent the word definitions and the control structures.
  \ - Split lines at 63 columns.
  \ - Add block titles.
  \
  \ 2016-02-16:
  \
  \ - Convert the graphics to binary numbers.
  \ - Implement words to define the graphics.
  \ - Adapt the invaders' data.
  \ - Factorize some words.
  \ - Adapt ACE Forth's `pick`.
  \ - Optimize some code idioms.
  \
  \ 2016-02-17:
  \
  \ - Factor the shoot manager.
  \ - Factor the invaders' manager.
  \ - Make the printing of containers faster.
  \ - Improve the invaders' data manipulation.
  \ - Convert the last `at-yx` to `at-xy`.
  \ - Add first words to support color.
  \ - Factor, modify and combine the presentation and
  \   instructions screens.
  \ - Name the main sprites.
  \ - Improve the logic of the game round loop.
  \ - Factor the arena screen.
  \ - Factor the printing of lifes.
  \
  \ 2016-02-18:
  \
  \ - Fix record init.
  \ - Fix access to invaders' data.
  \ - Factor status bar.
  \ - Simplify printing of lifes (number and icons).
  \ - Simplify selecting the font.
  \ - Fix the phase incrementer.
  \
  \ 2016-02-19:
  \
  \ - Factor the calculation of the last invader type.
  \ - Factor the calculation of the invaders' direction.
  \ - Factor and fix the ending condition in the combat loop.
  \ - Fix the invaders' data.
  \ - Fix the reading of movement keys.
  \ - Fix and improve the phase update.
  \ - Fix the initial position of the building and the
  \   invaders.
  \ - Standardize the pauses.
  \ - Add the invaders' direction to the data table.
  \ - Fix the movement of invaders.
  \ - Improve access to both coordinates of current invader.
  \
  \ 2016-02-20:
  \
  \ - Improve the keyboard reading.
  \ - Make the keyboard controls configurable.
  \ - Fix the storage of invaders' coordinates as a double
  \ number.
  \ - Fix and improve the calculation of the building size.
  \ - Fix the increasing of the level.
  \ - Fix the printing of lifes.
  \ - Fix the OCR init.
  \ - Add level 1.
  \
  \ 2016-02-21:
  \
  \ - Fix the printing of score.
  \ - Fix shooting and impacting.
  \
  \ 2016-02-22:
  \
  \ - Change the graphic codes.
  \ - Change the layout of controls' menu.
  \
  \ 2016-02-23:
  \
  \ - Factor the explosion of invaders.
  \ - Make the usage of UDG codes automatic.
  \
  \ 2016-02-24:
  \
  \ - Add color.
  \ - Fix calculation of maximum number of controls.
  \ - Add broken walls effect.
  \ - Use 4 frames per invader instead of 2.
  \ - Set initial position of invaders at the margins of the
  \ screen.
  \ - Set initial position of the tank at the center of its
  \ row.
  \ - Add broken container effect.
  \ - Fix the color of the number of lifes.
  \
  \ 2016-03-25:
  \
  \ - Update to the new organization of the Solo Forth library.
  \ - Fix the status bar.
  \ - Modify the printing of lifes.
  \ - Fix the count of controls.

  \ vim: filetype=soloforth
